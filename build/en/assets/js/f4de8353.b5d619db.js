"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[81835],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>g});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=s(n),m=o,g=d["".concat(c,".").concat(m)]||d[m]||u[m]||r;return n?a.createElement(g,l(l({ref:t},p),{},{components:n})):a.createElement(g,l({ref:t},p))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,l=new Array(r);l[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[d]="string"==typeof e?e:o,l[1]=i;for(var s=2;s<r;s++)l[s]=n[s];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},2052:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>s});var a=n(87462),o=(n(67294),n(3905));const r={title:"Transaction Isolation",keywords:["Seata Transaction Isolation"],description:"Seata Transaction Isolation"},l="Seata Transaction Isolation",i={unversionedId:"user/appendix/isolation",id:"version-v1.7/user/appendix/isolation",title:"Transaction Isolation",description:"Seata Transaction Isolation",source:"@site/i18n/en/docusaurus-plugin-content-docs/version-v1.7/user/appendix/isolation.md",sourceDirName:"user/appendix",slug:"/user/appendix/isolation",permalink:"/en/docs/user/appendix/isolation",draft:!1,tags:[],version:"v1.7",frontMatter:{title:"Transaction Isolation",keywords:["Seata Transaction Isolation"],description:"Seata Transaction Isolation"},sidebar:"docs",previous:{title:"Global Transaction Status",permalink:"/en/docs/user/appendix/global-transaction-status"},next:{title:"Seata AT Mode",permalink:"/en/docs/dev/mode/at-mode"}},c={},s=[{value:"Starting with the Proxy Data Source",id:"starting-with-the-proxy-data-source",level:2},{value:"<strong>Processing logic of <code>StatementProxy.executeXXX()</code></strong>",id:"processing-logic-of-statementproxyexecutexxx",level:3},{value:"<strong>Handling logic of <code>ConnectionProxy.commit()</code></strong>",id:"handling-logic-of-connectionproxycommit",level:3},{value:"<strong>Purpose of <code>@GlobalTransactional</code></strong>",id:"purpose-of-globaltransactional",level:3},{value:"<strong>Purpose of <code>@GlobalLock</code> + <code>select for update</code></strong>",id:"purpose-of-globallock--select-for-update",level:3},{value:"Let&#39;s first give an example of dirty write, and then see how Seata prevents dirty write",id:"lets-first-give-an-example-of-dirty-write-and-then-see-how-seata-prevents-dirty-write",level:2},{value:"<strong>How to prevent dirty write using Seata?</strong>",id:"how-to-prevent-dirty-write-using-seata",level:2},{value:"Method 1: Add <code>@GlobalTransactional</code> to <code>updateA()</code> as well, how does Seata ensure transaction isolation in this case?",id:"method-1-add-globaltransactional-to-updatea-as-well-how-does-seata-ensure-transaction-isolation-in-this-case",level:3},{value:"Method 2: <strong>@GlobalLock + select for update</strong>",id:"method-2-globallock--select-for-update",level:3},{value:"<strong>How to prevent dirty reads?</strong>",id:"how-to-prevent-dirty-reads",level:2},{value:"Scenario:   One business calls <code>updateAll()</code> first, <code>updateAll()</code> is not completed, and then another business calls <code>queryA()</code>",id:"scenario---one-business-calls-updateall-first-updateall-is-not-completed-and-then-another-business-calls-querya",level:3},{value:"<strong>The role of DataSourceProxy</strong>",id:"the-role-of-datasourceproxy",level:2},{value:"<strong>Get <code>StatementProxy</code> through <code>ConnectionProxy.prepareStatement(...)</code></strong>",id:"get-statementproxy-through-connectionproxypreparestatement",level:2},{value:"<strong>Processing logic for <code>StatementProxy.execute()</code></strong>",id:"processing-logic-for-statementproxyexecute",level:2},{value:"<strong>Processing Logic of <code>ConnectionProxy.commit()</code></strong>",id:"processing-logic-of-connectionproxycommit",level:2},{value:"Introduction to <code>RootContext</code>",id:"introduction-to-rootcontext",level:2},{value:"<strong><code>GlobalTransactionalInterceptor</code> handles methods with <code>@GlobalTransactional</code> or <code>@GlobalLock</code></strong>",id:"globaltransactionalinterceptor-handles-methods-with-globaltransactional-or-globallock",level:2},{value:"<strong>First, handle <code>@GlobalTransactional</code></strong>",id:"first-handle-globaltransactional",level:3},{value:"<strong>Continue to handle <code>@GlobalLock</code></strong>",id:"continue-to-handle-globallock",level:3}],p={toc:s},d="wrapper";function u(e){let{components:t,...r}=e;return(0,o.kt)(d,(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"seata-transaction-isolation"},"Seata Transaction Isolation"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"This article aims to help users understand how to correctly implement transaction isolation when using Seata ",(0,o.kt)("strong",{parentName:"p"},"AT mode")," to prevent dirty reads and writes."),(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"It is expected that readers have already read the introduction to the AT mode on the Seata official website and have an understanding of local database locks.")),(0,o.kt)("p",{parentName:"blockquote"},"(For example, when two transactions are simultaneously updating the same record, only the transaction that holds the record lock can update successfully, while the other transaction must wait until the record lock is released, or until the transaction times out)")),(0,o.kt)("p",null,'First, take a look at this piece of code. Although it looks "basic," the main thing that the persistence layer framework actually does for us is just that.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'@Service\npublic class StorageService {\n\n    @Autowired\n    private DataSource dataSource;\n\n    @GlobalTransactional\n    public void batchUpdate() throws SQLException {\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        try {\n            connection = dataSource.getConnection();\n            connection.setAutoCommit(false);\n            String sql = "update storage_tbl set count = ?" +\n                "    where id = ? and commodity_code = ?";\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.setInt(1, 100);\n            preparedStatement.setLong(2, 1);\n            preparedStatement.setString(3, "2001");\n            preparedStatement.executeUpdate();\n            connection.commit();\n        } catch (Exception e) {\n            throw e;\n        } finally {\n            IOutils.close(preparedStatement);\n            IOutils.close(connection);\n        }\n    }\n\n}\n')),(0,o.kt)("h2",{id:"starting-with-the-proxy-data-source"},"Starting with the Proxy Data Source"),(0,o.kt)("p",null,"When using the AT mode, the most important thing is the proxy data source. So what is the purpose of using ",(0,o.kt)("inlineCode",{parentName:"p"},"DataSourceProxy")," to proxy the data source?"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"DataSourceProxy")," can help us obtain several important proxy objects"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Obtain ",(0,o.kt)("inlineCode",{parentName:"p"},"ConnectionProxy")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"DataSourceProxy.getConnection()"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Obtain ",(0,o.kt)("inlineCode",{parentName:"p"},"StatementProxy")," through ",(0,o.kt)("inlineCode",{parentName:"p"},"ConnectionProxy.prepareStatement(...)")))),(0,o.kt)("p",null,"Seata's implementation of transaction isolation is hidden in these 2 proxies, let me outline the implementation logic first."),(0,o.kt)("h3",{id:"processing-logic-of-statementproxyexecutexxx"},(0,o.kt)("strong",{parentName:"h3"},"Processing logic of ",(0,o.kt)("inlineCode",{parentName:"strong"},"StatementProxy.executeXXX()"))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"When calling ",(0,o.kt)("inlineCode",{parentName:"p"},"io.seata.rm.datasource.StatementProxy.executeXXX()"),", the SQL is passed to ",(0,o.kt)("inlineCode",{parentName:"p"},"io.seata.rm.datasource.exec.ExecuteTemplate.execute(...)")," to process."),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"In the ",(0,o.kt)("inlineCode",{parentName:"li"},"ExecuteTemplate.execute(...)")," method, Seata uses different Executers based on different ",(0,o.kt)("inlineCode",{parentName:"li"},"dbType")," and SQL statement types, and calls the ",(0,o.kt)("inlineCode",{parentName:"li"},"execute(Object... args)")," method of the ",(0,o.kt)("inlineCode",{parentName:"li"},"io.seata.rm.datasource.exec.Executer")," class."),(0,o.kt)("li",{parentName:"ul"},"If a DML type Executer is chosen, the following main actions are performed:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Pre-query image (select for update, obtaining local lock at this time)"),(0,o.kt)("li",{parentName:"ul"},"Execute business SQL"),(0,o.kt)("li",{parentName:"ul"},"Post-query image"),(0,o.kt)("li",{parentName:"ul"},"Prepare undoLog"))),(0,o.kt)("li",{parentName:"ul"},"If your SQL is ",(0,o.kt)("inlineCode",{parentName:"li"},"select for update"),", then ",(0,o.kt)("inlineCode",{parentName:"li"},"SelectForUpdateExecutor")," will be used (Seata proxies ",(0,o.kt)("inlineCode",{parentName:"li"},"select for update"),"), and the logic for post-processing after proxying is as follows:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"First, execute select for update (obtain the database's local lock)"),(0,o.kt)("li",{parentName:"ul"},"If in ",(0,o.kt)("inlineCode",{parentName:"li"},"@GlobalTransactional")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"@GlobalLock"),", ",(0,o.kt)("strong",{parentName:"li"},"check")," if there is a global lock"),(0,o.kt)("li",{parentName:"ul"},"If there is a global lock, under the condition of not starting a local transaction, rollback the local transaction, then re-acquire the local lock and global lock, and so on, unless the global lock is obtained.")))))),(0,o.kt)("h3",{id:"handling-logic-of-connectionproxycommit"},(0,o.kt)("strong",{parentName:"h3"},"Handling logic of ",(0,o.kt)("inlineCode",{parentName:"strong"},"ConnectionProxy.commit()"))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"In a global transaction (i.e., the data persistence method has ",(0,o.kt)("inlineCode",{parentName:"li"},"@GlobalTransactional"),")",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Register branch transaction, obtain global lock"),(0,o.kt)("li",{parentName:"ul"},"UndoLog data persistence"),(0,o.kt)("li",{parentName:"ul"},"Let the database commit the current transaction"))),(0,o.kt)("li",{parentName:"ul"},"In ",(0,o.kt)("inlineCode",{parentName:"li"},"@GlobalLock")," (i.e., the data persistence method has ",(0,o.kt)("inlineCode",{parentName:"li"},"@GlobalLock"),")",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Query the TC for the existence of a global lock, and if it exists, throw an exception"),(0,o.kt)("li",{parentName:"ul"},"Let the database commit the current transaction"))),(0,o.kt)("li",{parentName:"ul"},"For other cases (the ",(0,o.kt)("inlineCode",{parentName:"li"},"else")," branch)",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Let the database commit the current transaction")))),(0,o.kt)("h3",{id:"purpose-of-globaltransactional"},(0,o.kt)("strong",{parentName:"h3"},"Purpose of ",(0,o.kt)("inlineCode",{parentName:"strong"},"@GlobalTransactional"))),(0,o.kt)("p",null,"Identifies a global transaction"),(0,o.kt)("h3",{id:"purpose-of-globallock--select-for-update"},(0,o.kt)("strong",{parentName:"h3"},"Purpose of ",(0,o.kt)("inlineCode",{parentName:"strong"},"@GlobalLock")," + ",(0,o.kt)("inlineCode",{parentName:"strong"},"select for update"))),(0,o.kt)("p",null,"If a method like ",(0,o.kt)("inlineCode",{parentName:"p"},"updateA()")," has ",(0,o.kt)("inlineCode",{parentName:"p"},"@GlobalLock + select for update"),", Seata, in processing, will first obtain a database local lock, then query if there is a global lock for that record, and if there is, it will throw a LockConflictException."),(0,o.kt)("h2",{id:"lets-first-give-an-example-of-dirty-write-and-then-see-how-seata-prevents-dirty-write"},"Let's first give an example of dirty write, and then see how Seata prevents dirty write"),(0,o.kt)("p",null,"Let's assume your business code is like this:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateAll()")," is used to update records in both table A and B, ",(0,o.kt)("inlineCode",{parentName:"li"},"updateA()")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"updateB()")," are used to update records in table A and B respectively"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateAll()")," has already been annotated with ",(0,o.kt)("inlineCode",{parentName:"li"},"@GlobalTransactional"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class YourBussinessService {\n\n    DbServiceA serviceA;\n    DbServiceB serviceB;\n\n    @GlobalTransactional\n    public boolean updateAll(DTO dto) {\n        serviceA.update(dto.getA());\n        serviceB.update(dto.getB());\n    }\n\n    public boolean updateA(DTO dto) {\n        serviceA.update(dto.getA());\n    }\n\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class DbServiceA {\n    @Transactional\n    public boolean update(A a) {\n    \n    }\n}\n")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"dirty-write",src:n(12556).Z,width:"1964",height:"1946"}),"\n|"),(0,o.kt)("h2",{id:"how-to-prevent-dirty-write-using-seata"},(0,o.kt)("strong",{parentName:"h2"},"How to prevent dirty write using Seata?")),(0,o.kt)("h3",{id:"method-1-add-globaltransactional-to-updatea-as-well-how-does-seata-ensure-transaction-isolation-in-this-case"},"Method 1: Add ",(0,o.kt)("inlineCode",{parentName:"h3"},"@GlobalTransactional")," to ",(0,o.kt)("inlineCode",{parentName:"h3"},"updateA()")," as well, how does Seata ensure transaction isolation in this case?"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class DbServiceA {\n\n    @GlobalTransactional\n    @Transactional\n    public boolean updateA(DTO dto) {\n\n        serviceA.update(dto.getA());\n\n    }\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateAll()")," is called first (not completed), ",(0,o.kt)("inlineCode",{parentName:"li"},"updateA()")," is called afterwards")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"dirty-write",src:n(33155).Z,width:"2236",height:"1932"})),(0,o.kt)("h3",{id:"method-2-globallock--select-for-update"},"Method 2: ",(0,o.kt)("strong",{parentName:"h3"},"@GlobalLock + select for update")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class DbServiceA {\n    \n    @GlobalLock\n    @Transactional\n    public boolean updateA(DTO dto) {\n\n        serviceA.selectForUpdate(dto.getA());\n\n        serviceA.update(dto.getA());\n\n    }\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"updateAll()")," is called first (not completed), ",(0,o.kt)("inlineCode",{parentName:"li"},"updateA()")," is called afterwards")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"dirty-write",src:n(21408).Z,width:"2860",height:"1830"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"What if ",(0,o.kt)("inlineCode",{parentName:"li"},"updateA()")," is called first (not completed), and then ",(0,o.kt)("inlineCode",{parentName:"li"},"updateAll()")," is called?\nSince both transactions need to acquire local locks first, dirty write will not occur."),(0,o.kt)("li",{parentName:"ul"},'Someone may ask, "Why do we need to add select for update here? Can\'t we prevent dirty write with just @GlobalLock?"\nYes. But please refer to the diagram above, select for update brings a few advantages:',(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},'Lock conflicts are handled more gracefully. If only @GlobalLock is used, it immediately throws an exception when a global lock is detected. It\'s a pity to release the global lock after a little "persistence" and throw an exception.'),(0,o.kt)("li",{parentName:"ul"},"In ",(0,o.kt)("inlineCode",{parentName:"li"},"updateA()"),", we can use select for update to get the latest A and then perform the update.")))),(0,o.kt)("h2",{id:"how-to-prevent-dirty-reads"},(0,o.kt)("strong",{parentName:"h2"},"How to prevent dirty reads?")),(0,o.kt)("h3",{id:"scenario---one-business-calls-updateall-first-updateall-is-not-completed-and-then-another-business-calls-querya"},"Scenario:   One business calls ",(0,o.kt)("inlineCode",{parentName:"h3"},"updateAll()")," first, ",(0,o.kt)("inlineCode",{parentName:"h3"},"updateAll()")," is not completed, and then another business calls ",(0,o.kt)("inlineCode",{parentName:"h3"},"queryA()")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"dirty-write",src:n(44677).Z,width:"2860",height:"1830"})),(0,o.kt)("hr",null),(0,o.kt)("h1",{id:"source-code-display"},(0,o.kt)("strong",{parentName:"h1"},"Source Code Display")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'@Service\npublic class StorageService {\n\n    @Autowired\n    private DataSource dataSource;\n\n    @GlobalTransactional\n    public void update() throws SQLException {\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        try {\n            connection = dataSource.getConnection();\n            connection.setAutoCommit(false);\n            String sql = "update storage_tbl set count = ?" +\n                "    where id = ? and commodity_code = ?";\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.setInt(1, 100);\n            preparedStatement.setLong(2, 1);\n            preparedStatement.setString(3, "2001");\n            preparedStatement.execute();\n            connection.commit();\n        } catch (Exception e) {\n            throw e;\n        } finally {\n            IOutils.close(preparedStatement);\n            IOutils.close(connection);\n        }\n    }\n\n}\n')),(0,o.kt)("p",null,"Although this code looks very basic and does not use the persistence layer framework, if we abstract what the framework does for us, it is actually the above code."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Brief explanation of the context of the following source code introduction (mainly focusing on source code related to transaction isolation)")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Purpose of proxy data source",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"The role of ",(0,o.kt)("inlineCode",{parentName:"li"},"DataSourceProxy")," (returns ",(0,o.kt)("inlineCode",{parentName:"li"},"ConnectionProxy"),")",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Introducing a small function of ",(0,o.kt)("inlineCode",{parentName:"li"},"ConnectionProxy")," (storing undolog)"))),(0,o.kt)("li",{parentName:"ul"},"The role of ",(0,o.kt)("inlineCode",{parentName:"li"},"ConnectionProxy")," (returns ",(0,o.kt)("inlineCode",{parentName:"li"},"StatementProxy"),")"),(0,o.kt)("li",{parentName:"ul"},"Processing logic of ",(0,o.kt)("inlineCode",{parentName:"li"},"StatementProxy.execute()"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Execution logic of ",(0,o.kt)("inlineCode",{parentName:"li"},"io.seata.rm.datasource.exec.UpdateExecutor")," (pre-check image, execute sql, post-check image, prepare undoLog)"),(0,o.kt)("li",{parentName:"ul"},"Execution logic of ",(0,o.kt)("inlineCode",{parentName:"li"},"SelectForUpdateExecutor")," (fight for local lock, check global lock. If there is a global lock, roll back, fight again...)"))),(0,o.kt)("li",{parentName:"ul"},"Processing logic of ",(0,o.kt)("inlineCode",{parentName:"li"},"ConnectionProxy.commit()")," (register branch transaction (fight for global lock), write undoLog, database commit)"))),(0,o.kt)("li",{parentName:"ul"},"Introducing RootContext"),(0,o.kt)("li",{parentName:"ul"},"Different proxy logic for ",(0,o.kt)("inlineCode",{parentName:"li"},"GlobalTransactionalInterceptor"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"How to handle with ",(0,o.kt)("inlineCode",{parentName:"li"},"@GlobalTransactional")),(0,o.kt)("li",{parentName:"ul"},"How to deal with ",(0,o.kt)("inlineCode",{parentName:"li"},"@GlobalLock"))))),(0,o.kt)("h2",{id:"the-role-of-datasourceproxy"},(0,o.kt)("strong",{parentName:"h2"},"The role of DataSourceProxy")),(0,o.kt)("p",null,"DataSourceProxy helps us obtain several important proxy objects"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Obtain ",(0,o.kt)("inlineCode",{parentName:"li"},"ConnectionProxy")," through ",(0,o.kt)("inlineCode",{parentName:"li"},"DataSourceProxy.getConnection()"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"package io.seata.rm.datasource;\n\nimport java.sql.Connection;\n\npublic class DataSourceProxy extends AbstractDataSourceProxy implements Resource {\n    \n    @Override\n    public ConnectionProxy getConnection() throws SQLException {\n        Connection targetConnection = targetDataSource.getConnection();\n        return new ConnectionProxy(this, targetConnection);\n    }\n}\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"First, let's introduce ",(0,o.kt)("inlineCode",{parentName:"p"},"ConnectionContext")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"ConnectionProxy"),", one of its functions is to ",(0,o.kt)("strong",{parentName:"p"},"store undoLog"),"."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"package io.seata.rm.datasource;\n\nimport io.seata.rm.datasource.undo.SQLUndoLog;\n\npublic class ConnectionProxy extends AbstractConnectionProxy {\n\n    private ConnectionContext context = new ConnectionContext();\n\n    public void appendUndoLog(SQLUndoLog sqlUndoLog) {\n        context.appendUndoItem(sqlUndoLog);\n    }\n\n}\n")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'package io.seata.rm.datasource;\n\npublic class ConnectionContext {\n\n    private static final Savepoint DEFAULT_SAVEPOINT = new Savepoint() {\n        @Override\n        public int getSavepointId() throws SQLException {\n            return 0;\n        }\n\n        @Override\n        public String getSavepointName() throws SQLException {\n            return "DEFAULT_SEATA_SAVEPOINT";\n        }\n    };\n    \n    private final Map<Savepoint, List<SQLUndoLog>> sqlUndoItemsBuffer = new LinkedHashMap<>();\n\n    private Savepoint currentSavepoint = DEFAULT_SAVEPOINT;\n\n    void appendUndoItem(SQLUndoLog sqlUndoLog) {\n        sqlUndoItemsBuffer.computeIfAbsent(currentSavepoint, k -> new ArrayList<>()).add(sqlUndoLog);\n    }\n\n}\n\n')))),(0,o.kt)("h2",{id:"get-statementproxy-through-connectionproxypreparestatement"},(0,o.kt)("strong",{parentName:"h2"},"Get ",(0,o.kt)("inlineCode",{parentName:"strong"},"StatementProxy")," through ",(0,o.kt)("inlineCode",{parentName:"strong"},"ConnectionProxy.prepareStatement(...)"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"package io.seata.rm.datasource;\n\npublic class ConnectionProxy extends AbstractConnectionProxy {\n\n    public ConnectionProxy(DataSourceProxy dataSourceProxy, Connection targetConnection) {\n        super(dataSourceProxy, targetConnection);\n    }\n\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"package io.seata.rm.datasource;\n\nimport java.sql.Connection;\n\npublic abstract class AbstractConnectionProxy implements Connection {\n\n    protected Connection targetConnection;\n\n    public AbstractConnectionProxy(DataSourceProxy dataSourceProxy, Connection targetConnection) {\n        this.dataSourceProxy = dataSourceProxy;\n        this.targetConnection = targetConnection;\n    }\n\n    @Override\n    public PreparedStatement prepareStatement(String sql) throws SQLException {\n        String dbType = getDbType();\n        // support oracle 10.2+\n        PreparedStatement targetPreparedStatement = null;\n        if (BranchType.AT == RootContext.getBranchType()) { //\u4e3a\u4ec0\u4e48\u8fd9\u91cc\u4f1a\u8fd4\u56deAT\uff1f\n            List<SQLRecognizer> sqlRecognizers = SQLVisitorFactory.get(sql, dbType);\n            if (sqlRecognizers != null && sqlRecognizers.size() == 1) {\n                SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                if (sqlRecognizer != null && sqlRecognizer.getSQLType() == SQLType.INSERT) {\n                    TableMeta tableMeta = TableMetaCacheFactory.getTableMetaCache(dbType).getTableMeta(getTargetConnection(),\n                            sqlRecognizer.getTableName(), getDataSourceProxy().getResourceId());\n                    String[] pkNameArray = new String[tableMeta.getPrimaryKeyOnlyName().size()];\n                    tableMeta.getPrimaryKeyOnlyName().toArray(pkNameArray);\n\n                    // If it is an insert statement, the PreparedStatement created here needs to be able to return the automatically generated primary key, so use this prepareStatement()\n                    targetPreparedStatement = getTargetConnection().prepareStatement(sql,pkNameArray);\n\n                }\n            }\n        }\n        if (targetPreparedStatement == null) {\n            targetPreparedStatement = getTargetConnection().prepareStatement(sql);\n        }\n        return new PreparedStatementProxy(this, targetPreparedStatement, sql);\n    }\n\n\n    public Connection getTargetConnection() {\n        return targetConnection;\n    }\n\n}\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"First, let's raise a question here, and explain it later.",(0,o.kt)("br",{parentName:"p"}),"\n",(0,o.kt)("strong",{parentName:"p"},"How could ",(0,o.kt)("inlineCode",{parentName:"strong"},"RootContext.getBranchType()")," return AT?"))),(0,o.kt)("h2",{id:"processing-logic-for-statementproxyexecute"},(0,o.kt)("strong",{parentName:"h2"},"Processing logic for ",(0,o.kt)("inlineCode",{parentName:"strong"},"StatementProxy.execute()"))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"When calling ",(0,o.kt)("inlineCode",{parentName:"p"},"io.seata.rm.datasource.StatementProxy.execute()"),", the SQL will be handed over to ",(0,o.kt)("inlineCode",{parentName:"p"},"io.seata.rm.datasource.exec.ExecuteTemplate.execute(...)")," for processing."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"package io.seata.rm.datasource;\n\npublic class PreparedStatementProxy extends AbstractPreparedStatementProxy\n    implements PreparedStatement, ParametersHolder {\n\n    @Override\n    public boolean execute() throws SQLException {\n        return ExecuteTemplate.execute(this, (statement, args) -> statement.execute());\n    }\n\n}\n")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"In the ",(0,o.kt)("inlineCode",{parentName:"li"},"ExecuteTemplate.execute(...)")," method, Seata uses different Executers based on the dbType and the type of SQL statement, and calls the ",(0,o.kt)("inlineCode",{parentName:"li"},"execute(Object... args)")," method of the ",(0,o.kt)("inlineCode",{parentName:"li"},"io.seata.rm.datasource.exec.Executer")," class.",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"package io.seata.rm.datasource.exec;\n")))))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'    public class ExecuteTemplate {\n\n        public static <T, S extends Statement> T execute(StatementProxy<S> statementProxy,\n                                                 StatementCallback<T, S> statementCallback,\n                                                 Object... args) throws SQLException {\n            return execute(null, statementProxy, statementCallback, args);\n        }\n\n        public static <T, S extends Statement> T execute(List<SQLRecognizer> sqlRecognizers,\n                                             StatementProxy<S> statementProxy,\n                                             StatementCallback<T, S> statementCallback,\n                                             Object... args) throws SQLException {\n            if (!RootContext.requireGlobalLock() && BranchType.AT != RootContext.getBranchType()) {\n                // Just work as original statement\n                return statementCallback.execute(statementProxy.getTargetStatement(), args);\n            }\n\n            String dbType = statementProxy.getConnectionProxy().getDbType();\n            if (CollectionUtils.isEmpty(sqlRecognizers)) {\n                sqlRecognizers = SQLVisitorFactory.get(\n                        statementProxy.getTargetSQL(),\n                        dbType);\n            }\n            Executor<T> executor;\n            if (CollectionUtils.isEmpty(sqlRecognizers)) {\n                executor = new PlainExecutor<>(statementProxy, statementCallback);\n            } else {\n                if (sqlRecognizers.size() == 1) {\n                    SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);\n                    switch (sqlRecognizer.getSQLType()) {\n                        case INSERT:\n                            executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n                                    new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n                                    new Object[]{statementProxy, statementCallback, sqlRecognizer});\n                            break;\n                        case UPDATE:\n                            executor = new UpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n                            break;\n                        case DELETE:\n                            executor = new DeleteExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n                            break;\n                        case SELECT_FOR_UPDATE:\n                            executor = new SelectForUpdateExecutor<>(statementProxy, statementCallback, sqlRecognizer);\n                            break;\n                        default:\n                            executor = new PlainExecutor<>(statementProxy, statementCallback);\n                            break;\n                    }\n                } else {\n                    executor = new MultiExecutor<>(statementProxy, statementCallback, sqlRecognizers);\n                }\n            }\n            T rs;\n            try {\n                rs = executor.execute(args);\n            } catch (Throwable ex) {\n                if (!(ex instanceof SQLException)) {\n                    // Turn other exception into SQLException\n                    ex = new SQLException(ex);\n                }\n                throw (SQLException) ex;\n            }\n            return rs;\n        }\n\n    }\n    ```\n    >\n    > Also, a question is raised here, explained later.\n    > **How does `RootContext.requireGlobalLock()` determine if the global lock is needed?**\n    >\n    Taking `io.seata.rm.datasource.exec.UpdateExecutor` as an example, `UpdateExecutor` extends `AbstractDMLBaseExecutor` extends `BaseTransactionalExecutor`.\n    Observing what the `execute()` method does\n    ```java\n    package io.seata.rm.datasource.exec;\n\n    public abstract class BaseTransactionalExecutor<T, S extends Statement> implements Executor<T> {\n        \n\n        protected StatementProxy<S> statementProxy;\n\n        protected StatementCallback<T, S> statementCallback;\n\n        protected SQLRecognizer sqlRecognizer;\n\n        public BaseTransactionalExecutor(StatementProxy<S> statementProxy, StatementCallback<T, S> statementCallback,\n            SQLRecognizer sqlRecognizer) {\n            this.statementProxy = statementProxy;\n            this.statementCallback = statementCallback;\n            this.sqlRecognizer = sqlRecognizer;\n        }\n\n        @Override\n        public T execute(Object... args) throws Throwable {\n            String xid = RootContext.getXID();\n            if (xid != null) {\n                statementProxy.getConnectionProxy().bind(xid);\n            }\n\n            statementProxy.getConnectionProxy().setGlobalLockRequire(RootContext.requireGlobalLock());\n            return doExecute(args);\n        }\n\n    }\n    ```\n    ```java\n    public abstract class AbstractDMLBaseExecutor<T, S extends Statement> extends BaseTransactionalExecutor<T, S> {\n        \n        public AbstractDMLBaseExecutor(StatementProxy<S> statementProxy, StatementCallback<T, S> statementCallback,\n                               SQLRecognizer sqlRecognizer) {\n            super(statementProxy, statementCallback, sqlRecognizer);\n        }\n\n        @Override\n        public T doExecute(Object... args) throws Throwable {\n            AbstractConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n            if (connectionProxy.getAutoCommit()) {\n                return executeAutoCommitTrue(args);\n            } else {\n                return executeAutoCommitFalse(args);\n            }\n        }\n\n        protected T executeAutoCommitTrue(Object[] args) throws Throwable {\n            ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n            try {\n                connectionProxy.changeAutoCommit(); // \u6ce8\u610f\uff0c\u4f60\u5982\u679c\u6ca1\u5f00\u542f\u4e8b\u52a1\uff0cseata\u5e2e\u4f60\u5f00\u542f\n                return new LockRetryPolicy(connectionProxy).execute(() -> {\n                    T result = executeAutoCommitFalse(args);\n                    connectionProxy.commit(); // \u5e2e\u4f60\u5f00\u542f\u4e8b\u52a1\u540e\uff0c\u901a\u8fc7connectionProxy\u6765\u63d0\u4ea4\n                    return result;\n                });\n            } catch (Exception e) {\n                // when exception occur in finally,this exception will lost, so just print it here\n                LOGGER.error("execute executeAutoCommitTrue error:{}", e.getMessage(), e);\n                if (!LockRetryPolicy.isLockRetryPolicyBranchRollbackOnConflict()) {\n                    connectionProxy.getTargetConnection().rollback();\n                }\n                throw e;\n            } finally {\n                connectionProxy.getContext().reset();\n                connectionProxy.setAutoCommit(true);\n            }\n        }\n\n        protected T executeAutoCommitFalse(Object[] args) throws Exception {\n            if (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) && isMultiPk()) {\n                throw new NotSupportYetException("multi pk only support mysql!");\n            }\n            TableRecords beforeImage = beforeImage();\n            T result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n            TableRecords afterImage = afterImage(beforeImage);\n            prepareUndoLog(beforeImage, afterImage);\n            return result;\n        }\n    }\n    ```\n    ```java\n    package io.seata.rm.datasource.exec;\n\n    public class UpdateExecutor<T, S extends Statement> extends AbstractDMLBaseExecutor<T, S> {\n        \n        public UpdateExecutor(StatementProxy<S> statementProxy, StatementCallback<T, S> statementCallback,\n                            SQLRecognizer sqlRecognizer) {\n            super(statementProxy, statementCallback, sqlRecognizer);\n        }\n\n    }\n\n    ```\n\n- If you have chosen a DML type Executer, you can see in the executeAutoCommitFalse() method above, it mainly does the following:\n    - Query before image (select for update, so local lock is acquired at this time)\n        ```java\n        package io.seata.rm.datasource.exec;\n\n        public class UpdateExecutor<T, S extends Statement> extends AbstractDMLBaseExecutor<T, S> {\n            \n            private static final boolean ONLY_CARE_UPDATE_COLUMNS = CONFIG.getBoolean(\n                    ConfigurationKeys.TRANSACTION_UNDO_ONLY_CARE_UPDATE_COLUMNS, DefaultValues.DEFAULT_ONLY_CARE_UPDATE_COLUMNS); // \u9ed8\u8ba4\u4e3atrue\n\n            @Override\n            protected TableRecords beforeImage() throws SQLException {\n                ArrayList<List<Object>> paramAppenderList = new ArrayList<>();\n                TableMeta tmeta = getTableMeta();\n                String selectSQL = buildBeforeImageSQL(tmeta, paramAppenderList);\n                // SELECT id, count FROM storage_tbl WHERE id = ? FOR UPDATE\n                return buildTableRecords(tmeta, selectSQL, paramAppenderList);\n            }\n\n            private String buildBeforeImageSQL(TableMeta tableMeta, ArrayList<List<Object>> paramAppenderList) {\n                SQLUpdateRecognizer recognizer = (SQLUpdateRecognizer) sqlRecognizer;\n                List<String> updateColumns = recognizer.getUpdateColumns();\n                StringBuilder prefix = new StringBuilder("SELECT ");\n                StringBuilder suffix = new StringBuilder(" FROM ").append(getFromTableInSQL());\n                String whereCondition = buildWhereCondition(recognizer, paramAppenderList);\n                if (StringUtils.isNotBlank(whereCondition)) {\n                    suffix.append(WHERE).append(whereCondition);\n                }\n                String orderBy = recognizer.getOrderBy();\n                if (StringUtils.isNotBlank(orderBy)) {\n                    suffix.append(orderBy);\n                }\n                ParametersHolder parametersHolder = statementProxy instanceof ParametersHolder ? (ParametersHolder)statementProxy : null;\n                String limit = recognizer.getLimit(parametersHolder, paramAppenderList);\n                if (StringUtils.isNotBlank(limit)) {\n                    suffix.append(limit);\n                }\n                suffix.append(" FOR UPDATE");\n                StringJoiner selectSQLJoin = new StringJoiner(", ", prefix.toString(), suffix.toString());\n                if (ONLY_CARE_UPDATE_COLUMNS) {\n                    if (!containsPK(updateColumns)) {// \u5982\u679c\u672c\u6b21\u66f4\u65b0\u7684\u884c\u4e0d\u5305\u542b\u4e3b\u952e\uff0c\u90a3select for update\u7684\u65f6\u5019\u52a0\u4e0a\u4e3b\u952e\n                        selectSQLJoin.add(getColumnNamesInSQL(tableMeta.getEscapePkNameList(getDbType())));\n                    }\n                    for (String columnName : updateColumns) {\n                        selectSQLJoin.add(columnName);\n                    }\n                } else {\n                    for (String columnName : tableMeta.getAllColumns().keySet()) {\n                        selectSQLJoin.add(ColumnUtils.addEscape(columnName, getDbType()));\n                    }\n                }\n                return selectSQLJoin.toString();\n            }\n\n\n            protected TableRecords buildTableRecords(TableMeta tableMeta, String selectSQL, ArrayList<List<Object>> paramAppenderList) throws SQLException {\n                ResultSet rs = null;\n                try (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) { // \u6267\u884cselect for update\uff0c\u7136\u540e\u5c31\u62ff\u5230\u4e86\u672c\u5730\u9501\n                    if (CollectionUtils.isNotEmpty(paramAppenderList)) {\n                        for (int i = 0, ts = paramAppenderList.size(); i < ts; i++) {\n                            List<Object> paramAppender = paramAppenderList.get(i);\n                            for (int j = 0, ds = paramAppender.size(); j < ds; j++) {\n                                ps.setObject(i * ds + j + 1, paramAppender.get(j));\n                            }\n                        }\n                    }\n                    rs = ps.executeQuery();\n                    return TableRecords.buildRecords(tableMeta, rs);\n                } finally {\n                    IOUtil.close(rs);\n                }\n            }\n        }\n\n        ```\n\n    - Execute business SQL\n    - Query the mirrored image\n      ```java\n        package io.seata.rm.datasource.exec;\n\n        public class UpdateExecutor<T, S extends Statement> extends AbstractDMLBaseExecutor<T, S> {\n            \n            @Override\n            protected TableRecords afterImage(TableRecords beforeImage) throws SQLException {\n                TableMeta tmeta = getTableMeta();\n                if (beforeImage == null || beforeImage.size() == 0) {\n                    return TableRecords.empty(getTableMeta());\n                }\n                String selectSQL = buildAfterImageSQL(tmeta, beforeImage);\n                //SELECT id, count FROM storage_tbl WHERE (id) in ( (?) )\n                ResultSet rs = null;\n                try (PreparedStatement pst = statementProxy.getConnection().prepareStatement(selectSQL)) {\n                    SqlGenerateUtils.setParamForPk(beforeImage.pkRows(), getTableMeta().getPrimaryKeyOnlyName(), pst);\n                    rs = pst.executeQuery();\n                    return TableRecords.buildRecords(tmeta, rs);\n                } finally {\n                    IOUtil.close(rs);\n                }\n            }\n        }\n      ```\n    - Prepare undoLog\n        ```java\n        public abstract class BaseTransactionalExecutor<T, S extends Statement> implements Executor<T> {\n            \n            protected void prepareUndoLog(TableRecords beforeImage, TableRecords afterImage) throws SQLException {\n                if (beforeImage.getRows().isEmpty() && afterImage.getRows().isEmpty()) {\n                    return;\n                }\n                if (SQLType.UPDATE == sqlRecognizer.getSQLType()) {\n                    if (beforeImage.getRows().size() != afterImage.getRows().size()) {\n                        throw new ShouldNeverHappenException("Before image size is not equaled to after image size, probably because you updated the primary keys.");\n                    }\n                }\n                ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n\n                TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n                String lockKeys = buildLockKey(lockKeyRecords);\n                if (null != lockKeys) {\n                    connectionProxy.appendLockKey(lockKeys);\n\n                    SQLUndoLog sqlUndoLog = buildUndoItem(beforeImage, afterImage);\n                    connectionProxy.appendUndoLog(sqlUndoLog); // \u628aundoLog\u5b58\u5230connectionProxy\u4e2d\uff0c\u5177\u4f53\u600e\u4e48\u56de\u4e8b\u4e0a\u9762\u6709\u63d0\u8fc7\n                }\n            }\n        }\n        ```\n- If your sql is select for update, `SelectForUpdateExecutor` will be used (Seata proxies select for update), and the processing logic after proxy is as follows:\n    - First execute select for update (obtain the database local lock)\n    - If it is in `@GlobalTransactional` or `@GlobalLock`, **check** whether there is a global lock\n    - If there is a global lock, and local transaction is not started, roll back the local transaction, then re-acquire the local lock and query the global lock until the global lock is released\n    ```java\n       package io.seata.rm.datasource.exec;\n\n       public class SelectForUpdateExecutor<T, S extends Statement> extends BaseTransactionalExecutor<T, S> {\n               @Override\n                public T doExecute(Object... args) throws Throwable {\n                    Connection conn = statementProxy.getConnection();\n                    DatabaseMetaData dbmd = conn.getMetaData();\n                    T rs;\n                    Savepoint sp = null;\n                    boolean originalAutoCommit = conn.getAutoCommit();\n                    try {\n                        if (originalAutoCommit) {\n                            /*\n                             * In order to hold the local db lock during global lock checking\n                             * set auto commit value to false first if original auto commit was true\n                             */\n                            conn.setAutoCommit(false);\n                        } else if (dbmd.supportsSavepoints()) {\n                            /*\n                             * In order to release the local db lock when global lock conflict\n                             * create a save point if original auto commit was false, then use the save point here to release db\n                             * lock during global lock checking if necessary\n                             */\n                            sp = conn.setSavepoint();\n                        } else {\n                            throw new SQLException("not support savepoint. please check your db version");\n                        }\n\n                        LockRetryController lockRetryController = new LockRetryController();\n                        ArrayList<List<Object>> paramAppenderList = new ArrayList<>();\n                        String selectPKSQL = buildSelectSQL(paramAppenderList);\n                        while (true) {\n                            try {\n                                // #870\n                                // execute return Boolean\n                                // executeQuery return ResultSet\n                                rs = statementCallback.execute(statementProxy.getTargetStatement(), args); // execute select for update (get database local lock)\n                                // Try to get global lock of those rows selected\n                                TableRecords selectPKRows = buildTableRecords(getTableMeta(), selectPKSQL, paramAppenderList);\n                                String lockKeys = buildLockKey(selectPKRows);\n                                if (StringUtils.isNullOrEmpty(lockKeys)) {\n                                    break;\n                                }\n\n                                if (RootContext.inGlobalTransaction() || RootContext.requireGlobalLock()) {\n                                    // Do the same thing under either @GlobalTransactional or @GlobalLock, \n                                    // that only check the global lock  here.\n                                    statementProxy.getConnectionProxy().checkLock(lockKeys);\n                                } else {\n                                    throw new RuntimeException("Unknown situation!");\n                                }\n                                break;\n                            } catch (LockConflictException lce) {\n                                if (sp != null) {\n                                    conn.rollback(sp);\n                                } else {\n                                    conn.rollback();// Roll back and release local lock\n                                }\n                                // trigger retry\n                                lockRetryController.sleep(lce);\n                            }\n                        }\n                    } finally {\n                        if (sp != null) {\n                            try {\n                                if (!JdbcConstants.ORACLE.equalsIgnoreCase(getDbType())) {\n                                    conn.releaseSavepoint(sp);\n                                }\n                            } catch (SQLException e) {\n                                LOGGER.error("{} release save point error.", getDbType(), e);\n                            }\n                        }\n                        if (originalAutoCommit) {\n                            conn.setAutoCommit(true);\n                        }\n                    }\n                    return rs;\n                }\n\n\n\n       }\n    ```\n')),(0,o.kt)("h2",{id:"processing-logic-of-connectionproxycommit"},(0,o.kt)("strong",{parentName:"h2"},"Processing Logic of ",(0,o.kt)("inlineCode",{parentName:"strong"},"ConnectionProxy.commit()"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class ConnectionProxy extends AbstractConnectionProxy {\n\n    private final static LockRetryPolicy LOCK_RETRY_POLICY = new LockRetryPolicy();\n\n    private ConnectionContext context = new ConnectionContext();\n\n    @Override\n    public void commit() throws SQLException {\n        try {\n            LOCK_RETRY_POLICY.execute(() -> {\n                doCommit();\n                return null;\n            });\n        } catch (SQLException e) {\n            if (targetConnection != null && !getAutoCommit() && !getContext().isAutoCommitChanged()) {\n                rollback();\n            }\n            throw e;\n        } catch (Exception e) {\n            throw new SQLException(e);\n        }\n    }\n\n    private void doCommit() throws SQLException {\n        if (context.inGlobalTransaction()) {\n            processGlobalTransactionCommit();\n        } else if (context.isGlobalLockRequire()) {\n            processLocalCommitWithGlobalLocks();\n        } else {\n            targetConnection.commit();\n        }\n    }\n\n}\n")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Also, a question has been raised here, which will be explained later.\nHow does ",(0,o.kt)("inlineCode",{parentName:"p"},"ConnectionContext")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"ConnectionProxy")," determine ",(0,o.kt)("inlineCode",{parentName:"p"},"inGlobalTransaction()")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"isGlobalLockRequire()"),"?")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"In a global transaction (i.e., data persistence method with ",(0,o.kt)("inlineCode",{parentName:"p"},"@GlobalTransactional"),")"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Register branch transaction, acquire global lock")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Store undo log data")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Commit the transaction in the database"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'    public class ConnectionProxy extends AbstractConnectionProxy {\n\n        private final static LockRetryPolicy LOCK_RETRY_POLICY = new LockRetryPolicy();\n\n        private ConnectionContext context = new ConnectionContext();\n        \n        private void processGlobalTransactionCommit() throws SQLException {\n            try {\n                register(); // Register branch and contend for global lock\n            } catch (TransactionException e) {\n                recognizeLockKeyConflictException(e, context.buildLockKeys());\n            }\n            try {\n                UndoLogManagerFactory.getUndoLogManager(this.getDbType()).flushUndoLogs(this); // Store undolog\n                targetConnection.commit(); // Commit branch transaction\n            } catch (Throwable ex) {\n                LOGGER.error("process connectionProxy commit error: {}", ex.getMessage(), ex);\n                report(false);\n                throw new SQLException(ex);\n            }\n            if (IS_REPORT_SUCCESS_ENABLE) {\n                report(true);\n            }\n            context.reset();\n        }\n\n        private void register() throws TransactionException {\n            if (!context.hasUndoLog() || !context.hasLockKey()) {\n                return;\n            }\n            Long branchId = DefaultResourceManager.get().branchRegister(BranchType.AT, getDataSourceProxy().getResourceId(),\n                null, context.getXid(), null, context.buildLockKeys());\n            context.setBranchId(branchId);\n        }\n')))))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    }\n    ```\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"In ",(0,o.kt)("inlineCode",{parentName:"p"},"@GlobalLock")," (i.e., data persistence method with ",(0,o.kt)("inlineCode",{parentName:"p"},"@GlobalLock"),"):"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Query tc for the presence of global lock")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Commit the transaction to the database"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"   public class ConnectionProxy extends AbstractConnectionProxy {\n\n       private final static LockRetryPolicy LOCK_RETRY_POLICY = new LockRetryPolicy();\n\n       private ConnectionContext context = new ConnectionContext();\n       \n       private void processLocalCommitWithGlobalLocks() throws SQLException {\n           checkLock(context.buildLockKeys());\n           try {\n               targetConnection.commit();\n           } catch (Throwable ex) {\n               throw new SQLException(ex);\n           }\n           context.reset();\n       }\n\n       public void checkLock(String lockKeys) throws SQLException {\n           if (StringUtils.isBlank(lockKeys)) {\n               return;\n           }\n           // Just check lock without requiring lock by now.\n           try {\n               boolean lockable = DefaultResourceManager.get().lockQuery(BranchType.AT,\n                   getDataSourceProxy().getResourceId(), context.getXid(), lockKeys);\n               if (!lockable) {\n                   throw new LockConflictException();\n               }\n           } catch (TransactionException e) {\n               recognizeLockKeyConflictException(e, lockKeys);\n           }\n       }\n")))))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"    }\n    ```\n")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Other than the above cases (the ",(0,o.kt)("inlineCode",{parentName:"li"},"else")," branch)",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Let the database commit the current transaction.")))),(0,o.kt)("h2",{id:"introduction-to-rootcontext"},"Introduction to ",(0,o.kt)("inlineCode",{parentName:"h2"},"RootContext")),(0,o.kt)("p",null,'We left three "clues" above, now it\'s time to answer them in conjunction with the ',(0,o.kt)("inlineCode",{parentName:"p"},"RootContext")," source code."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"How could the return value of ",(0,o.kt)("inlineCode",{parentName:"strong"},"RootContext.getBranchType()")," be AT?"),(0,o.kt)("br",{parentName:"p"}),"\n","The logic in this method is: as long as it is determined that the ",(0,o.kt)("strong",{parentName:"p"},"current transaction is in a global state")," (i.e., as long as ",(0,o.kt)("inlineCode",{parentName:"p"},"RootContext.bind(xid)")," has been called somewhere), it will return the default ",(0,o.kt)("inlineCode",{parentName:"p"},"BranchType.AT"),"."),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'public class RootContext {\n\n    public static final String KEY_XID = "TX_XID";\n\n    private static ContextCore CONTEXT_HOLDER = ContextCoreLoader.load();\n\n    private static BranchType DEFAULT_BRANCH_TYPE;\n\n    @Nullable\n    public static BranchType getBranchType() {\n        if (inGlobalTransaction()) {\n            BranchType branchType = (BranchType) CONTEXT_HOLDER.get(KEY_BRANCH_TYPE);\n            if (branchType != null) {\n                return branchType;\n            }\n            //Returns the default branch type.\n            return DEFAULT_BRANCH_TYPE != null ? DEFAULT_BRANCH_TYPE : BranchType.AT;\n        }\n        return null;\n    }\n\n    public static boolean inGlobalTransaction() {\n        return CONTEXT_HOLDER.get(KEY_XID) != null;\n    }\n\n    public static void bind(@Nonnull String xid) {\n        if (StringUtils.isBlank(xid)) {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug("xid is blank, switch to unbind operation!");\n            }\n            unbind();\n        } else {\n            MDC.put(MDC_KEY_XID, xid);\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug("bind {}", xid);\n            }\n            CONTEXT_HOLDER.put(KEY_XID, xid);\n        }\n    }\n}\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"How to determine whether ",(0,o.kt)("inlineCode",{parentName:"strong"},"RootContext.requireGlobalLock()")," needs a global lock?"),"\nSomewhere needs to call ",(0,o.kt)("inlineCode",{parentName:"p"},"RootContext.bindGlobalLockFlag()")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'public class RootContext {\n\n    public static final String KEY_GLOBAL_LOCK_FLAG = "TX_LOCK";\n    public static final Boolean VALUE_GLOBAL_LOCK_FLAG = true;\n\n    private static ContextCore CONTEXT_HOLDER = ContextCoreLoader.load();\n\n    public static boolean requireGlobalLock() {\n        return CONTEXT_HOLDER.get(KEY_GLOBAL_LOCK_FLAG) != null;\n    }\n\n    public static void bindGlobalLockFlag() {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug("Local Transaction Global Lock support enabled");\n        }\n\n        //just put something not null\n        CONTEXT_HOLDER.put(KEY_GLOBAL_LOCK_FLAG, VALUE_GLOBAL_LOCK_FLAG);\n    }\n\n}\n'))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"How does ",(0,o.kt)("inlineCode",{parentName:"strong"},"ConnectionProxy.commit()")," distinguish between different states based on the context, and how does ",(0,o.kt)("inlineCode",{parentName:"strong"},"ConnectionContext")," determine ",(0,o.kt)("inlineCode",{parentName:"strong"},"inGlobalTransaction()")," or ",(0,o.kt)("inlineCode",{parentName:"strong"},"isGlobalLockRequire()"),"?")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"}," public class ConnectionProxy extends AbstractConnectionProxy {\n\n    private ConnectionContext context = new ConnectionContext();\n\n    private void doCommit() throws SQLException {\n        if (context.inGlobalTransaction()) {\n            processGlobalTransactionCommit();\n        } else if (context.isGlobalLockRequire()) {\n            processLocalCommitWithGlobalLocks();\n        } else {\n            targetConnection.commit();\n        }\n    }\n}\n")),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"How is ",(0,o.kt)("inlineCode",{parentName:"p"},"inGlobalTransaction()")," determined? (Note that this is different from the mentioned ",(0,o.kt)("inlineCode",{parentName:"p"},"RootContext")," above)"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},'public class ConnectionContext {\n\n    private String xid;\n\n    void setXid(String xid) {\n        this.xid = xid;\n    }\n\n    public boolean inGlobalTransaction() {\n        return xid != null;\n    }\n\n    void bind(String xid) {\n        if (xid == null) {\n            throw new IllegalArgumentException("xid should not be null");\n        }\n        if (!inGlobalTransaction()) {\n            setXid(xid);\n        } else {\n            if (!this.xid.equals(xid)) {\n                throw new ShouldNeverHappenException();\n            }\n        }\n    }\n\n}\n')),(0,o.kt)("p",{parentName:"li"},"Where is ",(0,o.kt)("inlineCode",{parentName:"p"},"ConnectionContext.bind(xid)")," called?"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"package io.seata.rm.datasource.exec;\n\npublic abstract class BaseTransactionalExecutor<T, S extends Statement> implements Executor<T> {\n\n  @Override\n  public T execute(Object... args) throws Throwable {\n      // So, where does the XID come from here? Look ahead and you will know that it comes from when the global transaction is opened, and is related to @GlobalTransactional\n      String xid = RootContext.getXID(); \n      if (xid != null) {\n          statementProxy.getConnectionProxy().bind(xid);\n      }\n\n      // This is the position to set isGlobalLockRequire, related to @GlobalLock\n      statementProxy.getConnectionProxy().setGlobalLockRequire(RootContext.requireGlobalLock());\n      return doExecute(args);\n  }\n}\n")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class ConnectionProxy extends AbstractConnectionProxy {\n\n   private ConnectionContext context = new ConnectionContext();\n\n    public void bind(String xid) {\n        context.bind(xid);\n    }\n\n    public void setGlobalLockRequire(boolean isLock) {\n        context.setGlobalLockRequire(isLock);\n    }\n\n}\n"))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"How to determine ",(0,o.kt)("inlineCode",{parentName:"p"},"isGlobalLockRequire()"),"?"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class ConnectionContext {\n\n    private boolean isGlobalLockRequire;\n\n    boolean isGlobalLockRequire() {\n       return isGlobalLockRequire;\n    }\n\n    void setGlobalLockRequire(boolean isGlobalLockRequire) {\n        this.isGlobalLockRequire = isGlobalLockRequire;\n    }\n\n}\n")),(0,o.kt)("p",{parentName:"li"},"After looking at the code, we know that as long as somewhere in ",(0,o.kt)("inlineCode",{parentName:"p"},"RootContext")," sets xid, or ",(0,o.kt)("inlineCode",{parentName:"p"},"bindGlobalLockFlag()"),", it will be recognized as a different state.\nSo where is it called? The answer is in the ",(0,o.kt)("inlineCode",{parentName:"p"},"GlobalTransactionalInterceptor")," below."))))),(0,o.kt)("h2",{id:"globaltransactionalinterceptor-handles-methods-with-globaltransactional-or-globallock"},(0,o.kt)("strong",{parentName:"h2"},(0,o.kt)("inlineCode",{parentName:"strong"},"GlobalTransactionalInterceptor")," handles methods with ",(0,o.kt)("inlineCode",{parentName:"strong"},"@GlobalTransactional")," or ",(0,o.kt)("inlineCode",{parentName:"strong"},"@GlobalLock"))),(0,o.kt)("p",null,"Methods with ",(0,o.kt)("inlineCode",{parentName:"p"},"@GlobalTransactional")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"@GlobalLock")," will be proxied and handled by ",(0,o.kt)("inlineCode",{parentName:"p"},"GlobalTransactionalInterceptor")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class GlobalTransactionalInterceptor implements ConfigurationChangeListener, MethodInterceptor {\n\n    @Override\n    public Object invoke(final MethodInvocation methodInvocation) throws Throwable {\n        Class<?> targetClass =\n            methodInvocation.getThis() != null ? AopUtils.getTargetClass(methodInvocation.getThis()) : null;\n        Method specificMethod = ClassUtils.getMostSpecificMethod(methodInvocation.getMethod(), targetClass);\n        if (specificMethod != null && !specificMethod.getDeclaringClass().equals(Object.class)) {\n            final Method method = BridgeMethodResolver.findBridgedMethod(specificMethod);\n            final GlobalTransactional globalTransactionalAnnotation =\n                getAnnotation(method, targetClass, GlobalTransactional.class);\n            final GlobalLock globalLockAnnotation = getAnnotation(method, targetClass, GlobalLock.class);\n            boolean localDisable = disable || (degradeCheck && degradeNum >= degradeCheckAllowTimes);\n            if (!localDisable) {\n                if (globalTransactionalAnnotation != null) {\n                    return handleGlobalTransaction(methodInvocation, globalTransactionalAnnotation);// Handle @GlobalTransactional\n                } else if (globalLockAnnotation != null) {\n                    return handleGlobalLock(methodInvocation, globalLockAnnotation); // Handle @GlobalLock\n                }\n            }\n        }\n        return methodInvocation.proceed();\n    }\n\n}\n\n")),(0,o.kt)("h3",{id:"first-handle-globaltransactional"},(0,o.kt)("strong",{parentName:"h3"},"First, handle ",(0,o.kt)("inlineCode",{parentName:"strong"},"@GlobalTransactional"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class GlobalTransactionalInterceptor implements ConfigurationChangeListener, MethodInterceptor {\n\n    private final TransactionalTemplate transactionalTemplate = new TransactionalTemplate();\n\n    Object handleGlobalTransaction(final MethodInvocation methodInvocation,\n        final GlobalTransactional globalTrxAnno) throws Throwable {\n        \n        //...\n        try {\n            return transactionalTemplate.execute(...);\n        } catch (TransactionalExecutor.ExecutionException e) {\n          // ...\n        } finally {\n            //...\n        }\n    }\n}\n\n")),(0,o.kt)("p",null,"We have arrived at the classic seata transaction template method, and we need to focus on the part where the transaction is initiated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class TransactionalTemplate {\n\n    public Object execute(TransactionalExecutor business) throws Throwable {\n        // 1. Get transactionInfo\n        //...\n        // 1.1 Get current transaction, if not null, the tx role is 'GlobalTransactionRole.Participant'.\n        GlobalTransaction tx = GlobalTransactionContext.getCurrent();\n\n        // 1.2 Handle the transaction propagation.\n        // ...\n\n            // 1.3 If null, create new transaction with role 'GlobalTransactionRole.Launcher'.\n            if (tx == null) {\n                tx = GlobalTransactionContext.createNew();\n            }\n\n           //...\n\n            try {\n                // 2. If the tx role is 'GlobalTransactionRole.Launcher', send the request of beginTransaction to TC,\n                //    else do nothing. Of course, the hooks will still be triggered.\n                beginTransaction(txInfo, tx);\n\n                Object rs;\n                try {\n                    // Do Your Business\n                    rs = business.execute();\n                } catch (Throwable ex) {\n                    // 3. The needed business exception to rollback.\n                    completeTransactionAfterThrowing(txInfo, tx, ex);\n                    throw ex;\n                }\n\n                // 4. everything is fine, commit.\n                commitTransaction(tx);\n                return rs;\n            } finally {\n                //5. clear\n                //...\n            }\n        } finally {\n            // If the transaction is suspended, resume it.\n           // ...\n        }\n    }\n\n\n    private void beginTransaction(TransactionInfo txInfo, GlobalTransaction tx) throws TransactionalExecutor.ExecutionException {\n        try {\n            triggerBeforeBegin();\n            tx.begin(txInfo.getTimeOut(), txInfo.getName());\n            triggerAfterBegin();\n        } catch (TransactionException txe) {\n            throw new TransactionalExecutor.ExecutionException(tx, txe,\n                TransactionalExecutor.Code.BeginFailure);\n\n        }\n    }\n\n\n}\n\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'public class DefaultGlobalTransaction implements GlobalTransaction {\n\n    @Override\n    public void begin(int timeout, String name) throws TransactionException {\n        if (role != GlobalTransactionRole.Launcher) {\n            assertXIDNotNull();\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug("Ignore Begin(): just involved in global transaction [{}]", xid);\n            }\n            return;\n        }\n        assertXIDNull();\n        String currentXid = RootContext.getXID();\n        if (currentXid != null) {\n            throw new IllegalStateException("Global transaction already exists," +\n                " can\'t begin a new global transaction, currentXid = " + currentXid);\n        }\n        xid = transactionManager.begin(null, null, name, timeout);\n        status = GlobalStatus.Begin;\n        RootContext.bind(xid); // Bind xid\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info("Begin new global transaction [{}]", xid);\n        }\n    }\n}\n')),(0,o.kt)("p",null,"See ",(0,o.kt)("inlineCode",{parentName:"p"},"RootContext.bind(xid);")),(0,o.kt)("h3",{id:"continue-to-handle-globallock"},(0,o.kt)("strong",{parentName:"h3"},"Continue to handle ",(0,o.kt)("inlineCode",{parentName:"strong"},"@GlobalLock"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class GlobalTransactionalInterceptor implements ConfigurationChangeListener, MethodInterceptor {\n\n    private final GlobalLockTemplate globalLockTemplate = new GlobalLockTemplate();\n\n    Object handleGlobalLock(final MethodInvocation methodInvocation,\n        final GlobalLock globalLockAnno) throws Throwable {\n\n        return globalLockTemplate.execute(new GlobalLockExecutor() {...});\n    }\n}\n")),(0,o.kt)("p",null,"Also using the template method to handle GlobalLock"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class GlobalLockTemplate {\n\n    public Object execute(GlobalLockExecutor executor) throws Throwable {\n        boolean alreadyInGlobalLock = RootContext.requireGlobalLock();\n        if (!alreadyInGlobalLock) {\n            RootContext.bindGlobalLockFlag();\n        }\n\n        // set my config to config holder so that it can be access in further execution\n        // for example, LockRetryController can access it with config holder\n        GlobalLockConfig myConfig = executor.getGlobalLockConfig();\n        GlobalLockConfig previousConfig = GlobalLockConfigHolder.setAndReturnPrevious(myConfig);\n\n        try {\n            return executor.execute();\n        } finally {\n            // only unbind when this is the root caller.\n            // otherwise, the outer caller would lose global lock flag\n            if (!alreadyInGlobalLock) {\n                RootContext.unbindGlobalLockFlag();\n            }\n\n            // if previous config is not null, we need to set it back\n            // so that the outer logic can still use their config\n            if (previousConfig != null) {\n                GlobalLockConfigHolder.setAndReturnPrevious(previousConfig);\n            } else {\n                GlobalLockConfigHolder.remove();\n            }\n        }\n    }\n}\n")),(0,o.kt)("p",null,"See, as soon as it enters the template method, ",(0,o.kt)("inlineCode",{parentName:"p"},"RootContext.bindGlobalLockFlag();")))}u.isMDXComponent=!0},12556:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/dirty-write-e87d2b06d84c820fd786932b58583404.png"},44677:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/prevent-dirty-read-ce251ac833cb2ea643757c1816ab9903.png"},21408:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/prevent-dirty-write-by-GlobalLock-2371e8e82186fce823044f836a2e02c2.png"},33155:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/prevent-dirty-write-by-GlobalTransaction-7a7b3233283a355ca3a609e67841e43c.png"}}]);