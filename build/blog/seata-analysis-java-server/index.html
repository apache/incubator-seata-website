<!doctype html>
<html lang="en-US" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">深度剖析一站式分布式事务方案Seata-Server | Seata</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="http://chai001125.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="http://chai001125.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="http://chai001125.github.io/blog/seata-analysis-java-server"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="深度剖析一站式分布式事务方案Seata-Server | Seata"><meta data-rh="true" name="description" content="再前不久，我写了一篇关于分布式事务中间件Fescar的解析，没过几天Fescar团队对其进行了品牌升级，取名为Seata(Simpe Extensible Autonomous Transcaction Architecture)，而以前的Fescar的英文全称为Fast &amp; EaSy Commit And Rollback。可以看见Fescar从名字上来看更加局限于Commit和Rollback，而新的品牌名字Seata旨在打造一套一站式分布式事务解决方案。更换名字之后，我对其未来的发展更有信心。"><meta data-rh="true" property="og:description" content="再前不久，我写了一篇关于分布式事务中间件Fescar的解析，没过几天Fescar团队对其进行了品牌升级，取名为Seata(Simpe Extensible Autonomous Transcaction Architecture)，而以前的Fescar的英文全称为Fast &amp; EaSy Commit And Rollback。可以看见Fescar从名字上来看更加局限于Commit和Rollback，而新的品牌名字Seata旨在打造一套一站式分布式事务解决方案。更换名字之后，我对其未来的发展更有信心。"><meta data-rh="true" name="keywords" content="fescar、seata、分布式事务"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2019-04-08T00:00:00.000Z"><link data-rh="true" rel="icon" href="/img/seata_logo_small.jpeg"><link data-rh="true" rel="canonical" href="http://chai001125.github.io/blog/seata-analysis-java-server"><link data-rh="true" rel="alternate" href="http://chai001125.github.io/blog/seata-analysis-java-server" hreflang="en-US"><link data-rh="true" rel="alternate" href="http://chai001125.github.io/zh-cn/blog/seata-analysis-java-server" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="http://chai001125.github.io/blog/seata-analysis-java-server" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Seata RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Seata Atom Feed">




<link rel="stylesheet" href="//g.alicdn.com/mamba/assets/0.0.19/mse-arc-ui.min.css">
<script src="//g.alicdn.com/mamba/assets/0.0.19/mse-arc-ui.min.js"></script>
<script src="//g.alicdn.com/alilog/mlog/aplus_v2.js" id="beacon-aplus" exparams="clog=o&amp;aplus&amp;sidx=aplusSidx&amp;ckx=aplusCkx"></script>
<script src="//g.alicdn.com/aes/??tracker/1.0.34/index.js,tracker-plugin-pv/2.4.5/index.js,tracker-plugin-event/1.2.5/index.js,tracker-plugin-jserror/1.0.13/index.js,tracker-plugin-api/1.1.14/index.js,tracker-plugin-perf/1.1.8/index.js,tracker-plugin-eventTiming/1.0.4/index.js"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-YHS75WKFBR" async></script><link rel="stylesheet" href="/assets/css/styles.c84d55f4.css">
<link rel="preload" href="/assets/js/runtime~main.6888d26e.js" as="script">
<link rel="preload" href="/assets/js/main.96f5711d.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/seata_logo.png" alt="Seata Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/seata_logo.png" alt="Seata Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate"></b></a><a class="navbar__item navbar__link" href="/">Home</a><a class="navbar__item navbar__link" href="/docs/overview/what-is-seata">Docs</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Solutions</a><ul class="dropdown__menu"><li><a href="https://cn.aliyun.com/product/aliware/mse?spm=seata-website.topbar.0.0.0" target="_blank" rel="noopener noreferrer" class="dropdown__link">Seata in cloud<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://cn.aliyun.com/product/aliware/mse?spm=seata-website.topbar.0.0.0" target="_blank" rel="noopener noreferrer" class="dropdown__link">Microservice solutions<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://www.aliyun.com/product/ahas?spm=seata-website.topbar.0.0.0" target="_blank" rel="noopener noreferrer" class="dropdown__link">High-availability solution<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://cn.aliyun.com/product/aliware/sae?spm=seata-website.topbar.0.0.0" target="_blank" rel="noopener noreferrer" class="dropdown__link">Serverless solution for microservices<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://www.aliyun.com/product/edas?spm=seata-website.topbar.0.0.0" target="_blank" rel="noopener noreferrer" class="dropdown__link">PaaS solution<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://www.aliyun.com/product/servicemesh?spm=seata-website.topbar.0.0.0" target="_blank" rel="noopener noreferrer" class="dropdown__link">Service mesh solution<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://help.aliyun.com/document_detail/132903.html?spm=seata-website.topbar.0.0.0" target="_blank" rel="noopener noreferrer" class="dropdown__link">SOFA distributed transaction<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><a class="navbar__item navbar__link" href="/docs/developers/developers_dev">Developers</a><a href="https://mp.weixin.qq.com/s/nvDmIJEuDaNEY3RfTA3UyA" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Recruitment</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/community">Community</a><a class="navbar__item navbar__link" href="/docs/download">Download</a><a href="http://demo.seata.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Console sample</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>En</a><ul class="dropdown__menu"><li><a href="/blog/seata-analysis-java-server" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="en-US">En</a></li><li><a href="/zh-cn/blog/seata-analysis-java-server" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="zh-CN">中</a></li></ul></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All Posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-community-meetup-hangzhou-ready">Seata Community Meetup·杭州站</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-meetup-hangzhou">Seata Community Meetup·杭州站</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-observable-practice">Seata的可观测实践</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-connect-data-and-application">Seata：连接数据与应用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-go-1.2.0">生产环境可用的 seata-go 1.2.0 来了！！！</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/iscas2023">6大课题现已开放挑选 | 欢迎报名 Seata 开源之夏</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-1.6.0">Seata 1.6.0 重磅发布，大幅提升性能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-1.5.2">Seata 1.5.2 重磅发布，支持xid负载均衡</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-tcc-fence">阿里 Seata 新版本终于解决了 TCC 模式的幂等、悬挂和空回滚问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-tcc">深度剖析 Seata TCC 模式（一）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-lock">详解 Seata AT 模式事务隔离级别与全局锁设计</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/welcome">Welcome</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-snowflake-explain">关于新版雪花算法的答疑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-UUID-generator">Seata基于改良版雪花算法的分布式UUID生成器分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-feature-undo-log-compress">Seata新特性支持 -- undo_log压缩</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-dsproxy-deadlock">ConcurrentHashMap导致的Seata死锁问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-client-start-analysis-02">Seata应用侧启动过程剖析——注册中心与配置中心模块</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-client-start-analysis-01">Seata应用侧启动过程剖析——RM &amp; TM如何与TC建立连接</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/integrate-seata-tcc-mode-with-spring-cloud">Spring Cloud集成Seata分布式事务-TCC模式</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-config-manager">Seata配置管理原理解析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-golang-communication-mode">seata-golang 通信模型详解</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-datasource-proxy">Seata数据源代理解析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-sourcecode-client-bootstrap">分布式事务Seata源码-Client端启动流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-demo-in-mac">Mac下的Seata Demo环境搭建（AT模式）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-rpc-refactor">Seata RPC 模块的重构之路</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-sourcecode-server-bootstrap">分布式事务Seata源码-Server端启动流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-xa-introduce">分布式事务如何实现？深入解读 Seata 的 XA 模式</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-quick-start">Seata 极简入门</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-ha-practice">Seata 高可用部署实践</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-config-modular">Seata config 模块源码分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-dubbo-transmit-xid">源码分析Seata-XID传递 Dubbo篇</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-tcc-modular">Seata tcc 模块源码分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-core-modular">Seata core 模块源码分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-spring-boot-aop-aspectj">通过AOP动态创建/关闭Seata分布式事务</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-dynamic-config-and-dynamic-disable">Seata 动态配置订阅与降级实现原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-config-center">Seata 配置中心实现原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-nacos-docker">Docker部署Seata与Nacos整合</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-nacos-analysis">Seata分布式事务启用Nacos做配置中心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-mybatisplus-analysis">透过源码解决SeataAT模式整合Mybatis-Plus失去MP特性的问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/springboot-dubbo-mybatisplus-seata">SpringBoot+Dubbo+MybatisPlus整合seata分布式事务</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-mode-start-rm-tm">Seata 客户端需要同时启动 RM 和 TM 吗？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-mode-start">Seata AT 模式启动源码分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/design-more-flexable-application-by-saga">基于 Seata Saga 设计更有弹性的金融应用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-tcc-saga">分布式事务 Seata 及其三种模式详解</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-mode-design">分布式事务中间件 Seata 的设计原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-go-server">Seata分布式Go Server正式开源-TaaS设计简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/how-to-support-spring-cloud">Fescar 与 Spring Cloud 集成源码深度剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/integrate-seata-with-spring-cloud">Seata（Fescar）分布式事务 整合 Spring Cloud</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-java-client">分布式事务之Seata-Client原理及流程详解</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/seata-analysis-java-server">深度剖析一站式分布式事务方案Seata-Server</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tcc-mode-applicable-scenario-analysis">TCC适用模型与适用场景分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tcc-mode-design-principle">TCC 理论及设计实现指南介绍</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/quick-start-use-seata-and-dubbo-services">How to use Seata to ensure consistency between Dubbo Microservices</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-simple">Fescar分布式事务原理解析探秘</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/manual-transaction-mode">MT mode</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">深度剖析一站式分布式事务方案Seata-Server</h1><div class="container_mt6G margin-vert--md"><time datetime="2019-04-08T00:00:00.000Z" itemprop="datePublished">April 8, 2019</time> · <!-- -->30 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><span itemprop="name">李钊,季敏</span></div></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>再前不久，我写了一篇关于分布式事务中间件Fescar的解析，没过几天Fescar团队对其进行了品牌升级，取名为Seata(Simpe Extensible Autonomous Transcaction Architecture)，而以前的Fescar的英文全称为Fast &amp; EaSy Commit And Rollback。可以看见Fescar从名字上来看更加局限于Commit和Rollback，而新的品牌名字Seata旨在打造一套一站式分布式事务解决方案。更换名字之后，我对其未来的发展更有信心。</p><p>这里先大概回忆一下Seata的整个过程模型:</p><p><img loading="lazy" src="/assets/images/20190327000119-20382b15f6fcf95833b54a3b2f735c5d.png" width="1716" height="986" class="img_ev3q"></p><ul><li>TM:事务的发起者。用来告诉TC，全局事务的开始，提交，回滚。</li><li>RM:具体的事务资源，每一个RM都会作为一个分支事务注册在TC。</li><li>TC:事务的协调者。也可以看做是Fescar-server，用于接收我们的事务的注册，提交和回滚。</li></ul><p>在之前的文章中对整个角色有个大体的介绍，在这篇文章中我将重点介绍其中的核心角色TC，也就是事务协调器。</p><h1>2.Transcation Coordinator</h1><p>为什么之前一直强调 TC 是核心呢？那因为TC这个角色就好像上帝一样，管控着云云众生的RM和TM。如果TC一旦不好使，那么RM和TM一旦出现小问题，那必定会乱的一塌糊涂。所以要想了解Seata，那么必须要了解它的TC。</p><p>那么一个优秀的事务协调者应该具备哪些能力呢？我觉得应该有以下几个:</p><ul><li>正确的协调：能正确的协调RM和TM接下来应该做什么，做错了应该怎么办，做对了应该怎么办。</li><li>高可用: 事务协调器在分布式事务中很重要，如果不能保证高可用，那么它也没有存在的必要了。</li><li>高性能：事务协调器的性能一定要高，如果事务协调器性能有瓶颈那么它所管理的RM和TM那么会经常遇到超时，从而引起回滚频繁。</li><li>高扩展性：这个特点是属于代码层面的，如果是一个优秀的框架，那么需要给使用方很多自定义扩展，比如服务注册/发现，读取配置等等。</li></ul><p>下面我也将逐步阐述Seata是如何做到上面四点。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="21-seata-server的设计">2.1 Seata-Server的设计<a href="#21-seata-server的设计" class="hash-link" aria-label="Direct link to 2.1 Seata-Server的设计" title="Direct link to 2.1 Seata-Server的设计">​</a></h2><p><img loading="lazy" src="/assets/images/design-593e833d29ab54ac77d5a9da7a196a08.png" width="954" height="503" class="img_ev3q"></p><p>Seata-Server整体的模块图如上所示:</p><ul><li>Coordinator Core: 在最下面的模块是事务协调器核心代码，主要用来处理事务协调的逻辑，如是否commit,rollback等协调活动。</li><li>Store:存储模块，用来将我们的数据持久化，防止重启或者宕机数据丢失。</li><li>Discovery: 服务注册/发现模块，用于将Server地址暴露给我们Client。</li><li>Config: 用来存储和查找我们服务端的配置。</li><li>Lock: 锁模块，用于给Seata提供全局锁的功能。</li><li>RPC:用于和其它端通信。</li><li>HA-Cluster:高可用集群，目前还没开源，为Seata提供可靠的高可用服务，预计将会在0.6版本开源。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="22-discovery">2.2 Discovery<a href="#22-discovery" class="hash-link" aria-label="Direct link to 2.2 Discovery" title="Direct link to 2.2 Discovery">​</a></h2><p>首先来讲讲比较基础的Discovery模块，又称服务注册/发现模块。我们将Seata-Sever启动之后，需要将自己的地址暴露给其它使用者，那么就需要我们这个模块帮忙。</p><p><img loading="lazy" src="/assets/images/discover-123b6b65796c5fac1dbfad5192bde0d2.png" width="583" height="409" class="img_ev3q"></p><p>这个模块有个核心接口RegistryService，如上图所示:</p><ul><li>register：服务端使用，进行服务注册。</li><li>unregister：服务端使用，一般在JVM关闭钩子，ShutdownHook中调用。</li><li>subscribe：客户端使用，注册监听事件，用来监听地址的变化。</li><li>unsubscribe：客户端使用，取消注册监听事件。</li><li>lookup：客户端使用，根据key查找服务地址列表。</li><li>close：都可以使用，用于关闭Registry资源。</li></ul><p>如果需要添加自己定义的服务注册/发现，那么实现这个接口即可。截止目前在社区的不断开发推动下，已经有五种服务注册/发现，分别是redis、zk、nacos、eruka 和 consul。下面简单介绍下Nacos的实现：</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="221-register接口">2.2.1 register接口：<a href="#221-register接口" class="hash-link" aria-label="Direct link to 2.2.1 register接口：" title="Direct link to 2.2.1 register接口：">​</a></h4><p><img loading="lazy" src="/assets/images/register-9c033585329a607956f4a576c500a0f3.png" width="702" height="117" class="img_ev3q"></p><p>step1:校验地址是否合法</p><p>step2:获取Nacos的 Naming 实例，然后将地址注册到服务名为 serverAddr（固定服务名） 的对应集群分组（registry.conf 文件配置）上面。</p><p>unregister接口类似，这里不做详解。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="222-lookup接口">2.2.2 lookup接口：<a href="#222-lookup接口" class="hash-link" aria-label="Direct link to 2.2.2 lookup接口：" title="Direct link to 2.2.2 lookup接口：">​</a></h4><p><img loading="lazy" src="/assets/images/lookup-a057c9d992510131026a9bd89e2b94e9.png" width="890" height="652" class="img_ev3q"></p><p>step1：获取当前clusterName名字。</p><p>step2：判断当前集群名对应的服务是否已经订阅过了，如果是直接从map中取订阅返回的数据。</p><p>step3：如果没有订阅先主动查询一次服务实例列表，然后添加订阅并将订阅返回的数据存放到map中，之后直接从map获取最新数据。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="223-subscribe接口">2.2.3 subscribe接口<a href="#223-subscribe接口" class="hash-link" aria-label="Direct link to 2.2.3 subscribe接口" title="Direct link to 2.2.3 subscribe接口">​</a></h4><p><img loading="lazy" src="/assets/images/subscribe-2be2aa5b1bcb8b9bb0a32711b67fc49b.png" width="712" height="143" class="img_ev3q"></p><p>这个接口比较简单，具体分两步:</p><p>step1：对将要订阅的cluster-&gt; listener 存放到map中，此处nacos未提交单机已订阅列表，所以需要自己实现。</p><p>step2：使用Nacos api 订阅。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="23-config">2.3 Config<a href="#23-config" class="hash-link" aria-label="Direct link to 2.3 Config" title="Direct link to 2.3 Config">​</a></h2><p>配置模块也是一个比较基础，比较简单的模块。我们需要配置一些常用的参数比如:Netty的select线程数量，work线程数量，session允许最大为多少等等，当然这些参数再Seata中都有自己的默认设置。</p><p>同样的在Seata中也提供了一个接口Configuration，用来自定义我们需要的获取配置的地方:</p><p><img loading="lazy" src="/assets/images/config-0cb2807fcc90c4dd96e784665c5ee074.png" width="735" height="403" class="img_ev3q"></p><ul><li>getInt/Long/Boolean/getConfig()：通过dataId来获取对应的值，读取不到配置、异常或超时将返回参数中的默认值。</li><li>putConfig：用于添加配置。</li><li>removeConfig：删除一个配置。</li><li>add/remove/get ConfigListener：添加/删除/获取 配置监听器，一般用来监听配置的变更。</li></ul><p>目前为止有四种方式获取Config：File(文件获取)、Nacos、Apollo 和 ZK（不推荐）。在Seata中首先需要配置registry.conf，来配置config.type 。实现conf比较简单这里就不深入分析。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="24-store">2.4 Store<a href="#24-store" class="hash-link" aria-label="Direct link to 2.4 Store" title="Direct link to 2.4 Store">​</a></h2><p>存储层的实现对于Seata是否高性能，是否可靠非常关键。
如果存储层没有实现好，那么如果发生宕机，在TC中正在进行分布式事务处理的数据将会被丢失，既然使用了分布式事务，那么其肯定不能容忍丢失。如果存储层实现好了，但是其性能有很大问题，RM可能会发生频繁回滚那么其完全无法应对高并发的场景。</p><p>在Seata中默认提供了文件方式的存储，下面我们定义我们存储的数据为Session，而我们的TM创造的全局事务操作数据叫GloabSession，RM创造的分支事务操作数据叫BranchSession，一个GloabSession可以拥有多个BranchSession。我们的目的就是要将这么多Session存储下来。</p><p>在FileTransactionStoreManager#writeSession代码中:</p><p><img loading="lazy" src="/assets/images/store-11995c04c2ae5a0b14ce70fe74837dbf.png" width="876" height="258" class="img_ev3q"></p><p>上面的代码主要分为下面几步：</p><ul><li>step1：生成一个TransactionWriteFuture。</li><li>step2：将这个futureRequest丢进一个LinkedBlockingQueue中。为什么需要将所有数据都丢进队列中呢？当然这里其实也可以用锁来实现，再另外一个阿里开源的RocketMQ中，使用的锁。不论是队列还是锁它们的目的是为了保证单线程写，这又是为什么呢？有人会解释说，需要保证顺序写，这样速度就很快，这个理解是错误的，我们的FileChannel的写方法是线程安全的，已经能保证顺序写了。保证单线程写其实是为了让我们这个写逻辑都是单线程的，因为可能有些文件写满或者记录写数据位置等等逻辑，当然这些逻辑都可以主动加锁去做，但是为了实现简单方便，直接再整个写逻辑排队处理是最为合适的。</li><li>step3：调用future.get，等待我们该条数据写逻辑完成通知。</li></ul><p>我们将数据提交到队列之后，我们接下来需要对其进行消费，代码如下：</p><p><img loading="lazy" src="/assets/images/storewrite-d7cf58998ec8ae864c12d42bb0af2295.png" width="719" height="101" class="img_ev3q"></p><p>这里将一个WriteDataFileRunnable()提交进我们的线程池，这个Runnable的run()方法如下:</p><p><img loading="lazy" src="/assets/images/storerun-50f3041c552421e9cdc2666489a4d46a.png" width="855" height="526" class="img_ev3q"></p><p>分为下面几步:</p><p>step1： 判断是否停止，如果stopping为true则返回null。</p><p>step2：从我们的队列中获取数据。</p><p>step3：判断future是否已经超时了，如果超时，则设置结果为false，此时我们生产者get()方法会接触阻塞。</p><p>step4：将我们的数据写进文件，此时数据还在pageCahce层并没有刷新到磁盘，如果写成功然后根据条件判断是否进行刷盘操作。</p><p>step5：当写入数量到达一定的时候，或者写入时间到达一定的时候，需要将我们当前的文件保存为历史文件，删除以前的历史文件，然后创建新的文件。这一步是为了防止我们文件无限增长，大量无效数据浪费磁盘资源。</p><p>在我们的writeDataFile中有如下代码:</p><p><img loading="lazy" src="/assets/images/writedatafile-d999695c1986d60cdd5f2945f81d9882.png" width="748" height="557" class="img_ev3q"></p><p>step1：首先获取我们的ByteBuffer，如果超出最大循环BufferSize就直接创建一个新的，否则就使用我们缓存的Buffer。这一步可以很大的减少GC。</p><p>step2：然后将数据添加进入ByteBuffer。</p><p>step3：最后将ByteBuffer写入我们的fileChannel,这里会重试三次。此时的数据还在pageCache层，受两方面的影响，OS有自己的刷新策略，但是这个业务程序不能控制，为了防止宕机等事件出现造成大量数据丢失，所以就需要业务自己控制flush。下面是flush的代码:</p><p><img loading="lazy" src="/assets/images/flush-ba1b0df70804b3501b6ccdf503b01ca8.png" width="868" height="273" class="img_ev3q"></p><p>这里flush的条件写入一定数量或者写的时间超过一定时间，这样也会有个小问题如果是停电，那么pageCache中有可能还有数据并没有被刷盘，会导致少量的数据丢失。目前还不支持同步模式，也就是每条数据都需要做刷盘操作，这样可以保证每条消息都落盘，但是性能也会受到极大的影响，当然后续会不断的演进支持。</p><p>我们的store核心流程主要是上面几个方法，当然还有一些比如，session重建等，这些比较简单，读者可以自行阅读。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="25-lock">2.5 Lock<a href="#25-lock" class="hash-link" aria-label="Direct link to 2.5 Lock" title="Direct link to 2.5 Lock">​</a></h2><p>大家知道数据库实现隔离级别主要是通过锁来实现的，同样的再分布式事务框架Seata中要实现隔离级别也需要通过锁。一般在数据库中数据库的隔离级别一共有四种:读未提交，读已提交，可重复读，串行化。在Seata中可以保证隔离级别是读已提交，但是提供了达到读已提交隔离的手段。</p><p>Lock模块也就是Seata实现隔离级别的核心模块。在Lock模块中提供了一个接口用于管理我们的锁:
<img loading="lazy" src="/assets/images/lockManager-ea0f0672144a891b0f4b8c1d79572c23.png" width="759" height="368" class="img_ev3q"></p><p>其中有三个方法:</p><ul><li>acquireLock：用于对我们的BranchSession加锁，这里虽然是传的分支事务Session，实际上是对分支事务的资源加锁，成功返回true。</li><li>isLockable：根据事务ID，资源Id，锁住的Key来查询是否已经加锁。</li><li>cleanAllLocks：清除所有的锁。
对于锁我们可以在本地实现，也可以通过redis或者mysql来帮助我们实现。官方默认提供了本地全局锁的实现：
<img loading="lazy" src="/assets/images/defaultLock-1df1bfa4a52ecb7b29a9fdf7f759db8c.png" width="887" height="223" class="img_ev3q"></li></ul><p>在本地锁的实现中有两个常量需要关注:</p><ul><li>BUCKET_PER_TABLE：用来定义每个table有多少个bucket，目的是为了后续对同一个表加锁的时候减少竞争。</li><li>LOCK_MAP：这个map从定义上来看非常复杂，里里外外套了很多层Map，这里用个表格具体说明一下：</li></ul><table><thead><tr><th>层数</th><th>key</th><th>value</th></tr></thead><tbody><tr><td>1-LOCK_MAP</td><td>resourceId（jdbcUrl）</td><td>dbLockMap</td></tr><tr><td>2- dbLockMap</td><td>tableName （表名）</td><td>tableLockMap</td></tr><tr><td>3- tableLockMap</td><td>PK.hashcode%Bucket （主键值的hashcode%bucket）</td><td>bucketLockMap</td></tr><tr><td>4- bucketLockMap</td><td>PK</td><td>trascationId</td></tr></tbody></table><p>可以看见实际上的加锁在bucketLockMap这个map中，这里具体的加锁方法比较简单就不作详细阐述，主要是逐步的找到bucketLockMap,然后将当前trascationId塞进去，如果这个主键当前有TranscationId，那么比较是否是自己，如果不是则加锁失败。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="26-rpc">2.6 RPC<a href="#26-rpc" class="hash-link" aria-label="Direct link to 2.6 RPC" title="Direct link to 2.6 RPC">​</a></h2><p>保证Seata高性能的关键之一也是使用了Netty作为RPC框架，采用默认配置的线程模型如下图所示：</p><p><img loading="lazy" src="/assets/images/reactor-08b0f8b4eacf85d471715b468a919377.png" width="1019" height="379" class="img_ev3q"></p><p>如果采用默认的基本配置那么会有一个Acceptor线程用于处理客户端的链接，会有cpu*2数量的NIO-Thread，再这个线程中不会做业务太重的事情，只会做一些速度比较快的事情，比如编解码，心跳事件，和TM注册。一些比较费时间的业务操作将会交给业务线程池，默认情况下业务线程池配置为最小线程为100，最大为500。</p><p>Seata 目前允许配置的传输层配置如图所示，用户可根据需要进行Netty传输层面的调优，配置通过配置中心配置，首次加载时生效。  </p><p><img loading="lazy" src="/assets/images/transport-72c1b92a7e58aefcead18accf36697b6.png" width="1052" height="818" class="img_ev3q"></p><p>这里需要提一下的是Seata的心跳机制，这里是使用Netty的IdleStateHandler完成的，如下:</p><p><img loading="lazy" src="/assets/images/idleStateHandler-777d7088d0487a1d6cc3aa82c6155b0c.png" width="885" height="53" class="img_ev3q"></p><p>在Sever端对于写没有设置最大空闲时间，对于读设置了最大空闲时间，默认为15s(客户端默认写空闲为5s，发送ping消息)，如果超过15s则会将链接断开，关闭资源。</p><p><img loading="lazy" src="/assets/images/userEventTriggered-dde1066ce734ef88b3a6acc562e70f9c.png" width="656" height="326" class="img_ev3q"></p><p>step1：判断是否是读空闲的检测事件。</p><p>step2：如果是则断开链接，关闭资源。<br>
<!-- -->另外Seata 做了内存池、客户端做了批量小包合并发送、Netty连接池（减少连接创建时的服务不可用时间）等功能，以下为批量小包合并功能。   </p><p><img loading="lazy" src="/assets/images/send-166e53dadab35ea5272470c6056d27c1.png" width="1472" height="1572" class="img_ev3q"></p><p>客户端的消息发送并不是真正的消息发送通过 AbstractRpcRemoting#sendAsyncRequest 包装成 RpcMessage 存储至 basket 中并唤醒合并发送线程。合并发送线程通过 while true 的形式
最长等待1ms对basket的消息取出包装成 merge 消息进行真正发送，此时若 channel 出现异常则会通过 fail-fast 快速失败返回结果。merge消息发送前在 map 中标识，收到结果后批量确认（AbstractRpcRemotingClient#channelRead），并通过 dispatch 分发至 messageListener 和 handler 去处理。同时，timerExecutor 定时对已发送消息进行超时检测，若超时置为失败。具体消息协议设计将会在后续的文章中给出，敬请关注。<br>
<!-- -->Seata 的 Netty Client由 TMClient和RMClient 组成，根据事务角色功能区分，都继承 AbstractRpcRemotingClient，AbstractRpcRemotingClient 实现了 RemotingService（服务启停）, RegisterMsgListener（netty 连接池连接创建回调）和 ClientMessageSender（消息发送）继承了 AbstractRpcRemoting（ Client和Server 顶层消息发送和处理的模板）。<br>
<!-- -->RMClient类关系图如下图所示：
<img loading="lazy" src="/assets/images/class-e9d7be588754b2b5a08756e05dc79ea1.png" width="1626" height="838" class="img_ev3q">
TMClient 和 RMClient 又会根据自身的 poolConfig 配置与 NettyPoolableFactory implements KeyedPoolableObjectFactory&lt;NettyPoolKey, Channel&gt; 进行 channel 连接的交互，channel 连接池根据角色 key+ip 作为连接池的 key 来定位各个连接池
，连接池对 channel 进行统一的管理。TMClient 和 RMClient 在发送过程中对于每个 ip 只会使用一个长连接，但连接不可用时，会从连接池中快速取出已经创建好并可用的连接，减少服务的不可用时间。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="27-ha-cluster">2.7 HA-Cluster<a href="#27-ha-cluster" class="hash-link" aria-label="Direct link to 2.7 HA-Cluster" title="Direct link to 2.7 HA-Cluster">​</a></h2><p>目前官方没有公布HA-Cluster,但是通过一些其它中间件和官方的一些透露，可以将HA-Cluster用如下方式设计:
<img loading="lazy" src="/assets/images/hacluster-3b88f79394b7ffe7c02f3b249fae582f.png" width="1085" height="622" class="img_ev3q"></p><p>具体的流程如下:</p><p>step1：客户端发布信息的时候根据transcationId保证同一个transcation是在同一个master上，通过多个Master水平扩展，提供并发处理性能。</p><p>step2：在server端中一个master有多个slave，master中的数据近实时同步到slave上，保证当master宕机的时候，还能有其它slave顶上来可以用。</p><p>当然上述一切都是猜测，具体的设计实现还得等0.5版本之后。目前有一个Go版本的Seata-Server也捐赠给了Seata(还在流程中)，其通过raft实现副本一致性，其它细节不是太清楚。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="28-metrics">2.8 Metrics<a href="#28-metrics" class="hash-link" aria-label="Direct link to 2.8 Metrics" title="Direct link to 2.8 Metrics">​</a></h2><p>这个模块也是一个没有具体公布实现的模块，当然有可能会提供插件口，让其它第三方metric接入进来，最近Apache SkyWalking 正在和Seata小组商讨如何接入进来。</p><h1>3.Coordinator Core</h1><p>上面我们讲了很多Server基础模块，想必大家对Seata的实现已经有个大概，接下来我会讲解事务协调器具体逻辑是如何实现的，让大家更加了解Seata的实现内幕。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="31-启动流程">3.1 启动流程<a href="#31-启动流程" class="hash-link" aria-label="Direct link to 3.1 启动流程" title="Direct link to 3.1 启动流程">​</a></h2><p>启动方法在Server类有个main方法，定义了我们启动流程：</p><p><img loading="lazy" src="/assets/images/main-616485b1d53577f53bdca2ea7817757b.png" width="651" height="643" class="img_ev3q"></p><p>step1：创建一个RpcServer，再这个里面包含了我们网络的操作，用Netty实现了服务端。</p><p>step2：解析端口号、本地文件地址（用户Server宕机未处理完成事务恢复)、IP(可选，本机只能获取内网ip，在跨网络时需要一个对外的vip注册服务)。</p><p>step3：初始化SessionHoler,其中最重要的重要就是重我们dataDir这个文件夹中恢复我们的数据，重建我们的Session。</p><p>step4：创建一个CoorDinator,这个也是我们事务协调器的逻辑核心代码，然后将其初始化，其内部初始化的逻辑会创建四个定时任务：</p><ul><li>retryRollbacking：重试rollback定时任务，用于将那些失败的rollback进行重试的，每隔5ms执行一次。</li><li>retryCommitting：重试commit定时任务，用于将那些失败的commit进行重试的，每隔5ms执行一次。</li><li>asyncCommitting：异步commit定时任务，用于执行异步的commit，每隔10ms一次。</li><li>timeoutCheck：超时定时任务检测，用于检测超时的任务，然后执行超时的逻辑，每隔2ms执行一次。</li></ul><p>step5： 初始化UUIDGenerator这个也是我们生成各种ID(transcationId,branchId)的基本类。</p><p>step6：将本地IP和监听端口设置到XID中，初始化rpcServer等待客户端的连接。</p><p>启动流程比较简单，下面我会介绍分布式事务框架中的常见的一些业务逻辑Seata是如何处理的。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="32-begin-开启全局事务">3.2 Begin-开启全局事务<a href="#32-begin-开启全局事务" class="hash-link" aria-label="Direct link to 3.2 Begin-开启全局事务" title="Direct link to 3.2 Begin-开启全局事务">​</a></h2><p>一次分布式事务的起始点一定是开启全局事务，首先我们看看全局事务Seata是如何实现的：</p><p><img loading="lazy" src="/assets/images/begin-074ada9f769abc9a5011ce878814e570.png" width="894" height="211" class="img_ev3q"></p><p>step1： 根据应用ID，事务分组，名字，超时时间创建一个GloabSession，这个在前面也提到过它和branchSession分别是什么。</p><p>step2：对其添加一个RootSessionManager用于监听一些事件，这里要说一下目前在Seata里面有四种类型的Listener(这里要说明的是所有的sessionManager都实现了SessionLifecycleListener)：</p><ul><li>ROOT_SESSION_MANAGER：最全，最大的，拥有所有的Session。</li><li>ASYNC_COMMITTING_SESSION_MANAGER：用于管理需要做异步commit的Session。</li><li>RETRY_COMMITTING_SESSION_MANAGER：用于管理重试commit的Session。</li><li>RETRY_ROLLBACKING_SESSION_MANAGER：用于管理重试回滚的Session。
由于这里是开启事务，其它SessionManager不需要关注，我们只添加RootSessionManager即可。</li></ul><p>step3：开启Globalsession</p><p><img loading="lazy" src="/assets/images/begin2-6e0b8fe3620f79a765a756c755da0169.png" width="895" height="340" class="img_ev3q"></p><p>这一步会把状态变为Begin,记录开始时间,并且调用RootSessionManager的onBegin监听方法，将Session保存到map并写入到我们的文件。</p><p>step4：最后返回XID，这个XID是由 ip+port+transactionId 组成的，非常重要，当TM申请到之后需要将这个ID传到RM中，RM通过XID来决定到底应该访问哪一台Server。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="33-branchregister-分支事务注册">3.3 BranchRegister-分支事务注册<a href="#33-branchregister-分支事务注册" class="hash-link" aria-label="Direct link to 3.3 BranchRegister-分支事务注册" title="Direct link to 3.3 BranchRegister-分支事务注册">​</a></h2><p>当我们全局事务在TM开启之后，我们RM的分支事务也需要注册到我们的全局事务之上，这里看看是如何处理的：</p><p><img loading="lazy" src="/assets/images/branchRegister-fb53633441af1f3dab28ea6ad31ef84d.png" width="878" height="376" class="img_ev3q"></p><p>step1：通过transactionId获取并校验全局事务是否是开启状态。</p><p>step2：创建一个新的分支事务，也就是我们的BranchSession。</p><p>step3：对分支事务进行加全局锁，这里的逻辑就是使用的我们锁模块的逻辑。</p><p>step4：添加branchSession，主要是将其添加到globalSession对象中，并写入到我们的文件中。</p><p>step5：返回branchId,这个ID也很重要，我们后续需要用它来回滚我们的事务，或者对我们分支事务状态更新。</p><p>分支事务注册之后，还需要汇报分支事务的本地事务的执行到底是成功还是失败，在Server目前只是简单的做一下保存记录，汇报的目的是，就算这个分支事务失败，如果TM还是执意要提交全局事务（catch 异常不抛出），那么再遍历提交分支事务的时候，这个失败的分支事务就不需要提交（用户选择性跳过）。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="34-globalcommit---全局提交">3.4 GlobalCommit - 全局提交<a href="#34-globalcommit---全局提交" class="hash-link" aria-label="Direct link to 3.4 GlobalCommit - 全局提交" title="Direct link to 3.4 GlobalCommit - 全局提交">​</a></h2><p>当我们分支事务执行完成之后，就轮到我们的TM-事务管理器来决定是提交还是回滚，如果是提交，那么就会走到下面的逻辑:</p><p><img loading="lazy" src="/assets/images/commit-2583aeb4369e3f50d4deeeef29fa65a0.png" width="890" height="397" class="img_ev3q"></p><p>step1：首先找到我们的globalSession。如果它为null证明已经被commit过了，那么直接幂等操作，返回成功。</p><p>step2：关闭我们的GloabSession防止再次有新的branch进来(跨服务调用超时回滚，provider在继续执行)。</p><p>step3：如果status是等于Begin，那么久证明还没有提交过，改变其状态为Committing也就是正在提交。</p><p>step4：判断是否是可以异步提交，目前只有AT模式可以异步提交，二阶段全局提交时只是删除undolog并无严格顺序，此处使用定时任务，客户端收到后批量合并删除。</p><p>step5：如果是异步提交，直接将其放进我们ASYNC_COMMITTING_SESSION_MANAGER，让其再后台线程异步去做我们的step6，如果是同步的那么直接执行我们的step6。</p><p>step6：遍历我们的BranchSession进行提交，如果某个分支事务失败，根据不同的条件来判断是否进行重试，可异步执行此branchSession不成功可以继续执行下一个，因为其本身都在manager中，只要没有成功就不会被删除会一直重试，如果是同步提交的会放进重试队列进行定时重试并卡住按照顺序提交。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="35-globalrollback---全局回滚">3.5 GlobalRollback - 全局回滚<a href="#35-globalrollback---全局回滚" class="hash-link" aria-label="Direct link to 3.5 GlobalRollback - 全局回滚" title="Direct link to 3.5 GlobalRollback - 全局回滚">​</a></h2><p>如果我们的TM决定全局回滚，那么会走到下面的逻辑：</p><p><img loading="lazy" src="/assets/images/rollback-16f69f2b916af5c4cd61f0f194979646.png" width="1738" height="652" class="img_ev3q"></p><p>这个逻辑和提交流程基本一致，可以看作是它的反向，这里就不展开讲了。</p><h1>4.总结</h1><p>最后在总结一下开始我们提出了分布式事务的关键4点，Seata到底是怎么解决的：</p><ul><li>正确的协调：通过后台定时任务各种正确的重试，并且未来会推出监控平台有可能可以手动回滚。</li><li>高可用: 通过HA-Cluster保证高可用。</li><li>高性能：文件顺序写，RPC通过netty实现，Seata未来可以水平扩展，提高处理性能。</li><li>高扩展性：提供给用户可以自由实现的地方，比如配置，服务发现和注册，全局锁等等。</li></ul><p>最后希望大家能从这篇文章能了解Seata-Server的核心设计原理，当然你也可以想象如果你自己去实现一个分布式事务的Server应该怎样去设计？</p><p>Seata GitHub地址：<a href="https://github.com/seata/seata" target="_blank" rel="noopener noreferrer">https://github.com/seata/seata</a>   </p><p>本文作者：</p><p>李钊，GitHub ID @CoffeeLatte007，公众号「咖啡拿铁」作者，Seata社区 Committer，猿辅导Java工程师，曾就职于美团。对分布式中间件，分布式系统有浓厚的兴趣。<br>
<!-- -->季敏(清铭)，GitHub ID @slievrly，Seata 开源项目负责人，阿里巴巴中间件 TXC/GTS 核心研发成员，长期从事于分布式中间件核心研发工作，在分布式事务领域有着较丰富的技术积累。</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/seata-analysis-java-client"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">分布式事务之Seata-Client原理及流程详解</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/tcc-mode-applicable-scenario-analysis"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">TCC适用模型与适用场景分析</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#21-seata-server的设计" class="table-of-contents__link toc-highlight">2.1 Seata-Server的设计</a></li><li><a href="#22-discovery" class="table-of-contents__link toc-highlight">2.2 Discovery</a></li><li><a href="#23-config" class="table-of-contents__link toc-highlight">2.3 Config</a></li><li><a href="#24-store" class="table-of-contents__link toc-highlight">2.4 Store</a></li><li><a href="#25-lock" class="table-of-contents__link toc-highlight">2.5 Lock</a></li><li><a href="#26-rpc" class="table-of-contents__link toc-highlight">2.6 RPC</a></li><li><a href="#27-ha-cluster" class="table-of-contents__link toc-highlight">2.7 HA-Cluster</a></li><li><a href="#28-metrics" class="table-of-contents__link toc-highlight">2.8 Metrics</a></li><li><a href="#31-启动流程" class="table-of-contents__link toc-highlight">3.1 启动流程</a></li><li><a href="#32-begin-开启全局事务" class="table-of-contents__link toc-highlight">3.2 Begin-开启全局事务</a></li><li><a href="#33-branchregister-分支事务注册" class="table-of-contents__link toc-highlight">3.3 BranchRegister-分支事务注册</a></li><li><a href="#34-globalcommit---全局提交" class="table-of-contents__link toc-highlight">3.4 GlobalCommit - 全局提交</a></li><li><a href="#35-globalrollback---全局回滚" class="table-of-contents__link toc-highlight">3.5 GlobalRollback - 全局回滚</a></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Vision</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/">Seata is ...</a></li></ul></div><div class="col footer__col"><div class="footer__title">Documentation</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/overview/what-is-seata">What is Seata?</a></li><li class="footer__item"><a class="footer__link-item" href="/docs/user/quickstart">Quick Start</a></li><li class="footer__item"><a href="https://github.com/seata/seata.github.io/issues/new" target="_blank" rel="noopener noreferrer" class="footer__link-item">Report a doc issue<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/seata/seata.github.io" target="_blank" rel="noopener noreferrer" class="footer__link-item">Edit This Page on GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">Resources</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/community">Community</a></li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><img src="//img.alicdn.com/tfs/TB1dGrSwVT7gK0jSZFpXXaTkpXa-4802-1285.png" class="themedImage_ToTc themedImage--light_HNdA footer__logo" width="120" height="36"><img src="//img.alicdn.com/tfs/TB1dGrSwVT7gK0jSZFpXXaTkpXa-4802-1285.png" class="themedImage_ToTc themedImage--dark_i4oU footer__logo" width="120" height="36"></div><div class="footer__copyright">Copyright © 2023 Seata</div></div></div></footer></div>
<script src="/assets/js/runtime~main.6888d26e.js"></script>
<script src="/assets/js/main.96f5711d.js"></script>
</body>
</html>