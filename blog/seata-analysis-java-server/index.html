<!doctype html>
<html lang="en-US" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">In-Depth Analysis of One-Stop Distributed Transaction Solution Seata-Server | Apache Seata</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://seata.apache.org/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://seata.apache.org/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://seata.apache.org/blog/seata-analysis-java-server"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="In-Depth Analysis of One-Stop Distributed Transaction Solution Seata-Server | Apache Seata"><meta data-rh="true" name="description" content="Not long ago, I wrote an analysis of the distributed transaction middleware Fescar. Shortly after, the Fescar team rebranded it as Seata (Simple Extensible Autonomous Transaction Architecture), whereas the previous Fescar&#x27;s English full name was Fast &amp; Easy Commit And Rollback. It can be seen that Fescar was more limited to Commit and Rollback based on its name, while the new brand name Seata aims to create a one-stop distributed transaction solution. With the name change, I am more confident about its future development."><meta data-rh="true" property="og:description" content="Not long ago, I wrote an analysis of the distributed transaction middleware Fescar. Shortly after, the Fescar team rebranded it as Seata (Simple Extensible Autonomous Transaction Architecture), whereas the previous Fescar&#x27;s English full name was Fast &amp; Easy Commit And Rollback. It can be seen that Fescar was more limited to Commit and Rollback based on its name, while the new brand name Seata aims to create a one-stop distributed transaction solution. With the name change, I am more confident about its future development."><meta data-rh="true" name="keywords" content="fescar,seata,distributed transaction"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2019-04-08T00:00:00.000Z"><link data-rh="true" rel="icon" href="/img/seata_logo_small.jpeg"><link data-rh="true" rel="canonical" href="https://seata.apache.org/blog/seata-analysis-java-server"><link data-rh="true" rel="alternate" href="https://seata.apache.org/blog/seata-analysis-java-server" hreflang="en-US"><link data-rh="true" rel="alternate" href="https://seata.apache.org/zh-cn/blog/seata-analysis-java-server" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://seata.apache.org/blog/seata-analysis-java-server" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://ICHFIJRDZF-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Apache Seata RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Apache Seata Atom Feed">


<link rel="search" type="application/opensearchdescription+xml" title="Apache Seata" href="/opensearch.xml">


<meta name="aes-config" content="pid=xux-opensource&amp;user_type=101&amp;uid=&amp;username=&amp;dim10=seata">
<script src="https://www.googletagmanager.com/gtag/js?id=G-X4LJGF90X2" async></script><link rel="stylesheet" href="/assets/css/styles.ef48be50.css">
<link rel="preload" href="/assets/js/runtime~main.71ee5820.js" as="script">
<link rel="preload" href="/assets/js/main.e74c416b.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script>



<script src="https://hm.baidu.com/hm.js?104e73ef0c18b416b27abb23757ed8ee"></script>
<script src="//g.alicdn.com/alilog/mlog/aplus_v2.js" id="beacon-aplus" exparams="clog=o&amp;aplus&amp;sidx=aplusSidx&amp;ckx=aplusCkx"></script>
<script src="//g.alicdn.com/aes/??tracker/1.0.34/index.js,tracker-plugin-pv/2.4.5/index.js,tracker-plugin-event/1.2.5/index.js,tracker-plugin-jserror/1.0.13/index.js,tracker-plugin-api/1.1.14/index.js,tracker-plugin-perf/1.1.8/index.js,tracker-plugin-eventTiming/1.0.4/index.js"></script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/seata_logo.png" alt="Seata Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/seata_logo.png" alt="Seata Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate"></b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/">Home</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" aria-haspopup="true" aria-expanded="false" role="button" docid="/overview/what-is-seata" href="/docs/overview/what-is-seata">v2.0</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/docs/next/overview/what-is-seata">Next Version</a></li><li><a class="dropdown__link" href="/docs/overview/what-is-seata">v2.0</a></li><li><a class="dropdown__link" href="/docs/v1.8/overview/what-is-seata">v1.8</a></li><li><a class="dropdown__link" href="/docs/v1.7/overview/what-is-seata">v1.7</a></li><li><a class="dropdown__link" href="/docs/v1.6/overview/what-is-seata">v1.6</a></li><li><a class="dropdown__link" href="/docs/v1.5/overview/what-is-seata">v1.5</a></li><li><a class="dropdown__link" href="/docs/v1.4/overview/what-is-seata">v1.4</a></li><li><a class="dropdown__link" href="/docs/v1.3/overview/what-is-seata">v1.3</a></li><li><a class="dropdown__link" href="/docs/v1.2/overview/what-is-seata">v1.2</a></li><li><a class="dropdown__link" href="/docs/v1.1/overview/what-is-seata">v1.1</a></li><li><a class="dropdown__link" href="/docs/v1.0/overview/what-is-seata">v1.0</a></li></ul></div><a class="navbar__item navbar__link" href="/docs/developers/contributor-guide/new-contributor-guide_dev">Developers</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a><a class="navbar__item navbar__link" href="/users">Users</a><a class="navbar__item navbar__link" href="/community">Community</a><a class="navbar__item navbar__link" href="/unversioned/download/seata-server">Download</a><a class="navbar__item navbar__link" href="/solution">Solution</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">Designer</a><ul class="dropdown__menu"><li><a class="dropdown__link" target="_blank" href="/saga-designer">Saga Designer</a></li><li><a class="dropdown__link" target="_blank" href="/saga-designer-legacy">Saga Designer (Legacy)</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">ASF</a><ul class="dropdown__menu"><li><a href="https://www.apache.org" target="_blank" rel="noopener noreferrer" class="dropdown__link">Foundation</a></li><li><a href="https://www.apache.org/licenses" target="_blank" rel="noopener noreferrer" class="dropdown__link">License</a></li><li><a href="https://www.apache.org/events/current-event.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Events</a></li><li><a href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Sponsorship</a></li><li><a href="https://privacy.apache.org/policies/privacy-policy-public.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Privacy</a></li><li><a href="https://www.apache.org/security" target="_blank" rel="noopener noreferrer" class="dropdown__link">Security</a></li><li><a href="https://www.apache.org/foundation/thanks.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Thanks</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_DSK9"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>En</a><ul class="dropdown__menu"><li><a href="/blog/seata-analysis-java-server" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="en-US">En</a></li><li><a href="/zh-cn/blog/seata-analysis-java-server" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="zh-CN">中</a></li></ul></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All Posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/explore-seata-journey">Exploring the Journey of Open Source Development in Seata Project</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-raft-detailed-explanation">Seata-Raft Storage Mode in Depth and Getting Started</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-connect-data-and-application">Seata:Bridging Data and Applications</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-observable-practice">Observability Practices in Seata</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-go-1.2.0">seata-go 1.2.0 Ready for Production Environment!!!</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/iscas2023">6 Major Topics Now Open for Selection | Welcome to Apply for Seata Open Source Summer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-1.6.0">Seata 1.6.0 Released with Significant Performance Improvement</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-1.5.2">Seata 1.5.2 Released with XID Load Balancing Support</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-tcc-fence">Alibaba Seata Resolves Idempotence, Dangling, and Empty Rollback Issues in TCC Mode</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-tcc">In-Depth Analysis of Seata TCC Mode (1)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-lock">In-Depth Analysis of Seata AT Mode Transaction Isolation Levels and Global Lock Design</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-snowflake-explain">Q&amp;A on the New Version of Snowflake Algorithm</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-UUID-generator">Analysis of Seata&#x27;s Distributed UUID Generator Based on Improved Snowflake Algorithm</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-feature-undo-log-compress">Seata New Feature Support -- Undo_Log Compression</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-dsproxy-deadlock">Seata Deadlock Issue Caused by ConcurrentHashMap</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-client-start-analysis-02">Seata Application-Side Startup Process Analysis — Registry and Configuration Module</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-client-start-analysis-01">Seata Application-Side Startup Process Analysis — How RM &amp; TM Connect with TC</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/integrate-seata-tcc-mode-with-spring-cloud">Integration of Spring Cloud with Seata for Distributed Transaction - TCC Mode</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-config-manager">Analysis of Seata Configuration Management Principles</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-golang-communication-mode">Detailed Explanation of seata-golang Communication Model</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-datasource-proxy">Analysis of Seata Data Source Proxy</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-sourcecode-client-bootstrap">Seata Source Code - Client Startup Process in Distributed Transactions</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-demo-in-mac">Setting Up Seata Demo Environment on Mac (AT Mode)</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-rpc-refactor">The Refactoring Journey of Seata RPC Module</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-sourcecode-server-bootstrap">Seata Source Code - Server Startup Process in Distributed Transactions</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-xa-introduce">How is distributed transaction realized? In-depth interpretation of Seata&#x27;s XA mode</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-quick-start">Seata Quick Start</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-ha-practice">Seata High Availability Deployment Practice</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-config-modular">Seata Config Module Source Code Analysis</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-dubbo-transmit-xid">Source Code Analysis of Seata-XID Propagation in Dubbo</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-tcc-modular">Seata TCC Module Source Code Analysis</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-community-meetup-hangzhou-ready">Seata Community Meetup·Hangzhou Station</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-core-modular">Seata Core Module Source Code Analysis</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-spring-boot-aop-aspectj">Dynamically Creating/Closing Seata Distributed Transactions through AOP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-dynamic-config-and-dynamic-disable">Seata Dynamic Configuration Subscription and Degradation Implementation Principles</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-config-center">Seata Configuration Center Implementation Principles</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-nacos-docker">Docker Deployment of Seata Integration with Nacos</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-nacos-analysis">Configuring Seata Distributed Transaction with Nacos as the Configuration Center</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-meetup-hangzhou">Seata Community Meetup·Hangzhou Station</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-mybatisplus-analysis">Resolving the Issue of Losing Mybatis-Plus Features in Seata AT Mode Integration through Source Code</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/springboot-dubbo-mybatisplus-seata">Integrating Seata Distributed Transaction with SpringBoot+Dubbo+MybatisPlus</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-mode-start-rm-tm">Does Seata Client Need to Start RM and TM Simultaneously?</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-mode-start">Seata AT Mode Startup Source Code Analysis</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/design-more-flexable-application-by-saga">Designing More Flexible Financial Applications with Seata Saga</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-tcc-saga">Comprehensive Explanation of Distributed Transaction Seata and Its Three Modes</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-at-mode-design">Design Principles of Distributed Transaction Middleware Seata</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-go-server">Seata Distributed Go Server Officially Open Source - Introduction to TaaS Design</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/how-to-support-spring-cloud">Fescar Integration with Spring Cloud In-Depth Analysis of Source Code</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/integrate-seata-with-spring-cloud">Integrating Seata (formerly Fescar) Distributed Transaction with Spring Cloud</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-java-client">In-Depth Explanation of Seata-Client Principles and Processes in Distributed Transactions</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/seata-analysis-java-server">In-Depth Analysis of One-Stop Distributed Transaction Solution Seata-Server</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tcc-mode-applicable-scenario-analysis">Analysis of Applicable Models and Scenarios for TCC</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/tcc-mode-design-principle">Introduction to TCC Theory and Design Implementation Guide</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/quick-start-use-seata-and-dubbo-services">How to use Seata to ensure consistency between Dubbo Microservices</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/seata-analysis-simple">Unveiling the Principles of Fescar Distributed Transaction</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/manual-transaction-mode">MT mode</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">In-Depth Analysis of One-Stop Distributed Transaction Solution Seata-Server</h1><div class="container_mt6G margin-vert--md"><time datetime="2019-04-08T00:00:00.000Z" itemprop="datePublished">April 8, 2019</time> · <!-- -->21 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><span itemprop="name">zhao.li,min.ji</span></div></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>Not long ago, I wrote an analysis of the distributed transaction middleware Fescar. Shortly after, the Fescar team rebranded it as Seata (Simple Extensible Autonomous Transaction Architecture), whereas the previous Fescar&#x27;s English full name was Fast &amp; Easy Commit And Rollback. It can be seen that Fescar was more limited to Commit and Rollback based on its name, while the new brand name Seata aims to create a one-stop distributed transaction solution. With the name change, I am more confident about its future development.</p><p>Here, let&#x27;s briefly recall the overall process model of Seata:</p><p><img loading="lazy" alt="Seata Process Model" src="/assets/images/20190327000119-20382b15f6fcf95833b54a3b2f735c5d.png" width="1716" height="986" class="img_ev3q"></p><ul><li>TM: Transaction initiator. Used to inform TC about the start, commit, and rollback of global transactions.</li><li>RM: Specific transaction resource. Each RM is registered as a branch transaction in TC.</li><li>TC: Transaction coordinator. Also known as Fescar-server, used to receive registration, commit, and rollback of transactions.</li></ul><p>In previous articles, I provided a general introduction to the roles, and in this article, I will focus on the core role TC, which is the transaction coordinator.</p><h1>2. Transaction Coordinator</h1><p>Why has the emphasis been placed on TC as the core role? Because TC, like God, manages the RM and TM of countless beings in the cloud. If TC fails to function properly, even minor issues with RM and TM will lead to chaos. Therefore, to understand Seata, one must understand its TC.</p><p>So, what capabilities should an excellent transaction coordinator possess? I think it should have the following:</p><ul><li>Correct coordination: It should be able to properly coordinate what RM and TM should do next, what to do if something goes wrong, and what to do if everything goes right.</li><li>High availability: The transaction coordinator is crucial in distributed transactions. If it cannot ensure high availability, it serves no purpose.</li><li>High performance: The performance of the transaction coordinator must be high. If there are performance bottlenecks, it will frequently encounter timeouts, leading to frequent rollbacks.</li><li>High scalability: This characteristic belongs to the code level. If it is an excellent framework, it needs to provide many customizable extensions for users, such as service registration/discovery, reading configuration, etc.</li></ul><p>Next, I will explain how Seata achieves the above four points.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="21-seata-server-design">2.1 Seata-Server Design<a href="#21-seata-server-design" class="hash-link" aria-label="Direct link to 2.1 Seata-Server Design" title="Direct link to 2.1 Seata-Server Design">​</a></h2><p><img loading="lazy" alt="Seata-Server Design" src="/assets/images/design-593e833d29ab54ac77d5a9da7a196a08.png" width="954" height="503" class="img_ev3q"></p><p>The overall module diagram of Seata-Server is shown above:</p><ul><li>Coordinator Core: At the bottom is the core code of the transaction coordinator, mainly used to handle transaction coordination logic, such as whether to commit, rollback, etc.</li><li>Store: Storage module used to persist data to prevent data loss during restarts or crashes.</li><li>Discovery: Service registration/discovery module used to expose server addresses to clients.</li><li>Config: Used to store and retrieve server configurations.</li><li>Lock: Lock module used to provide global locking functionality to Seata.</li><li>RPC: Used for communication with other endpoints.</li><li>HA-Cluster: High availability cluster, currently not open-source, provides reliable high availability services to Seata, expected to be open-sourced in version 0.6.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="22-discovery">2.2 Discovery<a href="#22-discovery" class="hash-link" aria-label="Direct link to 2.2 Discovery" title="Direct link to 2.2 Discovery">​</a></h2><p>First, let&#x27;s talk about the basic Discovery module, also known as the service registration/discovery module. After starting Seata-Sever, we need to expose our address to other users, which is the responsibility of this module.</p><p><img loading="lazy" alt="Discovery Module" src="/assets/images/discover-123b6b65796c5fac1dbfad5192bde0d2.png" width="583" height="409" class="img_ev3q"></p><p>This module has a core interface <code>RegistryService</code>, as shown in the image above:</p><ul><li>register: Used by the server to register the service.</li><li>unregister: Used by the server, typically called in JVM shutdown hooks.</li><li>subscribe: Used by clients to register event listeners to listen for address changes.</li><li>unsubscribe: Used by clients to cancel event listeners.</li><li>lookup: Used by clients to retrieve service address lists based on keys.</li><li>close: Used to close the Registry resource.</li></ul><p>If you need to add your own service registration/discovery, just implement this interface. So far, with the continuous development and promotion in the community, there are already five service registration/discovery implementations, including redis, zk, nacos, eruka, and consul. Below is a brief introduction to the Nacos implementation:</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="221-register-interface">2.2.1 register Interface:<a href="#221-register-interface" class="hash-link" aria-label="Direct link to 2.2.1 register Interface:" title="Direct link to 2.2.1 register Interface:">​</a></h3><p><img loading="lazy" alt="Register Interface" src="/assets/images/register-9c033585329a607956f4a576c500a0f3.png" width="702" height="117" class="img_ev3q"></p><p>Step 1: Validate the address.
Step 2: Get the Naming instance of Nacos and register the address with the service name <code>serverAddr</code> (fixed service name) on the corresponding cluster group (configured in registry.conf).</p><p>The unregister interface is similar, and I won&#x27;t go into detail here.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="222-lookup-interface">2.2.2 lookup Interface:<a href="#222-lookup-interface" class="hash-link" aria-label="Direct link to 2.2.2 lookup Interface:" title="Direct link to 2.2.2 lookup Interface:">​</a></h3><p><img loading="lazy" alt="Lookup Interface" src="/assets/images/lookup-a057c9d992510131026a9bd89e2b94e9.png" width="890" height="652" class="img_ev3q"></p><p>Step 1: Get the current cluster name.
Step 2: Check if the service corresponding to the current cluster name has been subscribed. If yes, directly retrieve the subscribed data from the map.</p><p>Step 3: If not subscribed, actively query the service instance list once, then add subscription and store the data returned by subscription in the map. After that, retrieve the latest data directly from the map.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="223-subscribe-interface">2.2.3 subscribe Interface:<a href="#223-subscribe-interface" class="hash-link" aria-label="Direct link to 2.2.3 subscribe Interface:" title="Direct link to 2.2.3 subscribe Interface:">​</a></h3><p><img loading="lazy" alt="Subscribe Interface" src="/assets/images/subscribe-2be2aa5b1bcb8b9bb0a32711b67fc49b.png" width="712" height="143" class="img_ev3q"></p><p>This interface is relatively simple, divided into two steps:
Step 1: Add the <code>cluster -&gt; listener</code> to be subscribed to the map. Since Nacos does not provide a single machine already subscribed list, it needs to be implemented by itself.
Step 2: Subscribe using the Nacos API.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="23-config">2.3 Config<a href="#23-config" class="hash-link" aria-label="Direct link to 2.3 Config" title="Direct link to 2.3 Config">​</a></h2><p>The configuration module is also a relatively basic and simple module. We need to configure some common parameters such as the number of select and work threads for Netty, the maximum allowed session, etc. Of course, these parameters in Seata have their own default settings.</p><p>Similarly, Seata also provides an interface <code>Configuration</code> for customizing where we need to obtain configurations:</p><p><img loading="lazy" alt="Config Interface" src="/assets/images/config-0cb2807fcc90c4dd96e784665c5ee074.png" width="735" height="403" class="img_ev3q"></p><ul><li>getInt/Long/Boolean/getConfig(): Retrieves the corresponding value based on the dataId. If the configuration cannot be read, an exception occurs, or a timeout occurs, it returns the default value specified in the parameters.</li><li>putConfig: Used to add configuration.</li><li>removeConfig: Deletes a configuration.</li><li>add/remove/get ConfigListener: Add/remove/get configuration listeners, usually used to listen for configuration changes.</li></ul><p>Currently, there are four ways to obtain Config: File (file-based), Nacos, Apollo, and ZK (not recommended). In Seata, you first need to configure <code>registry.conf</code> to specify the <code>config.type</code>. Implementing Config is relatively simple, and I won&#x27;t delve into it here.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="24-store">2.4 Store<a href="#24-store" class="hash-link" aria-label="Direct link to 2.4 Store" title="Direct link to 2.4 Store">​</a></h2><p>The implementation of the storage layer is crucial for Seata&#x27;s performance and reliability.
If the storage layer is not implemented well, data being processed by TC in distributed transactions may be lost in the event of a crash. Since distributed transactions cannot tolerate data loss, if the storage layer is implemented well but has significant performance issues, RM may experience frequent rollbacks, making it unable to cope with high-concurrency scenarios.</p><p>In Seata, file storage is provided as the default method for storing data. Here, we define the data to be stored as sessions. Sessions created by the TM are referred to as GlobalSessions, while those created by RMs are called BranchSessions. A GlobalSession can have multiple BranchSessions. Our objective is to store all these sessions.</p><p>the code of FileTransactionStoreManager:</p><p><img loading="lazy" src="/assets/images/store-11995c04c2ae5a0b14ce70fe74837dbf.png" width="876" height="258" class="img_ev3q"></p><p>The code snippet above can be broken down into the following steps:</p><ul><li><strong>Step 1</strong>: Generate a TransactionWriteFuture.</li><li><strong>Step 2</strong>: Put this futureRequest into a LinkedBlockingQueue. Why do we need to put all the data into a queue? Well, in fact, we could also use locks for this purpose. In another Alibaba open-source project, RocketMQ, locks are used. Whether it&#x27;s a queue or a lock, their purpose is to ensure single-threaded writing. But why is that necessary? Some might explain that it&#x27;s to ensure sequential writing, which would improve speed. However, this understanding is incorrect. The write method of our FileChannel is thread-safe and already ensures sequential writing. Ensuring single-threaded writing is actually to make our write logic single-threaded. This is because there may be logic such as when a file is full or when records are written to specific positions. Of course, this logic could be actively locked, but to achieve simplicity and convenience, it&#x27;s most appropriate to queue the entire write logic for processing.</li><li><strong>Step 3</strong>: Call future.get to wait for the completion notification of our write logic.</li></ul><p>Once we submit the data to the queue, the next step is to consume it. The code is as follows:</p><p><img loading="lazy" alt="Write Data File" src="/assets/images/storewrite-d7cf58998ec8ae864c12d42bb0af2295.png" width="719" height="101" class="img_ev3q"></p><p>Here, a WriteDataFileRunnable() is submitted to our thread pool, and the run() method of this Runnable is as follows:</p><p><img loading="lazy" alt="Store Run" src="/assets/images/storerun-50f3041c552421e9cdc2666489a4d46a.png" width="855" height="526" class="img_ev3q"></p><p>It can be broken down into the following steps:</p><ul><li><strong>Step 1</strong>: Check if stopping is true. If so, return null.</li><li><strong>Step 2</strong>: Get data from our queue.</li><li><strong>Step 3</strong>: Check if the future has timed out. If so, set the result to false. At this point, our producer&#x27;s get() method will unblock.</li><li><strong>Step 4</strong>: Write our data to the file. At this point, the data is still in the pageCache layer and has not been flushed to the disk yet. If the write is successful, flush it based on certain conditions.</li><li><strong>Step 5</strong>: When the number of writes reaches a certain threshold, or when the writing time exceeds a certain limit, the current file needs to be saved as a historical file, the old historical files need to be deleted, and a new file needs to be created. This step is to prevent unlimited growth of our files, which would waste disk resources.</li></ul><p>In our writeDataFile method, we have the following code:</p><p><img loading="lazy" alt="Write Data File" src="/assets/images/writedatafile-d999695c1986d60cdd5f2945f81d9882.png" width="748" height="557" class="img_ev3q"></p><ul><li><strong>Step 1</strong>: First, get our ByteBuffer. If it exceeds the maximum loop BufferSize, create a new one directly; otherwise, use our cached Buffer. This step can greatly reduce garbage collection.</li><li><strong>Step 2</strong>: Add the data to the ByteBuffer.</li><li><strong>Step 3</strong>: Finally, write the ByteBuffer to our fileChannel. This will be retried three times. At this point, the data is still in the pageCache layer and is affected by two factors: the OS has its own flushing strategy, but this business program cannot control it. To prevent events such as crashes from causing a large amount of data loss, the business itself needs to control the flush. Below is the flush code:</li></ul><p><img loading="lazy" alt="Flush" src="/assets/images/flush-ba1b0df70804b3501b6ccdf503b01ca8.png" width="868" height="273" class="img_ev3q"></p><p>Here, the flush condition is based on writing a certain number of data or exceeding a certain time. This also presents a small issue: in the event of a power failure, there may still be data in the pageCache that has not been flushed to disk, resulting in a small amount of data loss. Currently, synchronous mode is not supported, which means that each piece of data needs to be flushed, ensuring that each message is written to disk. However, this would greatly affect performance. Of course, there will be continuous evolution and support for this in the future.</p><p>Our store&#x27;s core process mainly consists of the above methods, but there are also some other processes such as session reconstruction, which are relatively simple and readers can read them on their own.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="25-lock">2.5 Lock<a href="#25-lock" class="hash-link" aria-label="Direct link to 2.5 Lock" title="Direct link to 2.5 Lock">​</a></h2><p>As we know, the isolation level in databases is mainly implemented through locks. Similarly, in the distributed transaction framework Seata, achieving isolation levels also requires locks. Generally, there are four isolation levels in databases: Read Uncommitted, Read Committed, Repeatable Read, and Serializable. In Seata, it can ensure that the isolation level is Read Committed but provides means to achieve Read Committed isolation.</p><p>The Lock module is the core module of Seata for implementing isolation levels. In the Lock module, an interface is provided for managing our locks:
<img loading="lazy" alt="Lock Manager" src="/assets/images/lockManager-ea0f0672144a891b0f4b8c1d79572c23.png" width="759" height="368" class="img_ev3q"></p><p>It has three methods:</p><ul><li>acquireLock: Used to lock our BranchSession. Although a branch transaction Session is passed here, it is actually locking the resources of the branch transaction. Returns true upon successful locking.</li><li>isLockable: Queries whether the transaction ID, resource ID, and locked key are already locked.</li><li>cleanAllLocks: Clears all locks.</li></ul><p>For locks, we can implement them locally or use Redis or MySQL to help us implement them. The official default provides local global lock implementation:
<img loading="lazy" alt="Default Lock" src="/assets/images/defaultLock-1df1bfa4a52ecb7b29a9fdf7f759db8c.png" width="887" height="223" class="img_ev3q"></p><p>In the local lock implementation, there are two constants to pay attention to:</p><ul><li>BUCKET_PER_TABLE: Defines how many buckets each table has, aiming to reduce competition when locking the same table later.</li><li>LOCK_MAP: This map seems very complex from its definition, with many layers of Maps nested inside and outside. Here&#x27;s a table to explain it specifically:</li></ul><table><thead><tr><th>Layer</th><th>Key</th><th>Value</th></tr></thead><tbody><tr><td>1-LOCK_MAP</td><td>resourceId (jdbcUrl)</td><td>dbLockMap</td></tr><tr><td>2- dbLockMap</td><td>tableName (table name)</td><td>tableLockMap</td></tr><tr><td>3- tableLockMap</td><td>PK.hashcode%Bucket (hashcode%bucket of the primary key value)</td><td>bucketLockMap</td></tr><tr><td>4- bucketLockMap</td><td>PK</td><td>transactionId</td></tr></tbody></table><p>It can be seen that the actual locking occurs in the bucketLockMap. The specific locking method here is relatively simple and will not be detailed. The main process is to gradually find the bucketLockMap and then insert the current transactionId. If this primary key currently has a TransactionId, then it checks if it is itself; if not, the locking fails.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="26-rpc">2.6 RPC<a href="#26-rpc" class="hash-link" aria-label="Direct link to 2.6 RPC" title="Direct link to 2.6 RPC">​</a></h2><p>One of the key factors in ensuring Seata&#x27;s high performance is the use of Netty as the RPC framework, with the default configuration of the thread model as shown in the diagram below:</p><p><img loading="lazy" alt="Reactor" src="/assets/images/reactor-08b0f8b4eacf85d471715b468a919377.png" width="1019" height="379" class="img_ev3q"></p><p>If the default basic configuration is adopted, there will be one Acceptor thread for handling client connections and a number of NIO-Threads equal to cpu*2. In these threads, heavy business operations are not performed. They only handle relatively fast tasks such as encoding and decoding, heartbeats, and TM registration. Time-consuming business operations are delegated to the business thread pool. By default, the business thread pool is configured with a minimum of 100 threads and a maximum of 500.</p><p>Seata currently allows for configuration of transport layer settings, as shown in the following diagram. Users can optimize Netty transport layer settings according to their needs, and the configuration takes effect when loaded for the first time.</p><p><img loading="lazy" alt="Transport" src="/assets/images/transport-72c1b92a7e58aefcead18accf36697b6.png" width="1052" height="818" class="img_ev3q"></p><p>It&#x27;s worth mentioning Seata&#x27;s heartbeat mechanism, which is implemented using Netty&#x27;s IdleStateHandler, as shown below:</p><p><img loading="lazy" alt="Idle State Handler" src="/assets/images/idleStateHandler-777d7088d0487a1d6cc3aa82c6155b0c.png" width="885" height="53" class="img_ev3q"></p><p>On the server side, there is no maximum idle time set for writing, and for reading, the maximum idle time is set to 15 seconds (the client&#x27;s default write idle time is 5 seconds, sending ping messages). If it exceeds 15 seconds, the connection will be disconnected, and resources will be closed.</p><p><img loading="lazy" alt="User Event Triggered" src="/assets/images/userEventTriggered-dde1066ce734ef88b3a6acc562e70f9c.png" width="656" height="326" class="img_ev3q"></p><ul><li>Step 1: Check if it is a read idle detection event.</li><li>Step 2: If it is, disconnect the connection and close the resources.</li></ul><p>Additionally, Seata has implemented features such as memory pools, batch merging of small packets by the client for sending, and Netty connection pools (reducing the service unavailable time when creating connections), one of which is batch merging of small packets.</p><p><img loading="lazy" src="/assets/images/send-166e53dadab35ea5272470c6056d27c1.png" width="1472" height="1572" class="img_ev3q"></p><p>The client&#x27;s message sending process does not directly send messages. Instead, it wraps the message into an RpcMessage through AbstractRpcRemoting#sendAsyncRequest and stores it in the basket, then wakes up the merge sending thread. The merge sending thread, through a while true loop, waits for a maximum of 1ms to retrieve messages from the basket and wraps them into merge messages for actual sending. If an exception occurs in the channel during this process, it will quickly fail and return the result through fail-fast. Before sending the merge message, it is marked in the map. Upon receiving the results, batch confirmation is performed (AbstractRpcRemotingClient#channelRead), and then dispatched to messageListener and handler for processing. Additionally, timerExecutor periodically checks for timeouts in sent messages, marking them as failed if they exceed the timeout. Specific details of the message protocol design will be provided in subsequent articles, so stay tuned.</p><p>Seata&#x27;s Netty Client consists of TMClient and RMClient, distinguished by their transactional roles. Both inherit from AbstractRpcRemotingClient, which implements RemotingService (service start and stop), RegisterMsgListener (Netty connection pool connection creation callback), and ClientMessageSender (message sending), further inheriting from AbstractRpcRemoting (the top-level message sending and processing template for Client and Server).</p><p>The class diagram for RMClient is depicted below:
<img loading="lazy" alt="RMClient Class Diagram" src="/assets/images/class-e9d7be588754b2b5a08756e05dc79ea1.png" width="1626" height="838" class="img_ev3q"></p><p>TMClient and RMClient interact with channel connections based on their respective poolConfig and NettyPoolableFactory, which implements KeyedPoolableObjectFactory&lt;NettyPoolKey, Channel&gt;. The channel connection pool locates each connection pool based on the role key+IP, and manages channels uniformly. During the sending process, TMClient and RMClient each use only one long-lived connection per IP. However, if a connection becomes unavailable, it is quickly retrieved from the connection pool, reducing service downtime.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="27-ha-cluster">2.7 HA-Cluster<a href="#27-ha-cluster" class="hash-link" aria-label="Direct link to 2.7 HA-Cluster" title="Direct link to 2.7 HA-Cluster">​</a></h2><p>Currently, the official HA-Cluster design has not been publicly disclosed. However, based on some hints from other middleware and the official channels, HA-Cluster could be designed as follows:
<img loading="lazy" alt="HA-Cluster Design" src="/assets/images/hacluster-3b88f79394b7ffe7c02f3b249fae582f.png" width="1085" height="622" class="img_ev3q"></p><p>The specific process is as follows:</p><p><strong>Step 1:</strong> When clients publish information, they ensure that the same transaction with the same transaction ID is handled on the same master. This is achieved by horizontally scaling multiple masters to provide concurrent processing performance.</p><p><strong>Step 2:</strong> On the server side, each master has multiple slaves. Data in the master is nearly real-time synchronized to the slaves, ensuring that when the master crashes, other slaves can take over.</p><p>However, all of the above is speculation, and the actual design and implementation will have to wait until version 0.5. Currently, there is a Go version of Seata-Server donated to Seata (still in progress), which implements replica consistency through Raft. However, other details are not clear.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="28-metrics">2.8 Metrics<a href="#28-metrics" class="hash-link" aria-label="Direct link to 2.8 Metrics" title="Direct link to 2.8 Metrics">​</a></h2><p>This module has not yet disclosed a specific implementation. However, it may provide a plugin interface for integrating with other third-party metrics. Recently, Apache SkyWalking has been discussing how to integrate with the Seata team.</p><h1>3. Coordinator Core</h1><p>We have covered many foundational modules of the Seata server. I believe you now have a general understanding of Seata&#x27;s implementation. Next, I will explain how the transaction coordinator&#x27;s specific logic is implemented, providing you with a deeper understanding of Seata&#x27;s internal workings.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="31-startup-process">3.1 Startup Process<a href="#31-startup-process" class="hash-link" aria-label="Direct link to 3.1 Startup Process" title="Direct link to 3.1 Startup Process">​</a></h2><p>The startup method is defined in the Server class&#x27;s main method, outlining our startup process:</p><p><img loading="lazy" src="/assets/images/main-616485b1d53577f53bdca2ea7817757b.png" width="651" height="643" class="img_ev3q"></p><p>step1: Create an RpcServer, which encapsulates network operations using Netty to implement the server.</p><p>step2: Parse the port number, local file address (for recovering incomplete transactions if the server crashes), and IP address (optional, useful for obtaining an external VIP registration service when crossing networks).</p><p>step3: Initialize SessionHolder, wherein the crucial step is to recover data from the dataDir folder and rebuild sessions.</p><p>step4: Create a Coordinator, the core logic of the transaction coordinator, and initialize it. The initialization process includes creating four scheduled tasks:</p><ul><li>retryRollbacking: Retry rollback task, used to retry failed rollbacks, executed every 5ms.</li><li>retryCommitting: Retry commit task, used to retry failed commits, executed every 5ms.</li><li>asyncCommitting: Asynchronous commit task, used to perform asynchronous commits, executed every 10ms.</li><li>timeoutCheck: Timeout task check, used to detect timeout tasks and execute timeout logic, executed every 2ms.</li></ul><p>step5: Initialize UUIDGenerator, a basic class used for generating various IDs (transactionId, branchId).</p><p>step6: Set the local IP and listening port in XID, initialize rpcServer, and wait for client connections.</p><p>The startup process is relatively straightforward. Next, I will describe how Seata handles common business logic in distributed transaction frameworks.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="32-begin---start-global-transaction">3.2 Begin - Start Global Transaction<a href="#32-begin---start-global-transaction" class="hash-link" aria-label="Direct link to 3.2 Begin - Start Global Transaction" title="Direct link to 3.2 Begin - Start Global Transaction">​</a></h2><p>The starting point of a distributed transaction is always to start a global transaction. Let&#x27;s see how Seata implements global transactions:</p><p><img loading="lazy" alt="Begin Global Transaction" src="/assets/images/begin-074ada9f769abc9a5011ce878814e570.png" width="894" height="211" class="img_ev3q"></p><p>step1: Create a GloabSession based on the application ID, transaction group, name, and timeout. As mentioned earlier, GloabSession and BranchSession represent different aspects of the transaction.</p><p>step2: Add a RootSessionManager to it for listening to some events. Currently, Seata has four types of listeners (it&#x27;s worth noting that all session managers implement SessionLifecycleListener):</p><ul><li>ROOT_SESSION_MANAGER: The largest, containing all sessions.</li><li>ASYNC_COMMITTING_SESSION_MANAGER: Manages sessions that need asynchronous commit.</li><li>RETRY_COMMITTING_SESSION_MANAGER: Manages sessions for retrying commit.</li><li>RETRY_ROLLBACKING_SESSION_MANAGER: Manages sessions for retrying rollback.
Since this is the beginning of a transaction, other SessionManagers are not needed, so only add RootSessionManager.</li></ul><p>step3: Start GloabSession, which changes the state to Begin, records the start time, and calls the onBegin method of RootSessionManager to save the session to the map and write it to the file.</p><p>step4: Finally, return the XID. This XID is composed of ip+port+transactionId, which is crucial. When the TM acquires it, it needs to pass this ID to RM. RM uses XID to determine which server to access.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="33-branchregister---register-branch-transaction">3.3 BranchRegister - Register Branch Transaction<a href="#33-branchregister---register-branch-transaction" class="hash-link" aria-label="Direct link to 3.3 BranchRegister - Register Branch Transaction" title="Direct link to 3.3 BranchRegister - Register Branch Transaction">​</a></h2><p>After the global transaction is initiated by TM, the branch transaction of our RM also needs to be registered on top of our global transaction. Here&#x27;s how it&#x27;s handled:</p><p><img loading="lazy" alt="Branch Transaction Registration" src="/assets/images/branchRegister-fb53633441af1f3dab28ea6ad31ef84d.png" width="878" height="376" class="img_ev3q"></p><p>step1: Retrieve and validate the global transaction&#x27;s state based on the transactionId.</p><p>step2: Create a new branch transaction, which is our BranchSession.</p><p>step3: Lock the branch transaction globally. Here, the logic uses the lock module.</p><p>step4: Add the branchSession, mainly by adding it to the globalSession object and writing it to our file.</p><p>step5: Return the branchId, which is also important. We will need it later to roll back our transaction or update the status of our branch transaction.</p><p>After registering the branch transaction, it is necessary to report whether the local transaction execution of the branch transaction was successful or failed. Currently, the server simply records this information. The purpose of reporting is that even if this branch transaction fails, if the TM insists on committing the global transaction (catches exceptions without throwing), then when traversing to commit the branch transaction, this failed branch transaction does not need to be committed (users can choose to skip it).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="34-globalcommit---global-commit">3.4 GlobalCommit - Global Commit<a href="#34-globalcommit---global-commit" class="hash-link" aria-label="Direct link to 3.4 GlobalCommit - Global Commit" title="Direct link to 3.4 GlobalCommit - Global Commit">​</a></h2><p>When our branch transaction is completed, it&#x27;s up to our TM - Transaction Manager to decide whether to commit or rollback. If it&#x27;s a commit, then the following logic will be executed:</p><p><img loading="lazy" alt="Global Commit" src="/assets/images/commit-2583aeb4369e3f50d4deeeef29fa65a0.png" width="890" height="397" class="img_ev3q"></p><p>step1: First, find our globalSession. If it&#x27;s null, it means it has already been committed, so perform idempotent operation and return success.</p><p>step2: Close our GloabSession to prevent new branches from coming in (rollback due to timeout in cross-service calls, provider continues execution).</p><p>step3: If the status is Begin, it means it hasn&#x27;t been committed yet, so change its status to Committing, indicating that it&#x27;s committing.</p><p>step4: Determine if it can be asynchronously committed. Currently, only AT mode can be asynchronously committed. In two-phase global commits, undolog is only deleted without strict order. Here, a timer task is used, and the client merges and deletes in batches after receiving it.</p><p>step5: If it&#x27;s an asynchronous commit, directly put it into our ASYNC_COMMITTING_SESSION_MANAGER to let it asynchronously execute step6 in the background. If it&#x27;s synchronous, then execute step6 directly.</p><p>step6: Traverse our BranchSessions for submission. If a branch transaction fails, determine whether to retry based on different conditions. This branchSession can be executed asynchronously, and if it fails, it can continue with the next one because it remains in the manager and won&#x27;t be deleted until it succeeds. If it&#x27;s a synchronous commit, it will be put into the retry queue for scheduled retries and will block and submit in sequence.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="35-globalrollback---global-rollback">3.5 GlobalRollback - Global Rollback<a href="#35-globalrollback---global-rollback" class="hash-link" aria-label="Direct link to 3.5 GlobalRollback - Global Rollback" title="Direct link to 3.5 GlobalRollback - Global Rollback">​</a></h2><p>If our TM decides to globally rollback, it will follow the logic below:</p><p><img loading="lazy" alt="Global Rollback" src="/assets/images/rollback-16f69f2b916af5c4cd61f0f194979646.png" width="1738" height="652" class="img_ev3q"></p><p>This logic is basically the same as the commit process but in reverse. I won&#x27;t delve into it here.</p><h1>4. Conclusion</h1><p>Finally, let&#x27;s summarize how Seata solves the key points of distributed transactions:</p><ul><li>Correct coordination: Through background scheduled tasks, various retries are performed correctly, and in the future, a monitoring platform may be introduced, possibly allowing manual rollback.</li><li>High availability: Ensured by HA-Cluster.</li><li>High performance: Sequential file writing, RPC implemented through Netty, and Seata can be horizontally scaled in the future to improve processing performance.</li><li>High extensibility: Provides places where users can freely implement, such as configuration, service discovery and registration, global lock, etc.</li></ul><p>In conclusion, I hope you can understand the core design principles of Seata-Server from this article. Of course, you can also imagine how you would design a distributed transaction server if you were to implement one yourself.</p><p>Seata GitHub Repository: <a href="https://github.com/apache/incubator-seata" target="_blank" rel="noopener noreferrer">https://github.com/apache/incubator-seata</a></p><p>Article Authors:</p><p>Li Zhao, GitHub ID @CoffeeLatte007, author of the public account &quot;咖啡拿铁&quot;, Seata community Committer, Java engineer at Yuanfudao, formerly employed at Meituan. Has a strong interest in distributed middleware and distributed systems.
Ji Min (Qingming), GitHub ID @slievrly, Seata open source project leader, core R&amp;D member of Alibaba middleware TXC/GTS, has long been engaged in core R&amp;D work of distributed middleware, and has rich technical accumulation in the field of distributed transactions.</p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_mRVl"><div class="col margin-top--sm"><a href="https://github.com/apache/incubator-seata-website/blob/docusaurus/i18n/en/docusaurus-plugin-content-blog/seata-analysis-java-server.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/seata-analysis-java-client"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">In-Depth Explanation of Seata-Client Principles and Processes in Distributed Transactions</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/tcc-mode-applicable-scenario-analysis"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">Analysis of Applicable Models and Scenarios for TCC</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#21-seata-server-design" class="table-of-contents__link toc-highlight">2.1 Seata-Server Design</a></li><li><a href="#22-discovery" class="table-of-contents__link toc-highlight">2.2 Discovery</a><ul><li><a href="#221-register-interface" class="table-of-contents__link toc-highlight">2.2.1 register Interface:</a></li><li><a href="#222-lookup-interface" class="table-of-contents__link toc-highlight">2.2.2 lookup Interface:</a></li><li><a href="#223-subscribe-interface" class="table-of-contents__link toc-highlight">2.2.3 subscribe Interface:</a></li></ul></li><li><a href="#23-config" class="table-of-contents__link toc-highlight">2.3 Config</a></li><li><a href="#24-store" class="table-of-contents__link toc-highlight">2.4 Store</a></li><li><a href="#25-lock" class="table-of-contents__link toc-highlight">2.5 Lock</a></li><li><a href="#26-rpc" class="table-of-contents__link toc-highlight">2.6 RPC</a></li><li><a href="#27-ha-cluster" class="table-of-contents__link toc-highlight">2.7 HA-Cluster</a></li><li><a href="#28-metrics" class="table-of-contents__link toc-highlight">2.8 Metrics</a></li><li><a href="#31-startup-process" class="table-of-contents__link toc-highlight">3.1 Startup Process</a></li><li><a href="#32-begin---start-global-transaction" class="table-of-contents__link toc-highlight">3.2 Begin - Start Global Transaction</a></li><li><a href="#33-branchregister---register-branch-transaction" class="table-of-contents__link toc-highlight">3.3 BranchRegister - Register Branch Transaction</a></li><li><a href="#34-globalcommit---global-commit" class="table-of-contents__link toc-highlight">3.4 GlobalCommit - Global Commit</a></li><li><a href="#35-globalrollback---global-rollback" class="table-of-contents__link toc-highlight">3.5 GlobalRollback - Global Rollback</a></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a href="https://incubator.apache.org/" target="_blank" rel="noopener noreferrer" class="footerLogoLink_BH7S"><img src="/img/apache/incubator.svg" alt="Apache Incubator Logo" class="themedImage_ToTc themedImage--light_HNdA footer__logo"><img src="/img/apache/incubator.svg" alt="Apache Incubator Logo" class="themedImage_ToTc themedImage--dark_i4oU footer__logo"></a></div><div class="footer__copyright">
                  <div class="fs-12">
                    <div class="center-div">
                      <span>Apache Seata (incubating) is an effort undergoing incubation at The Apache Software Foundation (ASF), sponsored by the Apache Incubator. Incubation is required of all newly accepted projects until a further review indicates that the infrastructure, communications, and decision making process have stabilized in a manner consistent with other successful ASF projects. While incubation status is not necessarily a reflection of the completeness or stability of the code, it does indicate that the project has yet to be fully endorsed by the ASF.</span>
                    </div>
                    <br>
                    <div class="center-div">
                      <span>Copyright © 2023-2024, The Apache Software Foundation Apache Seata, Seata, Apache, Apache Incubator, the Apache feather, the Apache Incubator logo and the Apache Seata project logo are either registered trademarks or trademarks of the Apache Software Foundation.</span>
                      <br>
                    </div>
                    <br>
                  </div>
                  </div></div></div></footer></div>
<script src="/assets/js/runtime~main.71ee5820.js"></script>
<script src="/assets/js/main.e74c416b.js"></script>
</body>
</html>