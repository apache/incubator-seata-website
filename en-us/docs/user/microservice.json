{
  "filename": "microservice.md",
  "__html": "<h1>Transaction Context</h1>\n<p>Transaction context of Seata is managed by RootContext.</p>\n<p>When application begins a global transaction, RootContext will bind the XID of the transaction automatically, at the end of transaction(commit or rollback), RootContext will unbind the XID automatically.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// Bind XID</span>\nRootContext.bind(xid);\n\n<span class=\"hljs-comment\">// Unbind XID</span>\nString xid = RootContext.unbind();\n</code></pre>\n<p>Application retrieve the global transaction XID through the API of RootContext.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// Retrieve XID</span>\nString xid = RootContext.getXID();\n</code></pre>\n<p>Whether application is running a global transaction, just check if an XID bound to RootContext.</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">inGlobalTransaction</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> CONTEXT_HOLDER.get(KEY_XID) != <span class=\"hljs-keyword\">null</span>;\n    }\n</code></pre>\n<h1>Transaction propagation</h1>\n<p>The mechanism of the global transaction of Seata is the propagation of transaction context,  primarily, it's the propagation way of XID in runtime.</p>\n<p><em>1. The propagation of transaction in the service</em></p>\n<p>By default, RootContext is based on ThreadLocal, which is the XID is bound in the context of thread.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThreadLocalContextCore</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ContextCore</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; threadLocal = <span class=\"hljs-keyword\">new</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt;() {\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Map&lt;String, String&gt; <span class=\"hljs-title\">initialValue</span><span class=\"hljs-params\">()</span> </span>{\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> HashMap&lt;String, String&gt;();\n        }\n\n    };\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(String key, String value)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> threadLocal.get().put(key, value);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(String key)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> threadLocal.get().get(key);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(String key)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> threadLocal.get().remove(key);\n    }\n}\n</code></pre>\n<p>So the inner XID of service is tracing by the same thread naturally, do nothing to propagate the transaction by default.</p>\n<p>If it hopes to hung up the transaction context, implement it by the API of RootContext:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// Hung up(pause)</span>\nString xid = RootContext.unbind();\n\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> Logic running out of the global transaction scope</span>\n\n<span class=\"hljs-comment\">// recover the global transaction</span>\nRootContext.bind(xid);\n\n</code></pre>\n<p><em>2. Transactional propagation across service calls</em></p>\n<p>It's easy to know by the basic idea preceding:</p>\n<blockquote>\n<p>The transaction propagation across service calls, essentially, propagate the XID via service call to service provider, and bind it to RootContext.</p>\n</blockquote>\n<p>As long as it can be done, Seata can support any microservice framework in theory.</p>\n<h1>Interpretation of supporting Dubbo</h1>\n<p>Let's interpret the inner support for Dubbo RPC to illustrate how Seata supports a specific microservice framework in follows:</p>\n<p>We use the org.apache.dubbo.rpc.Filter of Dubbo to support propagation of transaction.</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n * The type Transaction propagation filter.\n */</span>\n<span class=\"hljs-meta\">@Activate</span>(group = { Constants.PROVIDER, Constants.CONSUMER }, order = <span class=\"hljs-number\">100</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TransactionPropagationFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Filter</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Logger LOGGER = LoggerFactory.getLogger(TransactionPropagationFilter.class);\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        String xid = RootContext.getXID(); <span class=\"hljs-comment\">// Get XID of current transaction</span>\n        String rpcXid = RpcContext.getContext().getAttachment(RootContext.KEY_XID); <span class=\"hljs-comment\">// Acquire the XID from RPC invoke</span>\n        <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(<span class=\"hljs-string\">\"xid in RootContext[\"</span> + xid + <span class=\"hljs-string\">\"] xid in RpcContext[\"</span> + rpcXid + <span class=\"hljs-string\">\"]\"</span>);\n        }\n        <span class=\"hljs-keyword\">boolean</span> bind = <span class=\"hljs-keyword\">false</span>;\n        <span class=\"hljs-keyword\">if</span> (xid != <span class=\"hljs-keyword\">null</span>) { <span class=\"hljs-comment\">// Consumer：Put XID into the attachment of RPC</span>\n            RpcContext.getContext().setAttachment(RootContext.KEY_XID, xid);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> (rpcXid != <span class=\"hljs-keyword\">null</span>) { <span class=\"hljs-comment\">// Provider：Bind the XID propagated by RPC to current runtime</span>\n                RootContext.bind(rpcXid);\n                bind = <span class=\"hljs-keyword\">true</span>;\n                <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(<span class=\"hljs-string\">\"bind[\"</span> + rpcXid + <span class=\"hljs-string\">\"] to RootContext\"</span>);\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">return</span> invoker.invoke(invocation); <span class=\"hljs-comment\">// Business method invoke</span>\n\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-keyword\">if</span> (bind) { <span class=\"hljs-comment\">// Provider：Clean up XID after invoke</span>\n                String unbindXid = RootContext.unbind();\n                <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(<span class=\"hljs-string\">\"unbind[\"</span> + unbindXid + <span class=\"hljs-string\">\"] from RootContext\"</span>);\n                }\n                <span class=\"hljs-keyword\">if</span> (!rpcXid.equalsIgnoreCase(unbindXid)) {\n                    LOGGER.warn(<span class=\"hljs-string\">\"xid in change during RPC from \"</span> + rpcXid + <span class=\"hljs-string\">\" to \"</span> + unbindXid);\n                    <span class=\"hljs-keyword\">if</span> (unbindXid != <span class=\"hljs-keyword\">null</span>) { <span class=\"hljs-comment\">// if there is new transaction begin, can't do clean up</span>\n                        RootContext.bind(unbindXid);\n                        LOGGER.warn(<span class=\"hljs-string\">\"bind [\"</span> + unbindXid + <span class=\"hljs-string\">\"] back to RootContext\"</span>);\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>\n",
  "link": "/en-us/docs/user/microservice.html",
  "meta": {
    "title": "Microservice Framework Guide",
    "keywords": "Seata",
    "description": "Microservice Framework Guide."
  }
}