"use strict";(self.webpackChunkseata_website=self.webpackChunkseata_website||[]).push([[25932],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>d});var n=a(67294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=c(a),h=s,d=u["".concat(l,".").concat(h)]||u[h]||m[h]||i;return a?n.createElement(d,r(r({ref:t},p),{},{components:a})):n.createElement(d,r({ref:t},p))}));function d(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=a.length,r=new Array(i);r[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[u]="string"==typeof e?e:s,r[1]=o;for(var c=2;c<i;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},75114:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var n=a(87462),s=(a(67294),a(3905));const i={title:"Seata Saga Mode",keywords:["Seata","Saga"],description:"The Saga pattern is a long transaction solution provided by SEATA. In the Saga pattern, each participant in the business process submits a local transaction. If any participant fails, it compensates the previously successful participants. Both the forward service in phase one and the compensation service in phase two are implemented by business development."},r="SEATA Saga Pattern",o={unversionedId:"user/mode/saga",id:"version-v2.0/user/mode/saga",title:"Seata Saga Mode",description:"The Saga pattern is a long transaction solution provided by SEATA. In the Saga pattern, each participant in the business process submits a local transaction. If any participant fails, it compensates the previously successful participants. Both the forward service in phase one and the compensation service in phase two are implemented by business development.",source:"@site/i18n/en/docusaurus-plugin-content-docs/version-v2.0/user/mode/saga.md",sourceDirName:"user/mode",slug:"/user/mode/saga",permalink:"/docs/user/mode/saga",draft:!1,tags:[],version:"v2.0",frontMatter:{title:"Seata Saga Mode",keywords:["Seata","Saga"],description:"The Saga pattern is a long transaction solution provided by SEATA. In the Saga pattern, each participant in the business process submits a local transaction. If any participant fails, it compensates the previously successful participants. Both the forward service in phase one and the compensation service in phase two are implemented by business development."},sidebar:"docs",previous:{title:"Seata TCC Mode",permalink:"/docs/user/mode/tcc"},next:{title:"Seata XA Mode",permalink:"/docs/user/mode/xa"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Applicable Scenarios:",id:"applicable-scenarios",level:3},{value:"Advantages:",id:"advantages",level:3},{value:"Disadvantages:",id:"disadvantages",level:3},{value:"Implementation of Saga:",id:"implementation-of-saga",level:3},{value:"Saga implementation based on state machine engine:",id:"saga-implementation-based-on-state-machine-engine",level:4},{value:"Quick Start",id:"quick-start",level:2},{value:"Demo Introduction",id:"demo-introduction",level:3},{value:"Introduction to &quot;State Machine&quot; Properties:",id:"introduction-to-state-machine-properties",level:4},{value:"Introduction to &quot;State&quot; Properties:",id:"introduction-to-state-properties",level:4},{value:"Demo Running Guide",id:"demo-running-guide",level:3},{value:"Step 1: Start the SEATA Server",id:"step-1-start-the-seata-server",level:4},{value:"Step 2: Start the Dubbo Provider Demo",id:"step-2-start-the-dubbo-provider-demo",level:4},{value:"Step 3: Start the Saga Demo",id:"step-3-start-the-saga-demo",level:4},{value:"State Machine Designer",id:"state-machine-designer",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Practical Experience in Designing Saga Services",id:"practical-experience-in-designing-saga-services",level:3},{value:"Allowing Empty Compensation",id:"allowing-empty-compensation",level:4},{value:"Preventing Hanging Control",id:"preventing-hanging-control",level:4},{value:"Idempotence Control",id:"idempotence-control",level:4},{value:"Dealing with Lack of Isolation",id:"dealing-with-lack-of-isolation",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"API referance",id:"api-referance",level:2},{value:"StateMachineEngine API",id:"statemachineengine-api",level:4},{value:"StateMachine Execution Instance API:",id:"statemachine-execution-instance-api",level:4},{value:"StateMachine Definition API:",id:"statemachine-definition-api",level:4},{value:"Config Reference",id:"config-reference",level:2},{value:"Configuring a StateMachineEngine in a Spring Bean Configuration File",id:"configuring-a-statemachineengine-in-a-spring-bean-configuration-file",level:4},{value:"State Language Reference",id:"state-language-reference",level:2},{value:"List of &quot;State Machine&quot; Properties",id:"list-of-state-machine-properties",level:3},{value:"Property List of All States",id:"property-list-of-all-states",level:3},{value:"ServiceTask:",id:"servicetask",level:4},{value:"Choice:",id:"choice",level:4},{value:"Succeed:",id:"succeed",level:4},{value:"Fail:",id:"fail",level:4},{value:"CompensationTrigger:",id:"compensationtrigger",level:4},{value:"SubStateMachine:",id:"substatemachine",level:4},{value:"CompensateSubMachine:",id:"compensatesubmachine",level:4},{value:"Complex Input Parameters",id:"complex-input-parameters",level:4},{value:"Loop Branch Transaction Usage",id:"loop-branch-transaction-usage",level:4},{value:"FAQ",id:"faq",level:2}],p={toc:c},u="wrapper";function m(e){let{components:t,...i}=e;return(0,s.kt)(u,(0,n.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"seata-saga-pattern"},"SEATA Saga Pattern"),(0,s.kt)("h2",{id:"overview"},"Overview"),(0,s.kt)("p",null,"The Saga pattern is a long transaction solution provided by SEATA. In the Saga pattern, each participant in the business process submits a local transaction. If any participant fails, the Saga pattern compensates the previously successful participants. Both the forward service in phase one and the compensation service in phase two are implemented by business development."),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://img.alicdn.com/tfs/TB1Y2kuw7T2gK0jSZFkXXcIQFXa-445-444.png",alt:"Saga Mode Overview"})),(0,s.kt)("p",null,'Theoretical Basis: Paper by Hector & Kenneth titled "Sagas" (1987)'),(0,s.kt)("h3",{id:"applicable-scenarios"},"Applicable Scenarios:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Long and numerous business processes."),(0,s.kt)("li",{parentName:"ul"},"Participants include other companies or legacy system services that cannot provide the three interfaces required by the TCC pattern.")),(0,s.kt)("h3",{id:"advantages"},"Advantages:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"One-phase commits local transaction, no locks, high performance."),(0,s.kt)("li",{parentName:"ul"},"Event-driven architecture, participants can execute asynchronously, high throughput."),(0,s.kt)("li",{parentName:"ul"},"Compensation service is easy to implement.")),(0,s.kt)("h3",{id:"disadvantages"},"Disadvantages:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Does not guarantee isolation (see later documents for solutions).")),(0,s.kt)("h3",{id:"implementation-of-saga"},"Implementation of Saga:"),(0,s.kt)("h4",{id:"saga-implementation-based-on-state-machine-engine"},"Saga implementation based on state machine engine:"),(0,s.kt)("p",null,"SEATA's current Saga pattern implementation is based on a state machine engine, which works as follows:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Define the service call process through a state diagram and generate a JSON state language definition file."),(0,s.kt)("li",{parentName:"ol"},"A node in the state diagram can be a service call, and each node can configure its compensation node. "),(0,s.kt)("li",{parentName:"ol"},"The state diagram JSON is driven by the state machine engine. When an exception occurs, the engine reverses the execution of the compensation nodes for the successful nodes to roll back the transaction.",(0,s.kt)("blockquote",{parentName:"li"},(0,s.kt)("p",{parentName:"blockquote"},"Note: Whether to compensate in case of an exception can also be decided by the user."))),(0,s.kt)("li",{parentName:"ol"},"It can implement service orchestration needs, supporting features such as single choice, concurrency, sub-processes, parameter conversion, parameter mapping, service execution status judgment, and exception capture.")),(0,s.kt)("p",null,"Example state diagram:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Example State Diagram",src:a(29030).Z,width:"508",height:"543"})),(0,s.kt)("h2",{id:"quick-start"},"Quick Start"),(0,s.kt)("h3",{id:"demo-introduction"},"Demo Introduction"),(0,s.kt)("p",null,"Using the Saga pattern under microservices built with Dubbo to demonstrate the submission and rollback of distributed transactions;"),(0,s.kt)("p",null,"The business process diagram is shown below:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Demo Business Process Diagram",src:a(80595).Z,width:"266",height:"528"})),(0,s.kt)("p",null,"First, download the seata-samples project: ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/seata/seata-samples.git"},"https://github.com/seata/seata-samples.git")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note: The SEATA version needs to be 0.9.0 or above.")),(0,s.kt)("p",null,"In the dubbo-saga-sample, a distributed transaction will involve 2 Saga transaction participants: ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/seata/seata-samples/blob/master/saga/dubbo-saga-sample/src/main/java/io/seata/samples/saga/action/InventoryAction.java"},"InventoryAction")," and ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/seata/seata-samples/blob/master/saga/dubbo-saga-sample/src/main/java/io/seata/samples/saga/action/BalanceAction.java"},"BalanceAction"),". If the distributed transaction commits, both participants commit; if it rolls back, both participants roll back."),(0,s.kt)("p",null,"These two Saga participants are Dubbo services. Both participants have a reduce method, which represents inventory reduction or balance reduction, and a compensateReduce method for compensating the reduction operation."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"InventoryAction interface definition:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public interface InventoryAction {\n\n    /**\n     * reduce\n     * @param businessKey\n     * @param amount\n     * @param params\n     * @return\n     */\n    boolean reduce(String businessKey, BigDecimal amount, Map<String, Object> params);\n\n    /**\n     * compensateReduce\n     * @param businessKey\n     * @param params\n     * @return\n     */\n    boolean compensateReduce(String businessKey, Map<String, Object> params);\n}\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"The scenario defined in state language is the following JSON: src/main/resources/statelang/reduce_inventory_and_balance.json")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "Name": "reduceInventoryAndBalance",\n    "Comment": "reduce inventory then reduce balance in a transaction",\n    "StartState": "ReduceInventory",\n    "Version": "0.0.1",\n    "States": {\n        "ReduceInventory": {\n            "Type": "ServiceTask",\n            "ServiceName": "inventoryAction",\n            "ServiceMethod": "reduce",\n            "CompensateState": "CompensateReduceInventory",\n            "Next": "ChoiceState",\n            "Input": [\n                "$.[businessKey]",\n                "$.[count]"\n            ],\n            "Output": {\n                "reduceInventoryResult": "$.#root"\n            },\n            "Status": {\n                "#root == true": "SU",\n                "#root == false": "FA",\n                "$Exception{java.lang.Throwable}": "UN"\n            }\n        },\n        "ChoiceState":{\n            "Type": "Choice",\n            "Choices":[\n                {\n                    "Expression":"[reduceInventoryResult] == true",\n                    "Next":"ReduceBalance"\n                }\n            ],\n            "Default":"Fail"\n        },\n        "ReduceBalance": {\n            "Type": "ServiceTask",\n            "ServiceName": "balanceAction",\n            "ServiceMethod": "reduce",\n            "CompensateState": "CompensateReduceBalance",\n            "Input": [\n                "$.[businessKey]",\n                "$.[amount]",\n                {\n                    "throwException" : "$.[mockReduceBalanceFail]"\n                }\n            ],\n            "Output": {\n                "compensateReduceBalanceResult": "$.#root"\n            },\n            "Status": {\n                "#root == true": "SU",\n                "#root == false": "FA",\n                "$Exception{java.lang.Throwable}": "UN"\n            },\n            "Catch": [\n                {\n                    "Exceptions": [\n                        "java.lang.Throwable"\n                    ],\n                    "Next": "CompensationTrigger"\n                }\n            ],\n            "Next": "Succeed"\n        },\n        "CompensateReduceInventory": {\n            "Type": "ServiceTask",\n            "ServiceName": "inventoryAction",\n            "ServiceMethod": "compensateReduce",\n            "Input": [\n                "$.[businessKey]"\n            ]\n        },\n        "CompensateReduceBalance": {\n            "Type": "ServiceTask",\n            "ServiceName": "balanceAction",\n            "ServiceMethod": "compensateReduce",\n            "Input": [\n                "$.[businessKey]"\n            ]\n        },\n        "CompensationTrigger": {\n            "Type": "CompensationTrigger",\n            "Next": "Fail"\n        },\n        "Succeed": {\n            "Type":"Succeed"\n        },\n        "Fail": {\n            "Type":"Fail",\n            "ErrorCode": "PURCHASE_FAILED",\n            "Message": "purchase failed"\n        }\n    }\n}\n')),(0,s.kt)("p",null,"The state diagram represented by this JSON:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"State Diagram Represented by JSON",src:a(29030).Z,width:"508",height:"543"})),(0,s.kt)("p",null,'The provided text introduces the concept of "State Machine" and its attributes in the context of Seata\'s Saga pattern, which is somewhat influenced by ',(0,s.kt)("a",{parentName:"p",href:"https://docs.aws.amazon.com/zh_cn/step-functions/latest/dg/tutorial-creating-lambda-state-machine.html"},"AWS Step Functions"),". Here's the translation:"),(0,s.kt)("h4",{id:"introduction-to-state-machine-properties"},'Introduction to "State Machine" Properties:'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Name"),": Represents the unique name of the state machine."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Comment"),": A description of the state machine."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Version"),": The version of the state machine definition."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"StartState"),': The first "state" to run when starting.'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"States"),': A list of states, structured as a map where the key is the unique name of the "state" within the state machine.'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"IsRetryPersistModeUpdate"),": Whether the log is updated based on the last failed log during forward retry."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"IsCompensatePersistModeUpdate"),": Whether the log is updated based on the last compensation log during backward compensation.")),(0,s.kt)("h4",{id:"introduction-to-state-properties"},'Introduction to "State" Properties:'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Type"),': The type of "state", for example:',(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"ServiceTask"),": Executes a service call task."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Choice"),": Single condition selection routing."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"CompensationTrigger"),": Triggers the compensation process."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Succeed"),": The state machine ends normally."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Fail"),": The state machine ends abnormally."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"SubStateMachine"),": Calls a sub-state machine."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"CompensateSubMachine"),": Used to compensate a sub-state machine."))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"ServiceName"),": The name of the service, usually the beanId of the service."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"ServiceMethod"),": The name of the service method."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"CompensateState"),': The compensation "state" of that "state".'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Loop"),": Indicates whether the transaction node is a loop transaction, i.e., the framework itself iterates over the collection elements based on the configuration of the loop attributes and executes the transaction node in a loop."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Input"),": The list of input parameters for calling the service, which is an array corresponding to the parameter list of the service method. ",(0,s.kt)("inlineCode",{parentName:"li"},"$")," indicates using an expression to take parameters from the state machine context, expressed using ",(0,s.kt)("a",{parentName:"li",href:"https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html"},"SpringEL"),". If it is a constant, write the value directly."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Output"),": Maps the returned parameters of the service to the state machine context, structured as a map. The key is the key when put into the state machine context (which is also a map), and the value with ",(0,s.kt)("inlineCode",{parentName:"li"},"$")," indicates a SpringEL expression to take values from the service's returned parameters. ",(0,s.kt)("inlineCode",{parentName:"li"},"#root")," represents the entire return parameter of the service."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Status"),": The mapping of service execution status. The framework defines three statuses: SU (Success), FA (Failure), and UN (Unknown). We need to map the execution status of the service to these three statuses to help the framework judge the consistency of the entire transaction. It's structured as a map where the key is a conditional expression, generally judging from the service's return value or thrown exception. Expressions starting with ",(0,s.kt)("inlineCode",{parentName:"li"},"$Exception{")," indicate judging the type of exception. The value is the mapped execution status when this conditional expression holds."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Catch"),": Routing after catching an exception."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Next"),': The next "state" to execute after the service completes.'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Choices"),': In the Choice type "state", it\'s a list of optional branches. The Expression in the branches is a SpringEL expression, and Next is the next "state" to execute when the expression holds.'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"ErrorCode"),': The error code of the Fail type "state".'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Message"),': The error message of the Fail type "state".')),(0,s.kt)("p",null,"For a more detailed explanation of state language, please see the ",(0,s.kt)("a",{parentName:"p",href:"#State-language-referance"},"State language reference")," section."),(0,s.kt)("p",null,"For more detailed examples of state language usage, see ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/seata/seata/tree/develop/test/src/test/java/io/seata/saga/engine"},"https://github.com/seata/seata/tree/develop/test/src/test/java/io/seata/saga/engine"),"."),(0,s.kt)("h3",{id:"demo-running-guide"},"Demo Running Guide"),(0,s.kt)("h4",{id:"step-1-start-the-seata-server"},"Step 1: Start the SEATA Server"),(0,s.kt)("p",null,"Run ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/seata/seata-samples/blob/master/saga/sofarpc-saga-sample/src/test/java/io/seata/samples/saga/SeataServerStarter.java"},"SeataServerStarter")," to start the Seata Server."),(0,s.kt)("h4",{id:"step-2-start-the-dubbo-provider-demo"},"Step 2: Start the Dubbo Provider Demo"),(0,s.kt)("p",null,"Run ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/seata/seata-samples/blob/master/saga/dubbo-saga-sample/src/test/java/io/seata/samples/saga/starter/DubboSagaProviderStarter.java"},"DubboSagaProviderStarter")," to start the Dubbo provider."),(0,s.kt)("h4",{id:"step-3-start-the-saga-demo"},"Step 3: Start the Saga Demo"),(0,s.kt)("p",null,"Run ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/seata/seata-samples/blob/master/saga/dubbo-saga-sample/src/main/java/io/seata/samples/saga/starter/DubboSagaTransactionStarter.java"},"DubboSagaTransactionStarter")," to start the demo project."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"The demo uses the H2 in-memory database. For production, it is recommended to use the same type of database as your business. Currently, it supports Oracle, MySQL, and DB2. The SQL scripts for table creation can be found at ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/seata/seata/tree/develop/saga/seata-saga-engine-store/src/main/resources/sql"},"https://github.com/seata/seata/tree/develop/saga/seata-saga-engine-store/src/main/resources/sql"),".")),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"The demo also includes examples of calling local services and SOFA RPC services.")),(0,s.kt)("h2",{id:"state-machine-designer"},"State Machine Designer"),(0,s.kt)("p",null,"Seata Saga provides a visual state machine designer for user convenience. For code and running guide, please refer to:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/seata/seata/tree/develop/saga/seata-saga-statemachine-designer"},"https://github.com/seata/seata/tree/develop/saga/seata-saga-statemachine-designer")),(0,s.kt)("p",null,"Screenshot of the state machine designer:\n",(0,s.kt)("img",{alt:"State Machine Designer",src:a(30895).Z,width:"637",height:"328"})),(0,s.kt)("h2",{id:"best-practices"},"Best Practices"),(0,s.kt)("h3",{id:"practical-experience-in-designing-saga-services"},"Practical Experience in Designing Saga Services"),(0,s.kt)("h4",{id:"allowing-empty-compensation"},"Allowing Empty Compensation"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Empty Compensation: The compensation service is executed even though the original service was not."),(0,s.kt)("li",{parentName:"ul"},"Reasons for Occurrence:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"The original service times out (packet loss)."),(0,s.kt)("li",{parentName:"ul"},"The Saga transaction triggers a rollback."),(0,s.kt)("li",{parentName:"ul"},"The compensation request is received before the original service request.")))),(0,s.kt)("p",null,"Therefore, in service design, allow empty compensation, i.e., return successful compensation and record the original business key when no compensable business key is found."),(0,s.kt)("h4",{id:"preventing-hanging-control"},"Preventing Hanging Control"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Hanging: The compensation service executes before the original service."),(0,s.kt)("li",{parentName:"ul"},"Reasons for Occurrence:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"The original service times out (congestion)."),(0,s.kt)("li",{parentName:"ul"},"Saga transaction rollback is triggered."),(0,s.kt)("li",{parentName:"ul"},"The congested original service arrives later.")))),(0,s.kt)("p",null,"So, it is necessary to check whether the current business key already exists in the recorded keys of empty compensation. If it exists, refuse the execution of the service."),(0,s.kt)("h4",{id:"idempotence-control"},"Idempotence Control"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Both the original and compensation services need to ensure idempotence. Due to potential network timeouts, retry strategies can be set. When retries occur, idempotence control should be used to prevent duplicate updates of business data.")),(0,s.kt)("h3",{id:"dealing-with-lack-of-isolation"},"Dealing with Lack of Isolation"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Since Saga transactions do not guarantee isolation, extreme situations may arise where rollback operations cannot be completed due to dirty writes. For example, in a distributed transaction, first, user A is credited, and then user B\u2019s balance is reduced. If user A spends the balance before the transaction is committed, and the transaction needs to be rolled back, compensation is not possible. This is a typical problem caused by lack of isolation. Common approaches in practice are:",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},"When designing business processes, follow the principle of \u201cprefer overpayment to underpayment.\u201d Overpayment means the customer has less money and the institution has more, which can be refunded based on the institution's credibility. In contrast, underpayment means the missing money might not be recoverable. Therefore, the business process design should always deduct money first."),(0,s.kt)("li",{parentName:"ul"},'Some business scenarios may allow the business to ultimately succeed. If it is impossible to roll back, the process can continue retrying to complete subsequent steps. Therefore, in addition to providing "rollback" capabilities, the state machine engine also needs to offer "forward" capabilities to recover the context and continue execution, allowing the business to ultimately succeed and achieve final consistency.')))),(0,s.kt)("h3",{id:"performance-optimization"},"Performance Optimization"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Configuring the client parameter ",(0,s.kt)("inlineCode",{parentName:"li"},"client.rm.report.success.enable=false")," improves performance by not reporting the status of a successfully executed branch transaction to the server.",(0,s.kt)("blockquote",{parentName:"li"},(0,s.kt)("p",{parentName:"blockquote"},"When the status of a previous branch transaction has not yet been reported, and the next branch transaction has already been registered, it can be assumed that the previous one was actually successful.")))),(0,s.kt)("h2",{id:"api-referance"},"API referance"),(0,s.kt)("h4",{id:"statemachineengine-api"},"StateMachineEngine API"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"public interface StateMachineEngine {\n\n    /**\n     * start a state machine instance\n     * @param stateMachineName\n     * @param tenantId\n     * @param startParams\n     * @return\n     * @throws EngineExecutionException\n     */\n    StateMachineInstance start(String stateMachineName, String tenantId, Map<String, Object> startParams) throws EngineExecutionException;\n\n    /**\n     * start a state machine instance with businessKey\n     * @param stateMachineName\n     * @param tenantId\n     * @param businessKey\n     * @param startParams\n     * @return\n     * @throws EngineExecutionException\n     */\n    StateMachineInstance startWithBusinessKey(String stateMachineName, String tenantId, String businessKey, Map<String, Object> startParams) throws EngineExecutionException;\n\n    /**\n     * start a state machine instance asynchronously\n     * @param stateMachineName\n     * @param tenantId\n     * @param startParams\n     * @param callback\n     * @return\n     * @throws EngineExecutionException\n     */\n    StateMachineInstance startAsync(String stateMachineName, String tenantId, Map<String, Object> startParams, AsyncCallback callback) throws EngineExecutionException;\n\n    /**\n     * start a state machine instance asynchronously with businessKey\n     * @param stateMachineName\n     * @param tenantId\n     * @param businessKey\n     * @param startParams\n     * @param callback\n     * @return\n     * @throws EngineExecutionException\n     */\n    StateMachineInstance startWithBusinessKeyAsync(String stateMachineName, String tenantId, String businessKey, Map<String, Object> startParams, AsyncCallback callback) throws EngineExecutionException;\n\n    /**\n     * forward restart a failed state machine instance\n     * @param stateMachineInstId\n     * @param replaceParams\n     * @return\n     * @throws ForwardInvalidException\n     */\n    StateMachineInstance forward(String stateMachineInstId, Map<String, Object> replaceParams) throws ForwardInvalidException;\n\n    /**\n     * forward restart a failed state machine instance asynchronously\n     * @param stateMachineInstId\n     * @param replaceParams\n     * @param callback\n     * @return\n     * @throws ForwardInvalidException\n     */\n    StateMachineInstance forwardAsync(String stateMachineInstId, Map<String, Object> replaceParams, AsyncCallback callback) throws ForwardInvalidException;\n\n    /**\n     * compensate a state machine instance\n     * @param stateMachineInstId\n     * @param replaceParams\n     * @return\n     * @throws EngineExecutionException\n     */\n    StateMachineInstance compensate(String stateMachineInstId, Map<String, Object> replaceParams) throws EngineExecutionException;\n\n    /**\n     * compensate a state machine instance asynchronously\n     * @param stateMachineInstId\n     * @param replaceParams\n     * @param callback\n     * @return\n     * @throws EngineExecutionException\n     */\n    StateMachineInstance compensateAsync(String stateMachineInstId, Map<String, Object> replaceParams, AsyncCallback callback) throws EngineExecutionException;\n\n    /**\n     * skip current failed state instance and forward restart state machine instance\n     * @param stateMachineInstId\n     * @return\n     * @throws EngineExecutionException\n     */\n    StateMachineInstance skipAndForward(String stateMachineInstId) throws EngineExecutionException;\n\n    /**\n     * skip current failed state instance and forward restart state machine instance asynchronously\n     * @param stateMachineInstId\n     * @param callback\n     * @return\n     * @throws EngineExecutionException\n     */\n    StateMachineInstance skipAndForwardAsync(String stateMachineInstId, AsyncCallback callback) throws EngineExecutionException;\n\n    /**\n     * get state machine configurations\n     * @return\n     */\n    StateMachineConfig getStateMachineConfig();\n}\n")),(0,s.kt)("h4",{id:"statemachine-execution-instance-api"},"StateMachine Execution Instance API:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"StateLogRepository stateLogRepository = stateMachineEngine.getStateMachineConfig().getStateLogRepository();\nStateMachineInstance stateMachineInstance = stateLogRepository.getStateMachineInstanceByBusinessKey(businessKey, tenantId);\n\n/**\n * State Log Repository\n *\n * @author lorne.cl\n */\npublic interface StateLogRepository {\n\n    /**\n     * Get state machine instance\n     *\n     * @param stateMachineInstanceId\n     * @return\n     */\n    StateMachineInstance getStateMachineInstance(String stateMachineInstanceId);\n\n    /**\n     * Get state machine instance by businessKey\n     *\n     * @param businessKey\n     * @param tenantId\n     * @return\n     */\n    StateMachineInstance getStateMachineInstanceByBusinessKey(String businessKey, String tenantId);\n\n    /**\n     * Query the list of state machine instances by parent id\n     *\n     * @param parentId\n     * @return\n     */\n    List<StateMachineInstance> queryStateMachineInstanceByParentId(String parentId);\n\n    /**\n     * Get state instance\n     *\n     * @param stateInstanceId\n     * @param machineInstId\n     * @return\n     */\n    StateInstance getStateInstance(String stateInstanceId, String machineInstId);\n\n    /**\n     * Get a list of state instances by state machine instance id\n     *\n     * @param stateMachineInstanceId\n     * @return\n     */\n    List<StateInstance> queryStateInstanceListByMachineInstanceId(String stateMachineInstanceId);\n}\n")),(0,s.kt)("h4",{id:"statemachine-definition-api"},"StateMachine Definition API:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"StateMachineRepository stateMachineRepository = stateMachineEngine.getStateMachineConfig().getStateMachineRepository();\nStateMachine stateMachine = stateMachineRepository.getStateMachine(stateMachineName, tenantId);\n\n/**\n * StateMachineRepository\n *\n * @author lorne.cl\n */\npublic interface StateMachineRepository {\n\n    /**\n     * Gets get state machine by id.\n     *\n     * @param stateMachineId the state machine id\n     * @return the get state machine by id\n     */\n    StateMachine getStateMachineById(String stateMachineId);\n\n    /**\n     * Gets get state machine.\n     *\n     * @param stateMachineName the state machine name\n     * @param tenantId         the tenant id\n     * @return the get state machine\n     */\n    StateMachine getStateMachine(String stateMachineName, String tenantId);\n\n    /**\n     * Gets get state machine.\n     *\n     * @param stateMachineName the state machine name\n     * @param tenantId         the tenant id\n     * @param version          the version\n     * @return the get state machine\n     */\n    StateMachine getStateMachine(String stateMachineName, String tenantId, String version);\n\n    /**\n     * Register the state machine to the repository (if the same version already exists, return the existing version)\n     *\n     * @param stateMachine\n     */\n    StateMachine registryStateMachine(StateMachine stateMachine);\n\n    /**\n     * registry by resources\n     *\n     * @param resources\n     * @param tenantId\n     */\n    void registryByResources(Resource[] resources, String tenantId) throws IOException;\n}\n")),(0,s.kt)("h2",{id:"config-reference"},"Config Reference"),(0,s.kt)("h4",{id:"configuring-a-statemachineengine-in-a-spring-bean-configuration-file"},"Configuring a StateMachineEngine in a Spring Bean Configuration File"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-xml"},'<bean id="dataSource" class="...">\n...\n<bean>\n<bean id="stateMachineEngine" class="io.seata.saga.engine.impl.ProcessCtrlStateMachineEngine">\n        <property name="stateMachineConfig" ref="dbStateMachineConfig"></property>\n</bean>\n<bean id="dbStateMachineConfig" class="io.seata.saga.engine.config.DbStateMachineConfig">\n    <property name="dataSource" ref="dataSource" />\n    <property name="resources" value="statelang/*.json" />\n    <property name="enableAsync" value="true" />\n    \x3c!-- Thread pool used for event-driven execution. If all state machines execute synchronously and there are no loop tasks, it may not be necessary. --\x3e\n    <property name="threadPoolExecutor" ref="threadExecutor" />\n    <property name="applicationId" value="saga_sample" />\n    <property name="txServiceGroup" value="my_test_tx_group" />\n    <property name="sagaBranchRegisterEnable" value="false" />\n    <property name="sagaJsonParser" value="fastjson" />\n    <property name="sagaRetryPersistModeUpdate" value="false" />\n    <property name="sagaCompensatePersistModeUpdate" value="false" />\n</bean>\n<bean id="threadExecutor"\n        class="org.springframework.scheduling.concurrent.ThreadPoolExecutorFactoryBean">\n    <property name="threadNamePrefix" value="SAGA_ASYNC_EXE_" />\n    <property name="corePoolSize" value="1" />\n    <property name="maxPoolSize" value="20" />\n</bean>\n\n\x3c!-- Seata Server needs this Holder to get the stateMachineEngine instance for transaction recovery --\x3e\n<bean class="io.seata.saga.rm.StateMachineEngineHolder">\n    <property name="stateMachineEngine" ref="stateMachineEngine"/>\n</bean>\n')),(0,s.kt)("h2",{id:"state-language-reference"},"State Language Reference"),(0,s.kt)("h3",{id:"list-of-state-machine-properties"},'List of "State Machine" Properties'),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "Name": "reduceInventoryAndBalance",\n    "Comment": "reduce inventory then reduce balance in a transaction",\n    "StartState": "ReduceInventory",\n    "Version": "0.0.1",\n    "States": {\n    },\n    "IsRetryPersistModeUpdate": false,\n    "IsCompensatePersistModeUpdate": false\n}\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Name"),": Represents the name of the state machine, which must be unique."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Comment"),": A description of the state machine."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Version"),": The version of the state machine definition."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"StartState"),': The first "state" to be executed at startup.'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"States"),': A list of states, structured as a map where the key is the unique name of the "state" within the state machine, and the value is a map representing the properties of the "state".'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"IsRetryPersistModeUpdate"),": Whether the log is updated based on the last failed log during a forward retry. By default, this is false, meaning a new retry log is added (this has a higher priority than the global stateMachineConfig configuration property)."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"IsCompensatePersistModeUpdate"),": Whether the log is updated based on the last compensation log during a backward compensation. By default, this is false, meaning a new compensation log is added (this has a higher priority than the global stateMachineConfig configuration property).")),(0,s.kt)("h3",{id:"property-list-of-all-states"},"Property List of All States"),(0,s.kt)("h4",{id:"servicetask"},"ServiceTask:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'"States": {\n    ...\n    "ReduceBalance": {\n        "Type": "ServiceTask",\n        "ServiceName": "balanceAction",\n        "ServiceMethod": "reduce",\n        "CompensateState": "CompensateReduceBalance",\n        "IsForUpdate": true,\n        "IsPersist": true,\n        "IsAsync": false,\n        "IsRetryPersistModeUpdate": false,\n        "IsCompensatePersistModeUpdate": false,\n        "Loop": {\n            "Parallel": 3,\n            "Collection": "$.[collection]",\n            "ElementVariableName": "element",\n            "ElementIndexName": "loopCounter",\n            "CompletionCondition": "[nrOfCompletedInstances] / [nrOfInstances] >= 0.6"\n        },\n        "Input": [\n            "$.[businessKey]",\n            "$.[amount]",\n            {\n                "loopCounter": "$.[loopCounter]",\n                "element": "$.[element]",\n                "throwException" : "$.[mockReduceBalanceFail]"\n            }\n        ],\n        "Output": {\n            "compensateReduceBalanceResult": "$.#root"\n        },\n        "Status": {\n            "#root == true": "SU",\n            "#root == false": "FA",\n            "$Exception{java.lang.Throwable}": "UN"\n        },\n        "Retry": [\n            {\n                "Exceptions": ["io.seata.saga.engine.mock.DemoException"],\n                "IntervalSeconds": 1.5,\n                "MaxAttempts": 3,\n                "BackoffRate": 1.5\n            },\n            {\n                "IntervalSeconds": 1,\n                "MaxAttempts": 3,\n                "BackoffRate": 1.5\n            }\n        ],\n        "Catch": [\n            {\n                "Exceptions": [\n                    "java.lang.Throwable"\n                ],\n                "Next": "CompensationTrigger"\n            }\n        ],\n        "Next": "Succeed"\n    }\n    ...\n}\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"ServiceName"),": The name of the service, typically the service's bean ID."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"ServiceMethod"),": The name of the service method."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"CompensateState"),': The compensation "state" for this "state".'),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"IsForUpdate"),": Indicates if the service will update data. Default is false. If CompensateState is configured, it defaults to true, as services with compensation are typically data update services."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"IsPersist"),": Indicates if execution logs should be stored. Default is true. For some query-type services, it can be set to false. Not storing execution logs improves performance because in case of exception recovery, the service can be re-executed."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"IsAsync"),": Indicates if the service is called asynchronously. Note: Asynchronous service calls will ignore the service's return result, so the service execution status mapping defined by the user (the Status attribute below) will be ignored. It defaults to successful service call. If the asynchronous call submission fails (e.g., thread pool is full), then the service execution status is considered failed."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"IsRetryPersistModeUpdate"),": Indicates if the log is updated based on the last failed log during forward retry. Default is false, meaning a new retry log is added. This has a higher priority than the state machine properties configuration."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"IsCompensatePersistModeUpdate"),": Indicates if the log is updated based on the last compensation log during backward compensation. Default is false, meaning a new compensation log is added. This has a higher priority than the state machine properties configuration."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Loop"),": Identifies whether the transaction node is a loop transaction, i.e., the framework itself iterates over collection elements based on the configuration of loop attributes and executes the transaction node in a loop. For specific usage, see: ",(0,s.kt)("a",{parentName:"li",href:"#Loop%20transaction%20usage"},"Loop transaction usage"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Input"),": The list of input parameters for calling the service. It's an array corresponding to the service method's parameter list. ",(0,s.kt)("inlineCode",{parentName:"li"},"$")," indicates using an expression to take parameters from the state machine context, expressed using ",(0,s.kt)("a",{parentName:"li",href:"https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html"},"SpringEL"),". For constants, the value can be written directly. For how to pass complex parameters, see: ",(0,s.kt)("a",{parentName:"li",href:"#Definition%20of%20complex%20parameters%20Input"},"Definition of complex parameters Input"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Output"),": Maps the service's returned parameters to the state machine context. It's a map structure where the key is the key when put into the state machine context (the state machine context is also a map), and the value with ",(0,s.kt)("inlineCode",{parentName:"li"},"$")," indicates a SpringEL expression to take values from the service's returned parameters. ",(0,s.kt)("inlineCode",{parentName:"li"},"#root")," represents the entire return parameter of the service."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Status"),": The mapping of service execution status. The framework defines three statuses: SU (Success), FA (Failure), and UN (Unknown). We need to map the execution status of the service to these three statuses to help the framework judge the consistency of the entire transaction. It's a map structure, where the key is a conditional expression, generally judging from the service's return value or thrown exception. Expressions starting with ",(0,s.kt)("inlineCode",{parentName:"li"},"$Exception{")," indicate judging the type of exception. The value is the mapped execution status when this conditional expression holds."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Catch"),": Routing after an exception is caught."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Retry"),": The retry strategy after catching an exception. It's an array that can configure multiple rules. ",(0,s.kt)("inlineCode",{parentName:"li"},"Exceptions")," are the list of matched exceptions, ",(0,s.kt)("inlineCode",{parentName:"li"},"IntervalSeconds")," is the retry interval, ",(0,s.kt)("inlineCode",{parentName:"li"},"MaxAttempts")," is the maximum number of retries, ",(0,s.kt)("inlineCode",{parentName:"li"},"BackoffRate")," is the multiplier for the next retry interval compared to the previous one (e.g., if the last retry interval was 2 seconds, with ",(0,s.kt)("inlineCode",{parentName:"li"},"BackoffRate=1.5"),", the next retry interval will be 3 seconds). The ",(0,s.kt)("inlineCode",{parentName:"li"},"Exceptions")," attribute can be left unconfigured, which means the framework will automatically match network timeout exceptions. If a different exception occurs during the retry process, the framework will rematch the rules and retry according to the new rule, but the total number of retries for the same rule will not exceed its ",(0,s.kt)("inlineCode",{parentName:"li"},"MaxAttempts"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Next"),': The next "state" to execute after the service completes.')),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"When the Status is not configured to map the execution status of a service, the system automatically determines the status as follows:"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"If there is no exception, it is considered a successful execution."),(0,s.kt)("li",{parentName:"ul"},"If there is an exception, the system checks if the exception is a network connection timeout. If so, it is considered a failure (FA)."),(0,s.kt)("li",{parentName:"ul"},"For other exceptions, if ",(0,s.kt)("inlineCode",{parentName:"li"},"IsForUpdate=true")," for the service, the status is set to unknown (UN); otherwise, it is considered a failure (FA)."))),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"How is the overall execution status of the state machine determined? This is judged by the framework itself, and the state machine has two statuses: ",(0,s.kt)("inlineCode",{parentName:"p"},"status")," (forward execution status) and ",(0,s.kt)("inlineCode",{parentName:"p"},"compensateStatus")," (compensation status):"),(0,s.kt)("ul",{parentName:"blockquote"},(0,s.kt)("li",{parentName:"ul"},"If all services execute successfully (transaction commits successfully), then ",(0,s.kt)("inlineCode",{parentName:"li"},"status=SU"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"compensateStatus=null"),"."),(0,s.kt)("li",{parentName:"ul"},"If a service execution fails and there are successfully executed update-type services without compensation (transaction commit fails), then ",(0,s.kt)("inlineCode",{parentName:"li"},"status=UN"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"compensateStatus=null"),"."),(0,s.kt)("li",{parentName:"ul"},"If a service execution fails and there are no successfully executed update-type services without compensation (transaction commit fails), then ",(0,s.kt)("inlineCode",{parentName:"li"},"status=FA"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"compensateStatus=null"),"."),(0,s.kt)("li",{parentName:"ul"},"If compensation is successful (transaction rollback successful), then ",(0,s.kt)("inlineCode",{parentName:"li"},"status=FA/UN"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"compensateStatus=SU"),"."),(0,s.kt)("li",{parentName:"ul"},"If compensation occurs and some services are not successfully compensated (rollback fails), then ",(0,s.kt)("inlineCode",{parentName:"li"},"status=FA/UN"),", ",(0,s.kt)("inlineCode",{parentName:"li"},"compensateStatus=UN"),"."),(0,s.kt)("li",{parentName:"ul"},"In cases of transaction commit or rollback failure, the Seata Server continuously initiates retries."))),(0,s.kt)("h4",{id:"choice"},"Choice:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'"ChoiceState":{\n    "Type": "Choice",\n    "Choices":[\n        {\n            "Expression":"[reduceInventoryResult] == true",\n            "Next":"ReduceBalance"\n        }\n    ],\n    "Default":"Fail"\n}\n')),(0,s.kt)("p",null,'The Choice type of "state" is a single-item selection route:'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Choices"),": A list of optional branches. Only the first branch with a satisfied condition will be chosen."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Expression"),": A Spring Expression Language (SpringEL) expression."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Next"),': The next "state" to be executed when the Expression is satisfied.')),(0,s.kt)("h4",{id:"succeed"},"Succeed:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'"Succeed": {\n    "Type":"Succeed"\n}\n')),(0,s.kt)("p",null,'Running into the "Succeed" state indicates that the state machine has ended normally. However, a normal end does not necessarily mean a successful end. Whether it is successful depends on whether each "state" has succeeded.'),(0,s.kt)("h4",{id:"fail"},"Fail:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'"Fail": {\n    "Type":"Fail",\n    "ErrorCode": "PURCHASE_FAILED",\n    "Message": "purchase failed"\n}\n')),(0,s.kt)("p",null,'Running into the "Fail" state indicates that the state machine has ended abnormally. During an abnormal termination, you can configure an ErrorCode and Message, representing the error code and error message, respectively. These can be used to return error codes and messages to the caller.'),(0,s.kt)("h4",{id:"compensationtrigger"},"CompensationTrigger:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'"CompensationTrigger": {\n    "Type": "CompensationTrigger",\n    "Next": "Fail"\n}\n')),(0,s.kt)("p",null,"A CompensationTrigger type of state is used to trigger compensation events and roll back distributed transactions."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Next"),": The state to which it routes after successful compensation.")),(0,s.kt)("h4",{id:"substatemachine"},"SubStateMachine:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'"CallSubStateMachine": {\n    "Type": "SubStateMachine",\n    "StateMachineName": "simpleCompensationStateMachine",\n    "CompensateState": "CompensateSubMachine",\n    "IsRetryPersistModeUpdate": false,\n    "IsCompensatePersistModeUpdate": false,\n    "Input": [\n        {\n            "a": "$.1",\n            "barThrowException": "$.[barThrowException]",\n            "fooThrowException": "$.[fooThrowException]",\n            "compensateFooThrowException": "$.[compensateFooThrowException]"\n        }\n    ],\n    "Output": {\n        "fooResult": "$.#root"\n    },\n    "Next": "Succeed"\n}\n')),(0,s.kt)("p",null,'The SubStateMachine type of "state" is used for calling a sub-state machine.'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"StateMachineName"),": The name of the sub-state machine to be called."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"CompensateState"),": The compensation state of the sub-state machine. It can be left unconfigured, and the system will automatically create its compensation state. The compensation of a sub-state machine actually involves calling the compensate method of the sub-state machine, so the user does not need to implement a compensation service for the sub-state machine themselves. When this attribute is configured, one can use the Input attribute to custom pass some variables, as shown in the CompensateSubMachine below.")),(0,s.kt)("h4",{id:"compensatesubmachine"},"CompensateSubMachine:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'"CompensateSubMachine": {\n    "Type": "CompensateSubMachine",\n    "Input": [\n        {\n            "compensateFooThrowException": "$.[compensateFooThrowException]"\n        }\n    ]\n}\n')),(0,s.kt)("p",null,"The CompensateSubMachine type of state is specifically used to compensate a sub-state machine. It calls the compensate method of the sub-state machine. You can use the Input attribute to pass in some custom variables. The Status attribute is used to automatically determine whether the compensation is successful."),(0,s.kt)("h4",{id:"complex-input-parameters"},"Complex Input Parameters"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'"FirstState": {\n    "Type": "ServiceTask",\n    "ServiceName": "demoService",\n    "ServiceMethod": "complexParameterMethod",\n    "Next": "ChoiceState",\n    "ParameterTypes" : ["java.lang.String", "int", "io.seata.saga.engine.mock.DemoService$People", "[Lio.seata.saga.engine.mock.DemoService$People;", "java.util.List", "java.util.Map"],\n    "Input": [\n        "$.[people].name",\n        "$.[people].age",\n        {\n            "name": "$.[people].name",\n            "age": "$.[people].age",\n            "childrenArray": [\n                {\n                    "name": "$.[people].name",\n                    "age": "$.[people].age"\n                },\n                {\n                    "name": "$.[people].name",\n                    "age": "$.[people].age"\n                }\n            ],\n            "childrenList": [\n                {\n                    "name": "$.[people].name",\n                    "age": "$.[people].age"\n                },\n                {\n                    "name": "$.[people].name",\n                    "age": "$.[people].age"\n                }\n            ],\n            "childrenMap": {\n                "lilei": {\n                    "name": "$.[people].name",\n                    "age": "$.[people].age"\n                }\n            }\n        },\n        [\n            {\n                "name": "$.[people].name",\n                "age": "$.[people].age"\n            },\n            {\n                "name": "$.[people].name",\n                "age": "$.[people].age"\n            }\n        ],\n        [\n            {\n                "@type": "io.seata.saga.engine.mock.DemoService$People",\n                "name": "$.[people].name",\n                "age": "$.[people].age"\n            }\n        ],\n        {\n            "lilei": {\n                "@type": "io.seata.saga.engine.mock.DemoService$People",\n                "name": "$.[people].name",\n                "age": "$.[people].age"\n            }\n        }\n    ],\n    "Output": {\n        "complexParameterMethodResult": "$.#root"\n    }\n}\n')),(0,s.kt)("p",null,"The definition of the ",(0,s.kt)("inlineCode",{parentName:"p"},"complexParameterMethod")," method is as follows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},"People complexParameterMethod(String name, int age, People people, People[] peopleArray, List<People> peopleList, Map<String, People> peopleMap)\n\nclass People {\n\n    private String name;\n    private int age;\n\n    private People[] childrenArray;\n    private List<People> childrenList;\n    private Map<String, People> childrenMap;\n\n    ...\n}\n")),(0,s.kt)("p",null,"Parameters passed when starting the state machine:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},'Map<String, Object> paramMap = new HashMap<>(1);\nPeople people = new People();\npeople.setName("lilei");\npeople.setAge(18);\nparamMap.put("people", people);\nString stateMachineName = "simpleStateMachineWithComplexParams";\nStateMachineInstance inst = stateMachineEngine.start(stateMachineName, null, paramMap);\n')),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note: The ",(0,s.kt)("inlineCode",{parentName:"p"},"ParameterTypes"),' attribute is optional. When the method\'s parameter list includes Map, List, or other collection types that can have generics, this attribute is needed because Java compilation loses generics information. Therefore, you need to use this attribute. Also, in the Input JSON, add "@type" to declare the generic type (the element type of the collection).')),(0,s.kt)("h4",{id:"loop-branch-transaction-usage"},"Loop Branch Transaction Usage"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'"States": {\n    ...\n    "ReduceBalance": {\n        "Type": "ServiceTask",\n        "ServiceName": "balanceAction",\n        "ServiceMethod": "reduce",\n        "CompensateState": "CompensateReduceBalance",\n        "Loop": {\n            "Parallel": 3,\n            "Collection": "$.[collection]",\n            "ElementVariableName": "loopElement",\n            "ElementIndexName": "loopCounter",\n            "CompletionCondition": "[nrOfCompletedInstances] / [nrOfInstances] >= 0.6"\n        },\n        "Input": [\n            {\n                "loopCounter": "$.[loopCounter]",\n                "element": "$.[element]",\n                "throwException": "$.[fooThrowException]"\n            }\n        ],\n        "Output": {\n            "fooResult": "$.#root"\n        },\n        "Status": {\n            "#root == true": "SU",\n            "#root == false": "FA",\n            "$Exception{java.lang.Throwable}": "UN"\n        },\n        "Next": "ChoiceState"\n    },\n    "ChoiceState": {\n        "Type": "Choice",\n        "Choices": [\n            {\n                "Expression": "[loopResult].?[#this[fooResult] == null].size() == 0",\n                "Next": "SecondState"\n            }\n        ],\n        "Default":"Fail"\n    }\n    ...\n}\n')),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Loop"),": Configuration of the Loop attribute",(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Parallel"),": The number of threads for executing transactions concurrently. It supports concurrent execution of loop tasks, with the default being 1."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Collection"),": The collection variable name, an input parameter when the state machine starts, used by the framework to get the collection object that needs to be looped through."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"ElementVariableName"),": The name of each element in the collection, used to obtain the value of an element in branch transactions. The default is ",(0,s.kt)("inlineCode",{parentName:"li"},"loopElement"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"CompletionCondition"),": Custom condition for ending the loop. If not specified, the default is to execute all, i.e., ",(0,s.kt)("inlineCode",{parentName:"li"},"[nrOfInstances] == [nrOfCompletedInstances]"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"ElementIndexName"),": The name of the collection index, used to obtain the element index in branch transactions. The default is ",(0,s.kt)("inlineCode",{parentName:"li"},"loopCounter"),".")))),(0,s.kt)("p",null,"In loop tasks, the output parameters of each transaction are stored in a list: ",(0,s.kt)("inlineCode",{parentName:"p"},"loopResult"),". This list can be accessed in the transaction context to obtain the set of transaction execution results and to iterate over the results of each execution."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Loop Context Parameters"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"nrOfInstances"),": The total number of loop instances."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"nrOfActiveInstances"),": The total number of currently active instances."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"nrOfCompletedInstances"),": The total number of instances that have been completed."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"loopResult"),": The result set of the loop instance executions.")))),(0,s.kt)("p",null,"Example State Diagram:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Saga_Loop Example State Diagram",src:a(5674).Z,width:"706",height:"728"})),(0,s.kt)("h2",{id:"faq"},"FAQ"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," Can the Saga service process be configured without using a global transaction ID to string everything together, to save on configuration work and avoid errors in manual configuration?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:"),' Saga generally has two implementations: one based on state machine definition, like Apache Camel Saga and Eventuate, and the other based on annotations and interceptors, like ServiceComb Saga. The latter does not require a state diagram configuration. Since Saga transactions do not guarantee isolation, extreme cases like dirty writes might prevent rollback operations. For example, in a distributed transaction, user A is credited before user B\'s balance is reduced. If user A spends the balance before the transaction is committed and a rollback occurs, compensation becomes impossible. Some business scenarios might allow the business to eventually succeed by continuing retries to complete the process, so the state machine engine provides both "rollback" capability and "forward" capability to recover the context and continue execution, aiming for final consistency. Implementations based on state machines are more common in production. Implementations based on annotations and interceptors will also be provided in the future.'),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," If service A is in system 1 and service B is in system 2, and a global transaction is initiated by A calling B to start a subtransaction, does system 2 also need to maintain the three tables of the Saga state machine and configure a StateMachineEngine in the Spring Bean configuration file?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," No, it's not needed. Logs are only recorded by the initiator, and since Saga logs are only recorded by the initiator and the participant services do not have interface parameter requirements, Saga can easily integrate services from other organizations or legacy systems."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," If services in systems 1 and 2 can call each other and both can initiate global transactions, can they be used in this way? Then, do both systems 1 and 2 need to maintain the three tables of the Saga state machine and configure a StateMachineEngine?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," Yes, they can be used in this way. If both systems initiate Saga transactions, then both would need to record those three tables and configure a StateMachineEngine."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," When using Seata, it's currently in AT mode. How big would the transformation be if we switched to Saga mode?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," AT mode is completely transparent, whereas Saga is more invasive as it requires configuration of the state machine JSON. If there are many services, the transformation could be substantial."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," Is Saga mode an enhancement of long transaction processing based on AT mode?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," No, it's not based on AT. The client sides are completely separate, though the server side is reused. You can see many examples in Saga's unit tests: ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/seata/seata/tree/develop/test/src/test/java/io/seata/saga/engine"},"https://github.com/seata/seata/tree/develop/test/src/test/java/io/seata/saga/engine")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:"),' In the developer documentation, the state machine engine\'s principle diagram shows an EventQueue that is used only for initiating distributed transactions and calling other system services as if calling local services. Are the systems still using RPC calls? And is it not purely event-driven between systems? (By "purely event-driven between systems," I mean even RPC is non-blocking.)'),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," Nodes are event-driven between each other. Non-blocking RPC requires support from the RPC client, which is theoretically possible. If the RPC client is also non-blocking IO, then all aspects are asynchronous."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," Consider a business process where subsequent sub-processes, regardless of which runs first, do not affect each other and can be called asynchronously. These sub-processes are services of other systems. Has Seata Saga implemented this, and are the individual nodes asynchronous in Saga's asynchronous calls?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:"),' The asynchronous start of a state machine (stateMachineEngine.startAsync) means that all states within the state machine are executed driven by events. The entire process is actually synchronous; the next state\'s event is generated only after the previous state ends. However, calling a service asynchronously is configuring that ServiceTask as "IsAsync": true. This service will be called asynchronously and will not block the progress of the state machine, which does not care about its execution result.'),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," What are the roles of the synchronous bus and asynchronous bus in the event-driven layer of Saga's source code?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," The synchronous BUS is thread-blocking and returns only after the entire state machine has finished executing. The asynchronous BUS is non-thread-blocking; it returns immediately after the call, and the state machine engine calls back your Callback after it has finished executing."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," IsPersist: Does the execution log get stored? It's true by default, but some query-type services can be configured to false, so the execution log is not stored to improve performance, as services can be re-executed in case of exception recovery, right?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," Yes, it can be configured to false. However,"),(0,s.kt)("p",null,"it's recommended to keep the default initially for a complete query execution log. Performance tuning can be considered later if needed; generally, there shouldn't be performance issues."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," For seata saga, if the client initiating the transaction or the seata server side crashes or restarts, how are unfinished state machine instances ensured to continue execution? Who triggers this operation?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," State machine instances are logged in the local database and recovered through these logs. The seata server triggers transaction recovery."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," Does Saga's JSON file support hot deployment?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," Yes, it supports hot deployment. You can use stateMachineEngine.getStateMachineConfig().getStateMachineRepository().registryByResources(). However, Java code and services need to implement support for hot deployment themselves."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," If both inputs and outputs are placed in Saga's context, and if there are many or large parameters and a large volume of business, are there any memory limitations?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," There are no limitations set. It's recommended not to put irrelevant parameters into the context. Parameters needed by the next service or for branch judgment can be put into the context."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," Just to confirm: Each node either handles exceptions internally to ensure there are return messages, or does not handle them internally and lets the state machine engine catch exceptions, defining the Catch attribute in JSON. So, compensation nodes do not automatically trigger compensation; manual intervention is needed in JSON, routing to CompensationTrigger through Catch or Choices attributes, right?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," Yes, that's correct. This design is to increase flexibility. Users can control whether to roll back because not all exceptions require rollback; there may be some custom handling methods."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," So Catch and Choices can be freely routed to the desired state, right?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," Yes. This custom compensation triggering design is based on BPMN 2.0."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Q:")," Regarding the JSON file, I plan to define one JSON for one process. Even though some processes are similar and can be solved with Choices, I feel the JSON should be as simple as possible. Is this consideration correct?"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"A:")," You can consider using a sub-state machine for reuse. A sub-state machine will generate an additional line of stateMachineInstance records, but the impact on performance should be minimal."))}m.isMDXComponent=!0},80595:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/demo_business_process-d7e667de4ce267e36b6851a1e820bc5b.png"},29030:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/demo_statelang-90f1fc01bfaf3a795c3b3357e1046f16.png"},5674:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/saga_loop_process-6520c9778e445f4a8340ca78944f09de.png"},30895:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/seata-saga-statemachine-designer-4d721b255c7c92189f04178dd7489e57.png"}}]);