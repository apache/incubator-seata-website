{
  "filename": "isolation.md",
  "__html": "<h1>Seata事务隔离</h1>\n<blockquote>\n<p>本文目标：帮助用户明白使用Seata <strong>AT模式</strong>时，该如何正确实现事务隔离，防止脏读脏写。</p>\n<p><strong>希望读者在阅读本文前，已阅读过seata官网中对AT模式的介绍，并且对数据库本地锁有所了解</strong></p>\n<p>（例如，两个事务同时在对同一条记录做update时，只有拿到record lock的事务才能更新成功，另一个事务在record lock未释放前只能等待，直到事务超时）</p>\n</blockquote>\n<p>首先请看这样的一段代码，尽管看着“初级”，但持久层框架实际上帮我们做的主要事情也就这样。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StorageService</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> DataSource dataSource;\n\n    <span class=\"hljs-meta\">@GlobalTransactional</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">batchUpdate</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        Connection connection = <span class=\"hljs-keyword\">null</span>;\n        PreparedStatement preparedStatement = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            connection = dataSource.getConnection();\n            connection.setAutoCommit(<span class=\"hljs-keyword\">false</span>);\n            String sql = <span class=\"hljs-string\">\"update storage_tbl set count = ?\"</span> +\n                <span class=\"hljs-string\">\"    where id = ? and commodity_code = ?\"</span>;\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.setInt(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">100</span>);\n            preparedStatement.setLong(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>);\n            preparedStatement.setString(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">\"2001\"</span>);\n            preparedStatement.executeUpdate();\n            connection.commit();\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            <span class=\"hljs-keyword\">throw</span> e;\n        } <span class=\"hljs-keyword\">finally</span> {\n            IOutils.close(preparedStatement);\n            IOutils.close(connection);\n        }\n    }\n\n}\n</code></pre>\n<h2>从代理数据源说起</h2>\n<p>使用AT模式，最重要的事情便是代理数据源，那么用<code>DataSourceProxy</code>代理数据源有什么作用呢？</p>\n<p>DataSourceProxy能帮助我们获得几个重要的代理对象</p>\n<ul>\n<li>\n<p>通过<code>DataSourceProxy.getConnection()</code>获得<code>ConnectionProxy</code></p>\n</li>\n<li>\n<p>通过<code>ConnectionProxy.prepareStatement(...)</code>获得<code>StatementProxy</code></p>\n</li>\n</ul>\n<p>Seata的如何实现事务隔离，就藏在这2个Proxy中，我先概述下实现逻辑。</p>\n<h3><strong><code>StatementProxy.executeXXX()</code>的处理逻辑</strong></h3>\n<ul>\n<li>\n<p>当调用<code>io.seata.rm.datasource.StatementProxy.executeXXX()</code>会将sql交给<code>io.seata.rm.datasource.exec.ExecuteTemplate.execute(...)</code>处理。</p>\n<ul>\n<li><code>ExecuteTemplate.execute(...)</code>方法中，Seata根据不同dbType和sql语句类型使用不同的Executer，调用<code>io.seata.rm.datasource.exec.Executer</code>类的<code>execute(Object... args)</code>。</li>\n<li>如果选了DML类型Executer，主要做了以下事情：\n<ul>\n<li>查询前镜像（select for update，因此此时获得本地锁）</li>\n<li>执行业务sql</li>\n<li>查询后镜像</li>\n<li>准备undoLog</li>\n</ul>\n</li>\n<li>如果你的sql是select for update则会使用<code>SelectForUpdateExecutor</code>（Seata代理了select for update），代理后处理的逻辑是这样的：\n<ul>\n<li>先执行 select for update（获取数据库本地锁）</li>\n<li>如果处于<code>@GlobalTransactional</code> or <code>@GlobalLock</code>，<strong>检查</strong>是否有全局锁</li>\n<li>如果有全局锁，则未开启本地事务下会rollback本地事务,再重新争抢本地锁和全局锁,以此类推,除非拿到全局锁</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3><strong><code>ConnectionProxy.commit()</code>的处理逻辑</strong></h3>\n<ul>\n<li>处于全局事务中（即，数据持久化方法带有<code>@GlobalTransactional</code>）\n<ul>\n<li>注册分支事务，获取全局锁</li>\n<li>undoLog数据入库</li>\n<li>让数据库commit本次事务</li>\n</ul>\n</li>\n<li>处于<code>@GlobalLock</code>中（即，数据持久化方法带有<code>@GlobalLock</code>）\n<ul>\n<li>向tc查询是否有全局锁存在，如存在，则抛出异常</li>\n<li>让数据库commit本次事务</li>\n</ul>\n</li>\n<li>除了以上情况（<code>else</code>分支）\n<ul>\n<li>让数据库commit本次事务</li>\n</ul>\n</li>\n</ul>\n<h3><strong>@GlobalTransactional的作用</strong></h3>\n<p>标识一个全局事务</p>\n<h3><strong>@GlobalLock + select for update的作用</strong></h3>\n<p>如果像<code>updateA()</code>方法带有<code>@GlobalLock + select for update</code>，Seata在处理时，会先获取数据库本地锁，然后查询该记录是否有全局锁存在，若有，则抛出LockConflictException。</p>\n<h2>先举一个脏写的例子，再来看Seata如何防止脏写</h2>\n<p>假设你的业务代码是这样的：</p>\n<ul>\n<li><code>updateAll()</code>用来同时更新A和B表记录，<code>updateA()</code> <code>updateB()</code>则分别更新A、B表记录</li>\n<li><code>updateAll()</code>已经加上了<code>@GlobalTransactional</code></li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">YourBussinessService</span> </span>{\n\n    DbServiceA serviceA;\n    DbServiceB serviceB;\n\n    <span class=\"hljs-meta\">@GlobalTransactional</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">updateAll</span><span class=\"hljs-params\">(DTO dto)</span> </span>{\n        serviceA.update(dto.getA());\n        serviceB.update(dto.getB());\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">updateA</span><span class=\"hljs-params\">(DTO dto)</span> </span>{\n        serviceA.update(dto.getA());\n    }\n\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DbServiceA</span> </span>{\n    <span class=\"hljs-meta\">@Transactional</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(A a)</span> </span>{\n    \n    }\n}\n\n</code></pre>\n<p><img src=\"/img/seata-isolation/dirty-write.png\" alt=\"dirty-write\">\n|</p>\n<h2><strong>怎么用Seata防止脏写？</strong></h2>\n<h3>办法一：<code>updateA()</code>也加上<code>@GlobalTransactional</code>，此时Seata会如何保证事务隔离？</h3>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DbServiceA</span> </span>{\n\n    <span class=\"hljs-meta\">@GlobalTransactional</span>\n    <span class=\"hljs-meta\">@Transactional</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">updateA</span><span class=\"hljs-params\">(DTO dto)</span> </span>{\n\n        serviceA.update(dto.getA());\n\n    }\n}\n</code></pre>\n<ul>\n<li><code>updateAll()</code>先被调用（未完成），<code>updateA()</code>后被调用</li>\n</ul>\n<p><img src=\"/img/seata-isolation/prevent-dirty-write-by-GlobalTransaction.png\" alt=\"dirty-write\"></p>\n<h3>办法二： <strong>@GlobalLock + select for update</strong></h3>\n<pre><code class=\"language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DbServiceA</span> </span>{\n    \n    <span class=\"hljs-meta\">@GlobalLock</span>\n    <span class=\"hljs-meta\">@Transactional</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">updateA</span><span class=\"hljs-params\">(DTO dto)</span> </span>{\n\n        serviceA.selectForUpdate(dto.getA());\n\n        serviceA.update(dto.getA());\n\n    }\n}\n</code></pre>\n<ul>\n<li>\n<p><code>updateAll()</code>先被调用（未完成），<code>updateA()</code>后被调用\n<img src=\"/img/seata-isolation/prevent-dirty-write-by-GlobalLock.png\" alt=\"dirty-write\"></p>\n</li>\n<li>\n<p>那如果是<code>updateA()</code>先被调用（未完成），<code>updateAll()</code>后被调用呢？<br>\n由于2个业务都是要先获得本地锁，因此同样不会发生脏写</p>\n</li>\n<li>\n<p>一定有人会问，“这里为什么要加上select for update? 只用@GlobalLock能不能防止脏写？”\n能。但请再回看下上面的图，select for update能带来这么几个好处：</p>\n<ul>\n<li>锁冲突更“温柔”些。如果只有@GlobalLock，检查到全局锁，则立刻抛出异常，也许再“坚持”那么一下，全局锁就释放了，抛出异常岂不可惜了。</li>\n<li>在<code>updateA()</code>中可以通过select for update获得最新的A，接着再做更新。</li>\n</ul>\n</li>\n</ul>\n<h2><strong>如何防止脏读？</strong></h2>\n<h3>场景：   某业务先调用<code>updateAll()</code>，<code>updateAll()</code>未执行完成，另一业务后调用<code>queryA()</code></h3>\n<p><img src=\"/img/seata-isolation/prevent-dirty-read.png\" alt=\"dirty-write\"></p>\n<hr>\n<h1><strong>源码展示</strong></h1>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">StorageService</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> DataSource dataSource;\n\n    <span class=\"hljs-meta\">@GlobalTransactional</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        Connection connection = <span class=\"hljs-keyword\">null</span>;\n        PreparedStatement preparedStatement = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            connection = dataSource.getConnection();\n            connection.setAutoCommit(<span class=\"hljs-keyword\">false</span>);\n            String sql = <span class=\"hljs-string\">\"update storage_tbl set count = ?\"</span> +\n                <span class=\"hljs-string\">\"    where id = ? and commodity_code = ?\"</span>;\n            preparedStatement = connection.prepareStatement(sql);\n            preparedStatement.setInt(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">100</span>);\n            preparedStatement.setLong(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>);\n            preparedStatement.setString(<span class=\"hljs-number\">3</span>, <span class=\"hljs-string\">\"2001\"</span>);\n            preparedStatement.execute();\n            connection.commit();\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            <span class=\"hljs-keyword\">throw</span> e;\n        } <span class=\"hljs-keyword\">finally</span> {\n            IOutils.close(preparedStatement);\n            IOutils.close(connection);\n        }\n    }\n\n}\n</code></pre>\n<p>这段代码虽然看着很初级，没有使用持久层框架，但如果将框架帮我们做的事情抽象出来，其实也就是上面这段代码。</p>\n<p><strong>简单说明接下来源码介绍的脉络（主要关注和事务隔离有关的源码）</strong></p>\n<ul>\n<li>代理数据源的用途\n<ul>\n<li><code>DataSourceProxy</code>的作用（返回<code>ConnectionProxy</code>）\n<ul>\n<li>介绍 <code>ConnectionProxy</code>的一个小功能（存放undolog）</li>\n</ul>\n</li>\n<li><code>ConnectionProxy</code>的作用（返回<code>StatementProxy</code>）</li>\n<li><code>StatementProxy.execute()</code>的处理逻辑\n<ul>\n<li><code>io.seata.rm.datasource.exec.UpdateExecutor</code>的执行逻辑（查前镜像、执行sql、查后镜像、准备undoLog）</li>\n<li><code>SelectForUpdateExecutor</code>的执行逻辑（挣本地锁，查全局锁。有全局锁，回滚，再争...）</li>\n</ul>\n</li>\n<li><code>ConnectionProxy.commit()</code>的处理逻辑（注册分支事务（争全局锁），写入undoLog，数据库提交）</li>\n</ul>\n</li>\n<li>介绍RootContext</li>\n<li><code>GlobalTransactionalInterceptor</code>的不同代理逻辑\n<ul>\n<li>带有<code>@GlobalTransactional</code>如何处理</li>\n<li>带有<code>@GlobalLock</code>如何处理</li>\n</ul>\n</li>\n</ul>\n<h2><strong>DataSourceProxy的作用</strong></h2>\n<p>DataSourceProxy帮助我们获得几个重要的代理对象</p>\n<ul>\n<li>通过<code>DataSourceProxy.getConnection()</code>获得<code>ConnectionProxy</code><pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.rm.datasource;\n\n<span class=\"hljs-keyword\">import</span> java.sql.Connection;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DataSourceProxy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractDataSourceProxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Resource</span> </span>{\n    \n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ConnectionProxy <span class=\"hljs-title\">getConnection</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        Connection targetConnection = targetDataSource.getConnection();\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> ConnectionProxy(<span class=\"hljs-keyword\">this</span>, targetConnection);\n    }\n}\n</code></pre>\n<ul>\n<li>现在先介绍下<code>ConnectionProxy</code>中的<code>ConnectionContext</code>，它的有一个功能是<strong>存放undoLog</strong>。<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.rm.datasource;\n\n<span class=\"hljs-keyword\">import</span> io.seata.rm.datasource.undo.SQLUndoLog;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConnectionProxy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractConnectionProxy</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> ConnectionContext context = <span class=\"hljs-keyword\">new</span> ConnectionContext();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">appendUndoLog</span><span class=\"hljs-params\">(SQLUndoLog sqlUndoLog)</span> </span>{\n        context.appendUndoItem(sqlUndoLog);\n    }\n\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.rm.datasource;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConnectionContext</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Savepoint DEFAULT_SAVEPOINT = <span class=\"hljs-keyword\">new</span> Savepoint() {\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getSavepointId</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        }\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getSavepointName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"DEFAULT_SEATA_SAVEPOINT\"</span>;\n        }\n    };\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Map&lt;Savepoint, List&lt;SQLUndoLog&gt;&gt; sqlUndoItemsBuffer = <span class=\"hljs-keyword\">new</span> LinkedHashMap&lt;&gt;();\n\n    <span class=\"hljs-keyword\">private</span> Savepoint currentSavepoint = DEFAULT_SAVEPOINT;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">appendUndoItem</span><span class=\"hljs-params\">(SQLUndoLog sqlUndoLog)</span> </span>{\n        sqlUndoItemsBuffer.computeIfAbsent(currentSavepoint, k -&gt; <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;()).add(sqlUndoLog);\n    }\n\n}\n\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2><strong>通过<code>ConnectionProxy.prepareStatement(...)</code>获得<code>StatementProxy</code></strong></h2>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.rm.datasource;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConnectionProxy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractConnectionProxy</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">ConnectionProxy</span><span class=\"hljs-params\">(DataSourceProxy dataSourceProxy, Connection targetConnection)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(dataSourceProxy, targetConnection);\n    }\n\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.rm.datasource;\n\n<span class=\"hljs-keyword\">import</span> java.sql.Connection;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AbstractConnectionProxy</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Connection</span> </span>{\n\n    <span class=\"hljs-keyword\">protected</span> Connection targetConnection;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AbstractConnectionProxy</span><span class=\"hljs-params\">(DataSourceProxy dataSourceProxy, Connection targetConnection)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.dataSourceProxy = dataSourceProxy;\n        <span class=\"hljs-keyword\">this</span>.targetConnection = targetConnection;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> PreparedStatement <span class=\"hljs-title\">prepareStatement</span><span class=\"hljs-params\">(String sql)</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        String dbType = getDbType();\n        <span class=\"hljs-comment\">// support oracle 10.2+</span>\n        PreparedStatement targetPreparedStatement = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">if</span> (BranchType.AT == RootContext.getBranchType()) { <span class=\"hljs-comment\">//为什么这里会返回AT？</span>\n            List&lt;SQLRecognizer&gt; sqlRecognizers = SQLVisitorFactory.get(sql, dbType);\n            <span class=\"hljs-keyword\">if</span> (sqlRecognizers != <span class=\"hljs-keyword\">null</span> &amp;&amp; sqlRecognizers.size() == <span class=\"hljs-number\">1</span>) {\n                SQLRecognizer sqlRecognizer = sqlRecognizers.get(<span class=\"hljs-number\">0</span>);\n                <span class=\"hljs-keyword\">if</span> (sqlRecognizer != <span class=\"hljs-keyword\">null</span> &amp;&amp; sqlRecognizer.getSQLType() == SQLType.INSERT) {\n                    TableMeta tableMeta = TableMetaCacheFactory.getTableMetaCache(dbType).getTableMeta(getTargetConnection(),\n                            sqlRecognizer.getTableName(), getDataSourceProxy().getResourceId());\n                    String[] pkNameArray = <span class=\"hljs-keyword\">new</span> String[tableMeta.getPrimaryKeyOnlyName().size()];\n                    tableMeta.getPrimaryKeyOnlyName().toArray(pkNameArray);\n                    <span class=\"hljs-comment\">// 如果是insert语句，这里创建的PreparedStatement需要可以返回自动生成的主键，因此使用这个prepareStatement()</span>\n                    targetPreparedStatement = getTargetConnection().prepareStatement(sql,pkNameArray);\n\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (targetPreparedStatement == <span class=\"hljs-keyword\">null</span>) {\n            targetPreparedStatement = getTargetConnection().prepareStatement(sql);\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> PreparedStatementProxy(<span class=\"hljs-keyword\">this</span>, targetPreparedStatement, sql);\n    }\n\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Connection <span class=\"hljs-title\">getTargetConnection</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> targetConnection;\n    }\n\n}\n</code></pre>\n<blockquote>\n<p>先在这打下个疑问，后边解释。<br>\n<strong><code>RootContext.getBranchType()</code>的返回值怎么会是AT？</strong></p>\n</blockquote>\n<h2><strong><code>StatementProxy.execute()</code>的处理逻辑</strong></h2>\n<ul>\n<li>\n<p>当调用<code>io.seata.rm.datasource.StatementProxy.execute()</code>会将sql交给<code>io.seata.rm.datasource.exec.ExecuteTemplate.execute(...)</code>处理。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.rm.datasource;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PreparedStatementProxy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractPreparedStatementProxy</span>\n    <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">PreparedStatement</span>, <span class=\"hljs-title\">ParametersHolder</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        <span class=\"hljs-keyword\">return</span> ExecuteTemplate.execute(<span class=\"hljs-keyword\">this</span>, (statement, args) -&gt; statement.execute());\n    }\n\n}\n</code></pre>\n<ul>\n<li>\n<p><code>ExecuteTemplate.execute(...)</code>方法中，Seata根据不同dbType和sql语句类型使用不同的Executer，调用<code>io.seata.rm.datasource.exec.Executer</code>类的<code>execute(Object... args)</code>。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.rm.datasource.exec;\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExecuteTemplate</span> </span>{\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T, S extends Statement&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(StatementProxy&lt;S&gt; statementProxy,\n                                             StatementCallback&lt;T, S&gt; statementCallback,\n                                             Object... args)</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        <span class=\"hljs-keyword\">return</span> execute(<span class=\"hljs-keyword\">null</span>, statementProxy, statementCallback, args);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> &lt;T, S extends Statement&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(List&lt;SQLRecognizer&gt; sqlRecognizers,\n                                         StatementProxy&lt;S&gt; statementProxy,\n                                         StatementCallback&lt;T, S&gt; statementCallback,\n                                         Object... args)</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        <span class=\"hljs-keyword\">if</span> (!RootContext.requireGlobalLock() &amp;&amp; BranchType.AT != RootContext.getBranchType()) {\n            <span class=\"hljs-comment\">// Just work as original statement</span>\n            <span class=\"hljs-keyword\">return</span> statementCallback.execute(statementProxy.getTargetStatement(), args);\n        }\n\n        String dbType = statementProxy.getConnectionProxy().getDbType();\n        <span class=\"hljs-keyword\">if</span> (CollectionUtils.isEmpty(sqlRecognizers)) {\n            sqlRecognizers = SQLVisitorFactory.get(\n                    statementProxy.getTargetSQL(),\n                    dbType);\n        }\n        Executor&lt;T&gt; executor;\n        <span class=\"hljs-keyword\">if</span> (CollectionUtils.isEmpty(sqlRecognizers)) {\n            executor = <span class=\"hljs-keyword\">new</span> PlainExecutor&lt;&gt;(statementProxy, statementCallback);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> (sqlRecognizers.size() == <span class=\"hljs-number\">1</span>) {\n                SQLRecognizer sqlRecognizer = sqlRecognizers.get(<span class=\"hljs-number\">0</span>);\n                <span class=\"hljs-keyword\">switch</span> (sqlRecognizer.getSQLType()) {\n                    <span class=\"hljs-keyword\">case</span> INSERT:\n                        executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,\n                                <span class=\"hljs-keyword\">new</span> Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},\n                                <span class=\"hljs-keyword\">new</span> Object[]{statementProxy, statementCallback, sqlRecognizer});\n                        <span class=\"hljs-keyword\">break</span>;\n                    <span class=\"hljs-keyword\">case</span> UPDATE:\n                        executor = <span class=\"hljs-keyword\">new</span> UpdateExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizer);\n                        <span class=\"hljs-keyword\">break</span>;\n                    <span class=\"hljs-keyword\">case</span> DELETE:\n                        executor = <span class=\"hljs-keyword\">new</span> DeleteExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizer);\n                        <span class=\"hljs-keyword\">break</span>;\n                    <span class=\"hljs-keyword\">case</span> SELECT_FOR_UPDATE:\n                        executor = <span class=\"hljs-keyword\">new</span> SelectForUpdateExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizer);\n                        <span class=\"hljs-keyword\">break</span>;\n                    <span class=\"hljs-keyword\">default</span>:\n                        executor = <span class=\"hljs-keyword\">new</span> PlainExecutor&lt;&gt;(statementProxy, statementCallback);\n                        <span class=\"hljs-keyword\">break</span>;\n                }\n            } <span class=\"hljs-keyword\">else</span> {\n                executor = <span class=\"hljs-keyword\">new</span> MultiExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizers);\n            }\n        }\n        T rs;\n        <span class=\"hljs-keyword\">try</span> {\n            rs = executor.execute(args);\n        } <span class=\"hljs-keyword\">catch</span> (Throwable ex) {\n            <span class=\"hljs-keyword\">if</span> (!(ex <span class=\"hljs-keyword\">instanceof</span> SQLException)) {\n                <span class=\"hljs-comment\">// Turn other exception into SQLException</span>\n                ex = <span class=\"hljs-keyword\">new</span> SQLException(ex);\n            }\n            <span class=\"hljs-keyword\">throw</span> (SQLException) ex;\n        }\n        <span class=\"hljs-keyword\">return</span> rs;\n    }\n\n}\n</code></pre>\n<blockquote>\n<p>也在这打下个疑问，后边解释。<br>\n<strong><code>RootContext.requireGlobalLock()</code>怎么判断当前是否需要全局锁？</strong></p>\n</blockquote>\n<p>先以<code>io.seata.rm.datasource.exec.UpdateExecutor</code>举例，<code>UpdateExecutor</code> extends <code>AbstractDMLBaseExecutor</code> extends <code>BaseTransactionalExecutor</code>。\n观察<code>execute()</code>方法的做了什么</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.rm.datasource.exec;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseTransactionalExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Statement</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Executor</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n    \n\n    <span class=\"hljs-keyword\">protected</span> StatementProxy&lt;S&gt; statementProxy;\n\n    <span class=\"hljs-keyword\">protected</span> StatementCallback&lt;T, S&gt; statementCallback;\n\n    <span class=\"hljs-keyword\">protected</span> SQLRecognizer sqlRecognizer;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">BaseTransactionalExecutor</span><span class=\"hljs-params\">(StatementProxy&lt;S&gt; statementProxy, StatementCallback&lt;T, S&gt; statementCallback,\n        SQLRecognizer sqlRecognizer)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.statementProxy = statementProxy;\n        <span class=\"hljs-keyword\">this</span>.statementCallback = statementCallback;\n        <span class=\"hljs-keyword\">this</span>.sqlRecognizer = sqlRecognizer;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(Object... args)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        String xid = RootContext.getXID();\n        <span class=\"hljs-keyword\">if</span> (xid != <span class=\"hljs-keyword\">null</span>) {\n            statementProxy.getConnectionProxy().bind(xid);\n        }\n\n        statementProxy.getConnectionProxy().setGlobalLockRequire(RootContext.requireGlobalLock());\n        <span class=\"hljs-keyword\">return</span> doExecute(args);\n    }\n\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AbstractDMLBaseExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Statement</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseTransactionalExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span>&gt; </span>{\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">AbstractDMLBaseExecutor</span><span class=\"hljs-params\">(StatementProxy&lt;S&gt; statementProxy, StatementCallback&lt;T, S&gt; statementCallback,\n                           SQLRecognizer sqlRecognizer)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(statementProxy, statementCallback, sqlRecognizer);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">doExecute</span><span class=\"hljs-params\">(Object... args)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        AbstractConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n        <span class=\"hljs-keyword\">if</span> (connectionProxy.getAutoCommit()) {\n            <span class=\"hljs-keyword\">return</span> executeAutoCommitTrue(args);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> executeAutoCommitFalse(args);\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> T <span class=\"hljs-title\">executeAutoCommitTrue</span><span class=\"hljs-params\">(Object[] args)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n        <span class=\"hljs-keyword\">try</span> {\n            connectionProxy.changeAutoCommit(); <span class=\"hljs-comment\">// 注意，你如果没开启事务，seata帮你开启</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> LockRetryPolicy(connectionProxy).execute(() -&gt; {\n                T result = executeAutoCommitFalse(args);\n                connectionProxy.commit(); <span class=\"hljs-comment\">// 帮你开启事务后，通过connectionProxy来提交</span>\n                <span class=\"hljs-keyword\">return</span> result;\n            });\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            <span class=\"hljs-comment\">// when exception occur in finally,this exception will lost, so just print it here</span>\n            LOGGER.error(<span class=\"hljs-string\">\"execute executeAutoCommitTrue error:{}\"</span>, e.getMessage(), e);\n            <span class=\"hljs-keyword\">if</span> (!LockRetryPolicy.isLockRetryPolicyBranchRollbackOnConflict()) {\n                connectionProxy.getTargetConnection().rollback();\n            }\n            <span class=\"hljs-keyword\">throw</span> e;\n        } <span class=\"hljs-keyword\">finally</span> {\n            connectionProxy.getContext().reset();\n            connectionProxy.setAutoCommit(<span class=\"hljs-keyword\">true</span>);\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> T <span class=\"hljs-title\">executeAutoCommitFalse</span><span class=\"hljs-params\">(Object[] args)</span> <span class=\"hljs-keyword\">throws</span> Exception </span>{\n        <span class=\"hljs-keyword\">if</span> (!JdbcConstants.MYSQL.equalsIgnoreCase(getDbType()) &amp;&amp; isMultiPk()) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NotSupportYetException(<span class=\"hljs-string\">\"multi pk only support mysql!\"</span>);\n        }\n        TableRecords beforeImage = beforeImage();\n        T result = statementCallback.execute(statementProxy.getTargetStatement(), args);\n        TableRecords afterImage = afterImage(beforeImage);\n        prepareUndoLog(beforeImage, afterImage);\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.rm.datasource.exec;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UpdateExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Statement</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractDMLBaseExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span>&gt; </span>{\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">UpdateExecutor</span><span class=\"hljs-params\">(StatementProxy&lt;S&gt; statementProxy, StatementCallback&lt;T, S&gt; statementCallback,\n                        SQLRecognizer sqlRecognizer)</span> </span>{\n        <span class=\"hljs-keyword\">super</span>(statementProxy, statementCallback, sqlRecognizer);\n    }\n\n}\n\n</code></pre>\n</li>\n<li>\n<p>如果选了DML类型Executer，可以在上面的executeAutoCommitFalse()中看到，主要做了以下事情：</p>\n<ul>\n<li>\n<p>查询前镜像（select for update，因此此时获得本地锁）</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.rm.datasource.exec;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UpdateExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Statement</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractDMLBaseExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span>&gt; </span>{\n    \n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">boolean</span> ONLY_CARE_UPDATE_COLUMNS = CONFIG.getBoolean(\n            ConfigurationKeys.TRANSACTION_UNDO_ONLY_CARE_UPDATE_COLUMNS, DefaultValues.DEFAULT_ONLY_CARE_UPDATE_COLUMNS); <span class=\"hljs-comment\">// 默认为true</span>\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> TableRecords <span class=\"hljs-title\">beforeImage</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        ArrayList&lt;List&lt;Object&gt;&gt; paramAppenderList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n        TableMeta tmeta = getTableMeta();\n        String selectSQL = buildBeforeImageSQL(tmeta, paramAppenderList);\n        <span class=\"hljs-comment\">// SELECT id, count FROM storage_tbl WHERE id = ? FOR UPDATE</span>\n        <span class=\"hljs-keyword\">return</span> buildTableRecords(tmeta, selectSQL, paramAppenderList);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title\">buildBeforeImageSQL</span><span class=\"hljs-params\">(TableMeta tableMeta, ArrayList&lt;List&lt;Object&gt;&gt; paramAppenderList)</span> </span>{\n        SQLUpdateRecognizer recognizer = (SQLUpdateRecognizer) sqlRecognizer;\n        List&lt;String&gt; updateColumns = recognizer.getUpdateColumns();\n        StringBuilder prefix = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-string\">\"SELECT \"</span>);\n        StringBuilder suffix = <span class=\"hljs-keyword\">new</span> StringBuilder(<span class=\"hljs-string\">\" FROM \"</span>).append(getFromTableInSQL());\n        String whereCondition = buildWhereCondition(recognizer, paramAppenderList);\n        <span class=\"hljs-keyword\">if</span> (StringUtils.isNotBlank(whereCondition)) {\n            suffix.append(WHERE).append(whereCondition);\n        }\n        String orderBy = recognizer.getOrderBy();\n        <span class=\"hljs-keyword\">if</span> (StringUtils.isNotBlank(orderBy)) {\n            suffix.append(orderBy);\n        }\n        ParametersHolder parametersHolder = statementProxy <span class=\"hljs-keyword\">instanceof</span> ParametersHolder ? (ParametersHolder)statementProxy : <span class=\"hljs-keyword\">null</span>;\n        String limit = recognizer.getLimit(parametersHolder, paramAppenderList);\n        <span class=\"hljs-keyword\">if</span> (StringUtils.isNotBlank(limit)) {\n            suffix.append(limit);\n        }\n        suffix.append(<span class=\"hljs-string\">\" FOR UPDATE\"</span>);\n        StringJoiner selectSQLJoin = <span class=\"hljs-keyword\">new</span> StringJoiner(<span class=\"hljs-string\">\", \"</span>, prefix.toString(), suffix.toString());\n        <span class=\"hljs-keyword\">if</span> (ONLY_CARE_UPDATE_COLUMNS) {\n            <span class=\"hljs-keyword\">if</span> (!containsPK(updateColumns)) {<span class=\"hljs-comment\">// 如果本次更新的行不包含主键，那select for update的时候加上主键</span>\n                selectSQLJoin.add(getColumnNamesInSQL(tableMeta.getEscapePkNameList(getDbType())));\n            }\n            <span class=\"hljs-keyword\">for</span> (String columnName : updateColumns) {\n                selectSQLJoin.add(columnName);\n            }\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">for</span> (String columnName : tableMeta.getAllColumns().keySet()) {\n                selectSQLJoin.add(ColumnUtils.addEscape(columnName, getDbType()));\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> selectSQLJoin.toString();\n    }\n\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> TableRecords <span class=\"hljs-title\">buildTableRecords</span><span class=\"hljs-params\">(TableMeta tableMeta, String selectSQL, ArrayList&lt;List&lt;Object&gt;&gt; paramAppenderList)</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        ResultSet rs = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">try</span> (PreparedStatement ps = statementProxy.getConnection().prepareStatement(selectSQL)) { <span class=\"hljs-comment\">// 执行select for update，然后就拿到了本地锁</span>\n            <span class=\"hljs-keyword\">if</span> (CollectionUtils.isNotEmpty(paramAppenderList)) {\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>, ts = paramAppenderList.size(); i &lt; ts; i++) {\n                    List&lt;Object&gt; paramAppender = paramAppenderList.get(i);\n                    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>, ds = paramAppender.size(); j &lt; ds; j++) {\n                        ps.setObject(i * ds + j + <span class=\"hljs-number\">1</span>, paramAppender.get(j));\n                    }\n                }\n            }\n            rs = ps.executeQuery();\n            <span class=\"hljs-keyword\">return</span> TableRecords.buildRecords(tableMeta, rs);\n        } <span class=\"hljs-keyword\">finally</span> {\n            IOUtil.close(rs);\n        }\n    }\n}\n\n</code></pre>\n</li>\n<li>\n<p>执行业务sql</p>\n</li>\n<li>\n<p>查询后镜像</p>\n<pre><code class=\"language-java\">  <span class=\"hljs-keyword\">package</span> io.seata.rm.datasource.exec;\n\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UpdateExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Statement</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractDMLBaseExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span>&gt; </span>{\n      \n      <span class=\"hljs-meta\">@Override</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> TableRecords <span class=\"hljs-title\">afterImage</span><span class=\"hljs-params\">(TableRecords beforeImage)</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n          TableMeta tmeta = getTableMeta();\n          <span class=\"hljs-keyword\">if</span> (beforeImage == <span class=\"hljs-keyword\">null</span> || beforeImage.size() == <span class=\"hljs-number\">0</span>) {\n              <span class=\"hljs-keyword\">return</span> TableRecords.empty(getTableMeta());\n          }\n          String selectSQL = buildAfterImageSQL(tmeta, beforeImage);\n          <span class=\"hljs-comment\">//SELECT id, count FROM storage_tbl WHERE (id) in ( (?) )</span>\n          ResultSet rs = <span class=\"hljs-keyword\">null</span>;\n          <span class=\"hljs-keyword\">try</span> (PreparedStatement pst = statementProxy.getConnection().prepareStatement(selectSQL)) {\n              SqlGenerateUtils.setParamForPk(beforeImage.pkRows(), getTableMeta().getPrimaryKeyOnlyName(), pst);\n              rs = pst.executeQuery();\n              <span class=\"hljs-keyword\">return</span> TableRecords.buildRecords(tmeta, rs);\n          } <span class=\"hljs-keyword\">finally</span> {\n              IOUtil.close(rs);\n          }\n      }\n  }\n</code></pre>\n</li>\n<li>\n<p>准备undoLog</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseTransactionalExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Statement</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Executor</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">prepareUndoLog</span><span class=\"hljs-params\">(TableRecords beforeImage, TableRecords afterImage)</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        <span class=\"hljs-keyword\">if</span> (beforeImage.getRows().isEmpty() &amp;&amp; afterImage.getRows().isEmpty()) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (SQLType.UPDATE == sqlRecognizer.getSQLType()) {\n            <span class=\"hljs-keyword\">if</span> (beforeImage.getRows().size() != afterImage.getRows().size()) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ShouldNeverHappenException(<span class=\"hljs-string\">\"Before image size is not equaled to after image size, probably because you updated the primary keys.\"</span>);\n            }\n        }\n        ConnectionProxy connectionProxy = statementProxy.getConnectionProxy();\n\n        TableRecords lockKeyRecords = sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;\n        String lockKeys = buildLockKey(lockKeyRecords);\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">null</span> != lockKeys) {\n            connectionProxy.appendLockKey(lockKeys);\n\n            SQLUndoLog sqlUndoLog = buildUndoItem(beforeImage, afterImage);\n            connectionProxy.appendUndoLog(sqlUndoLog); <span class=\"hljs-comment\">// 把undoLog存到connectionProxy中，具体怎么回事上面有提过</span>\n        }\n    }\n}\n</code></pre>\n</li>\n</ul>\n</li>\n<li>\n<p>如果你的sql是select for update则会使用<code>SelectForUpdateExecutor</code>（Seata代理了select for update），代理后处理的逻辑是这样的：</p>\n<ul>\n<li>先执行 select for update（获取数据库本地锁）</li>\n<li>如果处于<code>@GlobalTransactional</code> or <code>@GlobalLock</code>，<strong>检查</strong>是否有全局锁</li>\n<li>如果有全局锁，则未开启本地事务下会rollback本地事务，再重新争抢本地锁和查询全局锁，直到全局锁释放</li>\n</ul>\n<pre><code class=\"language-java\">   <span class=\"hljs-keyword\">package</span> io.seata.rm.datasource.exec;\n\n   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SelectForUpdateExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Statement</span>&gt; <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">BaseTransactionalExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span>&gt; </span>{\n           <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">doExecute</span><span class=\"hljs-params\">(Object... args)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n                Connection conn = statementProxy.getConnection();\n                DatabaseMetaData dbmd = conn.getMetaData();\n                T rs;\n                Savepoint sp = <span class=\"hljs-keyword\">null</span>;\n                <span class=\"hljs-keyword\">boolean</span> originalAutoCommit = conn.getAutoCommit();\n                <span class=\"hljs-keyword\">try</span> {\n                    <span class=\"hljs-keyword\">if</span> (originalAutoCommit) {\n                        <span class=\"hljs-comment\">/*\n                         * In order to hold the local db lock during global lock checking\n                         * set auto commit value to false first if original auto commit was true\n                         */</span>\n                        conn.setAutoCommit(<span class=\"hljs-keyword\">false</span>);\n                    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (dbmd.supportsSavepoints()) {\n                        <span class=\"hljs-comment\">/*\n                         * In order to release the local db lock when global lock conflict\n                         * create a save point if original auto commit was false, then use the save point here to release db\n                         * lock during global lock checking if necessary\n                         */</span>\n                        sp = conn.setSavepoint();\n                    } <span class=\"hljs-keyword\">else</span> {\n                        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> SQLException(<span class=\"hljs-string\">\"not support savepoint. please check your db version\"</span>);\n                    }\n\n                    LockRetryController lockRetryController = <span class=\"hljs-keyword\">new</span> LockRetryController();\n                    ArrayList&lt;List&lt;Object&gt;&gt; paramAppenderList = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n                    String selectPKSQL = buildSelectSQL(paramAppenderList);\n                    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">true</span>) {\n                        <span class=\"hljs-keyword\">try</span> {\n                            <span class=\"hljs-comment\">// #870</span>\n                            <span class=\"hljs-comment\">// execute return Boolean</span>\n                            <span class=\"hljs-comment\">// executeQuery return ResultSet</span>\n                            rs = statementCallback.execute(statementProxy.getTargetStatement(), args); <span class=\"hljs-comment\">//执行 select for update（获取数据库本地锁）</span>\n\n                            <span class=\"hljs-comment\">// Try to get global lock of those rows selected</span>\n                            TableRecords selectPKRows = buildTableRecords(getTableMeta(), selectPKSQL, paramAppenderList);\n                            String lockKeys = buildLockKey(selectPKRows);\n                            <span class=\"hljs-keyword\">if</span> (StringUtils.isNullOrEmpty(lockKeys)) {\n                                <span class=\"hljs-keyword\">break</span>;\n                            }\n\n                            <span class=\"hljs-keyword\">if</span> (RootContext.inGlobalTransaction() || RootContext.requireGlobalLock()) {\n                                <span class=\"hljs-comment\">// Do the same thing under either @GlobalTransactional or @GlobalLock, </span>\n                                <span class=\"hljs-comment\">// that only check the global lock  here.</span>\n                                statementProxy.getConnectionProxy().checkLock(lockKeys);\n                            } <span class=\"hljs-keyword\">else</span> {\n                                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">\"Unknown situation!\"</span>);\n                            }\n                            <span class=\"hljs-keyword\">break</span>;\n                        } <span class=\"hljs-keyword\">catch</span> (LockConflictException lce) {\n                            <span class=\"hljs-keyword\">if</span> (sp != <span class=\"hljs-keyword\">null</span>) {\n                                conn.rollback(sp);\n                            } <span class=\"hljs-keyword\">else</span> {\n                                conn.rollback();<span class=\"hljs-comment\">// 回滚，释放本地锁</span>\n                            }\n                            <span class=\"hljs-comment\">// trigger retry</span>\n                            lockRetryController.sleep(lce);\n                        }\n                    }\n                } <span class=\"hljs-keyword\">finally</span> {\n                    <span class=\"hljs-keyword\">if</span> (sp != <span class=\"hljs-keyword\">null</span>) {\n                        <span class=\"hljs-keyword\">try</span> {\n                            <span class=\"hljs-keyword\">if</span> (!JdbcConstants.ORACLE.equalsIgnoreCase(getDbType())) {\n                                conn.releaseSavepoint(sp);\n                            }\n                        } <span class=\"hljs-keyword\">catch</span> (SQLException e) {\n                            LOGGER.error(<span class=\"hljs-string\">\"{} release save point error.\"</span>, getDbType(), e);\n                        }\n                    }\n                    <span class=\"hljs-keyword\">if</span> (originalAutoCommit) {\n                        conn.setAutoCommit(<span class=\"hljs-keyword\">true</span>);\n                    }\n                }\n                <span class=\"hljs-keyword\">return</span> rs;\n            }\n\n\n\n   }\n</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2><strong><code>ConnectionProxy.commit()</code>的处理逻辑</strong></h2>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConnectionProxy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractConnectionProxy</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> LockRetryPolicy LOCK_RETRY_POLICY = <span class=\"hljs-keyword\">new</span> LockRetryPolicy();\n\n    <span class=\"hljs-keyword\">private</span> ConnectionContext context = <span class=\"hljs-keyword\">new</span> ConnectionContext();\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">commit</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        <span class=\"hljs-keyword\">try</span> {\n            LOCK_RETRY_POLICY.execute(() -&gt; {\n                doCommit();\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n            });\n        } <span class=\"hljs-keyword\">catch</span> (SQLException e) {\n            <span class=\"hljs-keyword\">if</span> (targetConnection != <span class=\"hljs-keyword\">null</span> &amp;&amp; !getAutoCommit() &amp;&amp; !getContext().isAutoCommitChanged()) {\n                rollback();\n            }\n            <span class=\"hljs-keyword\">throw</span> e;\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> SQLException(e);\n        }\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doCommit</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        <span class=\"hljs-keyword\">if</span> (context.inGlobalTransaction()) {\n            processGlobalTransactionCommit();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (context.isGlobalLockRequire()) {\n            processLocalCommitWithGlobalLocks();\n        } <span class=\"hljs-keyword\">else</span> {\n            targetConnection.commit();\n        }\n    }\n\n}\n</code></pre>\n<blockquote>\n<p>也在这打下个疑问，后边解释。<br>\n<strong><code>ConnectionProxy</code>里的<code>ConnectionContext</code>是如何判断<code>inGlobalTransaction()</code> or <code>isGlobalLockRequire()</code>的呢？</strong></p>\n</blockquote>\n<ul>\n<li>\n<p>处于全局事务中（即，数据持久化方法带有<code>@GlobalTransactional</code>）</p>\n<ul>\n<li>注册分支事务，获取全局锁</li>\n<li>undoLog数据入库</li>\n<li>让数据库commit本次事务</li>\n</ul>\n<pre><code class=\"language-java\">    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConnectionProxy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractConnectionProxy</span> </span>{\n\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> LockRetryPolicy LOCK_RETRY_POLICY = <span class=\"hljs-keyword\">new</span> LockRetryPolicy();\n\n        <span class=\"hljs-keyword\">private</span> ConnectionContext context = <span class=\"hljs-keyword\">new</span> ConnectionContext();\n        \n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">processGlobalTransactionCommit</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n            <span class=\"hljs-keyword\">try</span> {\n                register(); <span class=\"hljs-comment\">// 注册分支，争全局锁</span>\n            } <span class=\"hljs-keyword\">catch</span> (TransactionException e) {\n                recognizeLockKeyConflictException(e, context.buildLockKeys());\n            }\n            <span class=\"hljs-keyword\">try</span> {\n                UndoLogManagerFactory.getUndoLogManager(<span class=\"hljs-keyword\">this</span>.getDbType()).flushUndoLogs(<span class=\"hljs-keyword\">this</span>); <span class=\"hljs-comment\">// undolog入库</span>\n                targetConnection.commit(); <span class=\"hljs-comment\">// 分支事务提交</span>\n            } <span class=\"hljs-keyword\">catch</span> (Throwable ex) {\n                LOGGER.error(<span class=\"hljs-string\">\"process connectionProxy commit error: {}\"</span>, ex.getMessage(), ex);\n                report(<span class=\"hljs-keyword\">false</span>);\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> SQLException(ex);\n            }\n            <span class=\"hljs-keyword\">if</span> (IS_REPORT_SUCCESS_ENABLE) {\n                report(<span class=\"hljs-keyword\">true</span>);\n            }\n            context.reset();\n        }\n\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">register</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> TransactionException </span>{\n            <span class=\"hljs-keyword\">if</span> (!context.hasUndoLog() || !context.hasLockKey()) {\n                <span class=\"hljs-keyword\">return</span>;\n            }\n            Long branchId = DefaultResourceManager.get().branchRegister(BranchType.AT, getDataSourceProxy().getResourceId(),\n                <span class=\"hljs-keyword\">null</span>, context.getXid(), <span class=\"hljs-keyword\">null</span>, context.buildLockKeys());\n            context.setBranchId(branchId);\n        }\n\n\n    }\n    ```\n\n</code></pre>\n</li>\n<li>\n<p>处于<code>@GlobalLock</code>中（即，数据持久化方法带有<code>@GlobalLock</code>）</p>\n<ul>\n<li>向tc查询是否有全局锁存在</li>\n<li>让数据库commit本次事务</li>\n</ul>\n<pre><code class=\"language-java\">   <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConnectionProxy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractConnectionProxy</span> </span>{\n\n       <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> LockRetryPolicy LOCK_RETRY_POLICY = <span class=\"hljs-keyword\">new</span> LockRetryPolicy();\n\n       <span class=\"hljs-keyword\">private</span> ConnectionContext context = <span class=\"hljs-keyword\">new</span> ConnectionContext();\n       \n       <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">processLocalCommitWithGlobalLocks</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n           checkLock(context.buildLockKeys());\n           <span class=\"hljs-keyword\">try</span> {\n               targetConnection.commit();\n           } <span class=\"hljs-keyword\">catch</span> (Throwable ex) {\n               <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> SQLException(ex);\n           }\n           context.reset();\n       }\n\n       <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">checkLock</span><span class=\"hljs-params\">(String lockKeys)</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n           <span class=\"hljs-keyword\">if</span> (StringUtils.isBlank(lockKeys)) {\n               <span class=\"hljs-keyword\">return</span>;\n           }\n           <span class=\"hljs-comment\">// Just check lock without requiring lock by now.</span>\n           <span class=\"hljs-keyword\">try</span> {\n               <span class=\"hljs-keyword\">boolean</span> lockable = DefaultResourceManager.get().lockQuery(BranchType.AT,\n                   getDataSourceProxy().getResourceId(), context.getXid(), lockKeys);\n               <span class=\"hljs-keyword\">if</span> (!lockable) {\n                   <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> LockConflictException();\n               }\n           } <span class=\"hljs-keyword\">catch</span> (TransactionException e) {\n               recognizeLockKeyConflictException(e, lockKeys);\n           }\n       }\n\n\n   }\n   ```\n</code></pre>\n</li>\n<li>\n<p>除了以上情况（<code>else</code>分支）</p>\n<ul>\n<li>让数据库commit本次事务</li>\n</ul>\n</li>\n</ul>\n<h2>介绍<code>RootContext</code></h2>\n<p>我们在上面留下了3个“扣儿”，现在到了结合<code>RootContext</code>源码来解答的时候。</p>\n<ol>\n<li>\n<p><strong><code>RootContext.getBranchType()</code>的返回值怎么会是AT？</strong><br>\n该方法的判断逻辑是：只要判断出<strong>当前处于全局事务中</strong>（即，只要有地方调用过<code>RootContext.bind(xid)</code>）, 就会返回默认<code>BranchType.AT</code></p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RootContext</span> </span>{\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String KEY_XID = <span class=\"hljs-string\">\"TX_XID\"</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> ContextCore CONTEXT_HOLDER = ContextCoreLoader.load();\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> BranchType DEFAULT_BRANCH_TYPE;\n\n    <span class=\"hljs-meta\">@Nullable</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> BranchType <span class=\"hljs-title\">getBranchType</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (inGlobalTransaction()) {\n            BranchType branchType = (BranchType) CONTEXT_HOLDER.get(KEY_BRANCH_TYPE);\n            <span class=\"hljs-keyword\">if</span> (branchType != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-keyword\">return</span> branchType;\n            }\n            <span class=\"hljs-comment\">//Returns the default branch type.</span>\n            <span class=\"hljs-keyword\">return</span> DEFAULT_BRANCH_TYPE != <span class=\"hljs-keyword\">null</span> ? DEFAULT_BRANCH_TYPE : BranchType.AT;\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">inGlobalTransaction</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> CONTEXT_HOLDER.get(KEY_XID) != <span class=\"hljs-keyword\">null</span>;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bind</span><span class=\"hljs-params\">(@Nonnull String xid)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (StringUtils.isBlank(xid)) {\n            <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(<span class=\"hljs-string\">\"xid is blank, switch to unbind operation!\"</span>);\n            }\n            unbind();\n        } <span class=\"hljs-keyword\">else</span> {\n            MDC.put(MDC_KEY_XID, xid);\n            <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(<span class=\"hljs-string\">\"bind {}\"</span>, xid);\n            }\n            CONTEXT_HOLDER.put(KEY_XID, xid);\n        }\n    }\n\n}\n</code></pre>\n</li>\n<li>\n<p><strong><code>RootContext.requireGlobalLock()</code>怎么判断当前是否需要全局锁？</strong><br>\n需要有地方调用<code>RootContext.bindGlobalLockFlag()</code></p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RootContext</span> </span>{\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> String KEY_GLOBAL_LOCK_FLAG = <span class=\"hljs-string\">\"TX_LOCK\"</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Boolean VALUE_GLOBAL_LOCK_FLAG = <span class=\"hljs-keyword\">true</span>;\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> ContextCore CONTEXT_HOLDER = ContextCoreLoader.load();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">requireGlobalLock</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> CONTEXT_HOLDER.get(KEY_GLOBAL_LOCK_FLAG) != <span class=\"hljs-keyword\">null</span>;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bindGlobalLockFlag</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(<span class=\"hljs-string\">\"Local Transaction Global Lock support enabled\"</span>);\n        }\n\n        <span class=\"hljs-comment\">//just put something not null</span>\n        CONTEXT_HOLDER.put(KEY_GLOBAL_LOCK_FLAG, VALUE_GLOBAL_LOCK_FLAG);\n    }\n\n}\n</code></pre>\n</li>\n<li>\n<p><strong><code>ConnectionProxy.commit()</code>会根据context的不同状态区分处理，那<code>ConnectionContext</code>是如何判断<code>inGlobalTransaction()</code> or <code>isGlobalLockRequire()</code>的呢？</strong></p>\n<pre><code class=\"language-java\"> <span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConnectionProxy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractConnectionProxy</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> ConnectionContext context = <span class=\"hljs-keyword\">new</span> ConnectionContext();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">doCommit</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        <span class=\"hljs-keyword\">if</span> (context.inGlobalTransaction()) {\n            processGlobalTransactionCommit();\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (context.isGlobalLockRequire()) {\n            processLocalCommitWithGlobalLocks();\n        } <span class=\"hljs-keyword\">else</span> {\n            targetConnection.commit();\n        }\n    }\n\n}\n</code></pre>\n<ul>\n<li>如何判断<code>inGlobalTransaction()</code>？（注意下，这里和上面提到的<code>RootContext</code>不是一个东西）<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConnectionContext</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> String xid;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setXid</span><span class=\"hljs-params\">(String xid)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.xid = xid;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">inGlobalTransaction</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> xid != <span class=\"hljs-keyword\">null</span>;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bind</span><span class=\"hljs-params\">(String xid)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (xid == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"xid should not be null\"</span>);\n        }\n        <span class=\"hljs-keyword\">if</span> (!inGlobalTransaction()) {\n            setXid(xid);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-keyword\">this</span>.xid.equals(xid)) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ShouldNeverHappenException();\n            }\n        }\n    }\n\n}\n</code></pre>\n哪里调用的<code>ConnectionContext.bind(xid)</code>?<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.rm.datasource.exec;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BaseTransactionalExecutor</span>&lt;<span class=\"hljs-title\">T</span>, <span class=\"hljs-title\">S</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Statement</span>&gt; <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Executor</span>&lt;<span class=\"hljs-title\">T</span>&gt; </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(Object... args)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        <span class=\"hljs-comment\">// 那么，这里的XID哪来的呢？往后看就知道，是来自开启全局事务的时候获得的，和@GlobalTransactional有关</span>\n        String xid = RootContext.getXID(); \n        <span class=\"hljs-keyword\">if</span> (xid != <span class=\"hljs-keyword\">null</span>) {\n            statementProxy.getConnectionProxy().bind(xid);\n        }\n\n        <span class=\"hljs-comment\">// 这里就是设置 isGlobalLockRequire的位置，和 @GlobalLock有关</span>\n        statementProxy.getConnectionProxy().setGlobalLockRequire(RootContext.requireGlobalLock());\n        <span class=\"hljs-keyword\">return</span> doExecute(args);\n    }\n\n}\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConnectionProxy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractConnectionProxy</span> </span>{\n\n   <span class=\"hljs-keyword\">private</span> ConnectionContext context = <span class=\"hljs-keyword\">new</span> ConnectionContext();\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bind</span><span class=\"hljs-params\">(String xid)</span> </span>{\n        context.bind(xid);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setGlobalLockRequire</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">boolean</span> isLock)</span> </span>{\n        context.setGlobalLockRequire(isLock);\n    }\n\n}\n</code></pre>\n</li>\n<li>如何判断<code>isGlobalLockRequire()</code>？<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ConnectionContext</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">boolean</span> isGlobalLockRequire;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isGlobalLockRequire</span><span class=\"hljs-params\">()</span> </span>{\n       <span class=\"hljs-keyword\">return</span> isGlobalLockRequire;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setGlobalLockRequire</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">boolean</span> isGlobalLockRequire)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.isGlobalLockRequire = isGlobalLockRequire;\n    }\n\n}\n</code></pre>\n</li>\n</ul>\n<p>在看过代码后，我们知道，只要有地方在<code>RootContext</code>中设置了xid，或<code>bindGlobalLockFlag()</code>,就会识别成不同的状态。\n那么哪儿调用的呢？答案就在下方的<code>GlobalTransactionalInterceptor</code>中。</p>\n</li>\n</ol>\n<h2><strong><code>GlobalTransactionalInterceptor</code>处理带有<code>@GlobalTransactional</code>或<code>@GlobalLock</code>的方法</strong></h2>\n<p>带有<code>@GlobalTransactional</code>和<code>@GlobalLock</code>的方法会被代理，交给<code>GlobalTransactionalInterceptor</code>处理</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GlobalTransactionalInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ConfigurationChangeListener</span>, <span class=\"hljs-title\">MethodInterceptor</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> MethodInvocation methodInvocation)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        Class&lt;?&gt; targetClass =\n            methodInvocation.getThis() != <span class=\"hljs-keyword\">null</span> ? AopUtils.getTargetClass(methodInvocation.getThis()) : <span class=\"hljs-keyword\">null</span>;\n        Method specificMethod = ClassUtils.getMostSpecificMethod(methodInvocation.getMethod(), targetClass);\n        <span class=\"hljs-keyword\">if</span> (specificMethod != <span class=\"hljs-keyword\">null</span> &amp;&amp; !specificMethod.getDeclaringClass().equals(Object.class)) {\n            <span class=\"hljs-keyword\">final</span> Method method = BridgeMethodResolver.findBridgedMethod(specificMethod);\n            <span class=\"hljs-keyword\">final</span> GlobalTransactional globalTransactionalAnnotation =\n                getAnnotation(method, targetClass, GlobalTransactional.class);\n            <span class=\"hljs-keyword\">final</span> GlobalLock globalLockAnnotation = getAnnotation(method, targetClass, GlobalLock.class);\n            <span class=\"hljs-keyword\">boolean</span> localDisable = disable || (degradeCheck &amp;&amp; degradeNum &gt;= degradeCheckAllowTimes);\n            <span class=\"hljs-keyword\">if</span> (!localDisable) {\n                <span class=\"hljs-keyword\">if</span> (globalTransactionalAnnotation != <span class=\"hljs-keyword\">null</span>) {\n                    <span class=\"hljs-keyword\">return</span> handleGlobalTransaction(methodInvocation, globalTransactionalAnnotation);<span class=\"hljs-comment\">// 处理 @GlobalTransactional</span>\n                } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (globalLockAnnotation != <span class=\"hljs-keyword\">null</span>) {\n                    <span class=\"hljs-keyword\">return</span> handleGlobalLock(methodInvocation, globalLockAnnotation); <span class=\"hljs-comment\">// 处理 @GlobalLock</span>\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> methodInvocation.proceed();\n    }\n\n}\n\n</code></pre>\n<h3><strong>先看处理<code>@GlobalTransactional</code></strong></h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GlobalTransactionalInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ConfigurationChangeListener</span>, <span class=\"hljs-title\">MethodInterceptor</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> TransactionalTemplate transactionalTemplate = <span class=\"hljs-keyword\">new</span> TransactionalTemplate();\n\n    <span class=\"hljs-function\">Object <span class=\"hljs-title\">handleGlobalTransaction</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> MethodInvocation methodInvocation,\n        <span class=\"hljs-keyword\">final</span> GlobalTransactional globalTrxAnno)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        \n        <span class=\"hljs-comment\">//...</span>\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">return</span> transactionalTemplate.execute(...);\n        } <span class=\"hljs-keyword\">catch</span> (TransactionalExecutor.ExecutionException e) {\n          <span class=\"hljs-comment\">// ...</span>\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-comment\">//...</span>\n        }\n    }\n}\n\n</code></pre>\n<p>来到了经典的seata事务模板方法，我们要关注开启事务的部分</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TransactionalTemplate</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(TransactionalExecutor business)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        <span class=\"hljs-comment\">// 1. Get transactionInfo</span>\n        <span class=\"hljs-comment\">//...</span>\n        <span class=\"hljs-comment\">// 1.1 Get current transaction, if not null, the tx role is 'GlobalTransactionRole.Participant'.</span>\n        GlobalTransaction tx = GlobalTransactionContext.getCurrent();\n\n        <span class=\"hljs-comment\">// 1.2 Handle the transaction propagation.</span>\n        <span class=\"hljs-comment\">// ...</span>\n\n            <span class=\"hljs-comment\">// 1.3 If null, create new transaction with role 'GlobalTransactionRole.Launcher'.</span>\n            <span class=\"hljs-keyword\">if</span> (tx == <span class=\"hljs-keyword\">null</span>) {\n                tx = GlobalTransactionContext.createNew();\n            }\n\n           <span class=\"hljs-comment\">//...</span>\n\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-comment\">// 2. If the tx role is 'GlobalTransactionRole.Launcher', send the request of beginTransaction to TC,</span>\n                <span class=\"hljs-comment\">//    else do nothing. Of course, the hooks will still be triggered.</span>\n                beginTransaction(txInfo, tx);\n\n                Object rs;\n                <span class=\"hljs-keyword\">try</span> {\n                    <span class=\"hljs-comment\">// Do Your Business</span>\n                    rs = business.execute();\n                } <span class=\"hljs-keyword\">catch</span> (Throwable ex) {\n                    <span class=\"hljs-comment\">// 3. The needed business exception to rollback.</span>\n                    completeTransactionAfterThrowing(txInfo, tx, ex);\n                    <span class=\"hljs-keyword\">throw</span> ex;\n                }\n\n                <span class=\"hljs-comment\">// 4. everything is fine, commit.</span>\n                commitTransaction(tx);\n\n                <span class=\"hljs-keyword\">return</span> rs;\n            } <span class=\"hljs-keyword\">finally</span> {\n                <span class=\"hljs-comment\">//5. clear</span>\n                <span class=\"hljs-comment\">//...</span>\n            }\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-comment\">// If the transaction is suspended, resume it.</span>\n           <span class=\"hljs-comment\">// ...</span>\n        }\n    }\n\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">beginTransaction</span><span class=\"hljs-params\">(TransactionInfo txInfo, GlobalTransaction tx)</span> <span class=\"hljs-keyword\">throws</span> TransactionalExecutor.ExecutionException </span>{\n        <span class=\"hljs-keyword\">try</span> {\n            triggerBeforeBegin();\n            tx.begin(txInfo.getTimeOut(), txInfo.getName());\n            triggerAfterBegin();\n        } <span class=\"hljs-keyword\">catch</span> (TransactionException txe) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> TransactionalExecutor.ExecutionException(tx, txe,\n                TransactionalExecutor.Code.BeginFailure);\n\n        }\n    }\n\n\n}\n\n</code></pre>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DefaultGlobalTransaction</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">GlobalTransaction</span> </span>{\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> timeout, String name)</span> <span class=\"hljs-keyword\">throws</span> TransactionException </span>{\n        <span class=\"hljs-keyword\">if</span> (role != GlobalTransactionRole.Launcher) {\n            assertXIDNotNull();\n            <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(<span class=\"hljs-string\">\"Ignore Begin(): just involved in global transaction [{}]\"</span>, xid);\n            }\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        assertXIDNull();\n        String currentXid = RootContext.getXID();\n        <span class=\"hljs-keyword\">if</span> (currentXid != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Global transaction already exists,\"</span> +\n                <span class=\"hljs-string\">\" can't begin a new global transaction, currentXid = \"</span> + currentXid);\n        }\n        xid = transactionManager.begin(<span class=\"hljs-keyword\">null</span>, <span class=\"hljs-keyword\">null</span>, name, timeout);\n        status = GlobalStatus.Begin;\n        RootContext.bind(xid); <span class=\"hljs-comment\">// 绑定xid</span>\n        <span class=\"hljs-keyword\">if</span> (LOGGER.isInfoEnabled()) {\n            LOGGER.info(<span class=\"hljs-string\">\"Begin new global transaction [{}]\"</span>, xid);\n        }\n    }\n}\n</code></pre>\n<p>看到了吗？<code>RootContext.bind(xid);</code></p>\n<h3><strong>接着看处理<code>@GlobalLock</code></strong></h3>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GlobalTransactionalInterceptor</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ConfigurationChangeListener</span>, <span class=\"hljs-title\">MethodInterceptor</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> GlobalLockTemplate globalLockTemplate = <span class=\"hljs-keyword\">new</span> GlobalLockTemplate();\n\n    <span class=\"hljs-function\">Object <span class=\"hljs-title\">handleGlobalLock</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> MethodInvocation methodInvocation,\n        <span class=\"hljs-keyword\">final</span> GlobalLock globalLockAnno)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n\n        <span class=\"hljs-keyword\">return</span> globalLockTemplate.execute(<span class=\"hljs-keyword\">new</span> GlobalLockExecutor() {...});\n    }\n}\n</code></pre>\n<p>也使用了模板方法来处理GlobalLock</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GlobalLockTemplate</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(GlobalLockExecutor executor)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        <span class=\"hljs-keyword\">boolean</span> alreadyInGlobalLock = RootContext.requireGlobalLock();\n        <span class=\"hljs-keyword\">if</span> (!alreadyInGlobalLock) {\n            RootContext.bindGlobalLockFlag();\n        }\n\n        <span class=\"hljs-comment\">// set my config to config holder so that it can be access in further execution</span>\n        <span class=\"hljs-comment\">// for example, LockRetryController can access it with config holder</span>\n        GlobalLockConfig myConfig = executor.getGlobalLockConfig();\n        GlobalLockConfig previousConfig = GlobalLockConfigHolder.setAndReturnPrevious(myConfig);\n\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">return</span> executor.execute();\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-comment\">// only unbind when this is the root caller.</span>\n            <span class=\"hljs-comment\">// otherwise, the outer caller would lose global lock flag</span>\n            <span class=\"hljs-keyword\">if</span> (!alreadyInGlobalLock) {\n                RootContext.unbindGlobalLockFlag();\n            }\n\n            <span class=\"hljs-comment\">// if previous config is not null, we need to set it back</span>\n            <span class=\"hljs-comment\">// so that the outer logic can still use their config</span>\n            <span class=\"hljs-keyword\">if</span> (previousConfig != <span class=\"hljs-keyword\">null</span>) {\n                GlobalLockConfigHolder.setAndReturnPrevious(previousConfig);\n            } <span class=\"hljs-keyword\">else</span> {\n                GlobalLockConfigHolder.remove();\n            }\n        }\n    }\n}\n</code></pre>\n<p>看到吗，一进模板方法就<code>RootContext.bindGlobalLockFlag();</code></p>\n",
  "link": "/zh-cn/docs/user/appendix/isolation.html",
  "meta": {
    "title": "Seata事务隔离",
    "keywords": "Seata事务隔离",
    "description": "Seata事务隔离"
  }
}