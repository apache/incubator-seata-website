{
  "filename": "microservice.md",
  "__html": "<h1>事务上下文</h1>\n<p>Seata 的事务上下文由 RootContext 来管理。</p>\n<p>应用开启一个全局事务后，RootContext 会自动绑定该事务的 XID，事务结束（提交或回滚完成），RootContext 会自动解绑 XID。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 绑定 XID</span>\nRootContext.bind(xid);\n\n<span class=\"hljs-comment\">// 解绑 XID</span>\nString xid = RootContext.unbind();\n</code></pre>\n<p>应用可以通过 RootContext 的 API 接口来获取当前运行时的全局事务 XID。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 获取 XID</span>\nString xid = RootContext.getXID();\n</code></pre>\n<p>应用是否运行在一个全局事务的上下文中，就是通过 RootContext 是否绑定 XID 来判定的。</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">inGlobalTransaction</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> CONTEXT_HOLDER.get(KEY_XID) != <span class=\"hljs-keyword\">null</span>;\n    }\n</code></pre>\n<h1>事务传播</h1>\n<p>Seata 全局事务的传播机制就是指事务上下文的传播，根本上，就是 XID 的应用运行时的传播方式。</p>\n<p><em>1. 服务内部的事务传播</em></p>\n<p>默认的，RootContext 的实现是基于 <em>ThreadLocal</em> 的，即 XID 绑定在当前线程上下文中。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ThreadLocalContextCore</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ContextCore</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; threadLocal = <span class=\"hljs-keyword\">new</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt;() {\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Map&lt;String, String&gt; <span class=\"hljs-title\">initialValue</span><span class=\"hljs-params\">()</span> </span>{\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> HashMap&lt;String, String&gt;();\n        }\n\n    };\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(String key, String value)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> threadLocal.get().put(key, value);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(String key)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> threadLocal.get().get(key);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">remove</span><span class=\"hljs-params\">(String key)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> threadLocal.get().remove(key);\n    }\n}\n</code></pre>\n<p>所以服务内部的 XID 传播通常是天然的通过同一个线程的调用链路串连起来的。默认不做任何处理，事务的上下文就是传播下去的。</p>\n<p>如果希望挂起事务上下文，则需要通过 RootContext 提供的 API 来实现：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 挂起（暂停）</span>\nString xid = RootContext.unbind();\n\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> 运行在全局事务外的业务逻辑</span>\n\n<span class=\"hljs-comment\">// 恢复全局事务上下文</span>\nRootContext.bind(xid);\n\n</code></pre>\n<p><em>2. 跨服务调用的事务传播</em></p>\n<p>通过上述基本原理，我们可以很容易理解：</p>\n<blockquote>\n<p>跨服务调用场景下的事务传播，本质上就是要把 XID 通过服务调用传递到服务提供方，并绑定到 RootContext 中去。</p>\n</blockquote>\n<p>只要能做到这点，理论上 Seata 可以支持任意的微服务框架。</p>\n<h1>对 Dubbo 支持的解读</h1>\n<p>下面，我们通过内置的对 Dubbo RPC 支持机制的解读，来说明 Seata 在实现对一个特定微服务框架支持的机制。</p>\n<p>对 Dubbo 的支持，我们利用了 Dubbo 框架的 <em>org.apache.dubbo.rpc.Filter</em> 机制。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n * The type Transaction propagation filter.\n */</span>\n<span class=\"hljs-meta\">@Activate</span>(group = { Constants.PROVIDER, Constants.CONSUMER }, order = <span class=\"hljs-number\">100</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TransactionPropagationFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Filter</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Logger LOGGER = LoggerFactory.getLogger(TransactionPropagationFilter.class);\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        String xid = RootContext.getXID(); <span class=\"hljs-comment\">// 获取当前事务 XID</span>\n        String rpcXid = RpcContext.getContext().getAttachment(RootContext.KEY_XID); <span class=\"hljs-comment\">// 获取 RPC 调用传递过来的 XID</span>\n        <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(<span class=\"hljs-string\">\"xid in RootContext[\"</span> + xid + <span class=\"hljs-string\">\"] xid in RpcContext[\"</span> + rpcXid + <span class=\"hljs-string\">\"]\"</span>);\n        }\n        <span class=\"hljs-keyword\">boolean</span> bind = <span class=\"hljs-keyword\">false</span>;\n        <span class=\"hljs-keyword\">if</span> (xid != <span class=\"hljs-keyword\">null</span>) { <span class=\"hljs-comment\">// Consumer：把 XID 置入 RPC 的 attachment 中</span>\n            RpcContext.getContext().setAttachment(RootContext.KEY_XID, xid);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> (rpcXid != <span class=\"hljs-keyword\">null</span>) { <span class=\"hljs-comment\">// Provider：把 RPC 调用传递来的 XID 绑定到当前运行时</span>\n                RootContext.bind(rpcXid);\n                bind = <span class=\"hljs-keyword\">true</span>;\n                <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(<span class=\"hljs-string\">\"bind[\"</span> + rpcXid + <span class=\"hljs-string\">\"] to RootContext\"</span>);\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">return</span> invoker.invoke(invocation); <span class=\"hljs-comment\">// 业务方法的调用</span>\n\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-keyword\">if</span> (bind) { <span class=\"hljs-comment\">// Provider：调用完成后，对 XID 的清理</span>\n                String unbindXid = RootContext.unbind();\n                <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(<span class=\"hljs-string\">\"unbind[\"</span> + unbindXid + <span class=\"hljs-string\">\"] from RootContext\"</span>);\n                }\n                <span class=\"hljs-keyword\">if</span> (!rpcXid.equalsIgnoreCase(unbindXid)) {\n                    LOGGER.warn(<span class=\"hljs-string\">\"xid in change during RPC from \"</span> + rpcXid + <span class=\"hljs-string\">\" to \"</span> + unbindXid);\n                    <span class=\"hljs-keyword\">if</span> (unbindXid != <span class=\"hljs-keyword\">null</span>) { <span class=\"hljs-comment\">// 调用过程有新的事务上下文开启，则不能清除</span>\n                        RootContext.bind(unbindXid);\n                        LOGGER.warn(<span class=\"hljs-string\">\"bind [\"</span> + unbindXid + <span class=\"hljs-string\">\"] back to RootContext\"</span>);\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>\n",
  "link": "/zh-cn/docs/user/microservice.html",
  "meta": {
    "title": "Seata 微服务框架支持",
    "keywords": "Seata",
    "description": "Seata 微服务框架支持。"
  }
}