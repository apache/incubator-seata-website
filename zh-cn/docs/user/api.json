{
  "filename": "api.md",
  "__html": "<h1>1. 概述</h1>\n<p>Seata API 分为两大类：High-Level API 和 Low-Level API ：</p>\n<ul>\n<li><strong>High-Level API</strong> ：用于事务边界定义、控制及事务状态查询。</li>\n<li><strong>Low-Level API</strong> ：用于控制事务上下文的传播。</li>\n</ul>\n<h1>2. High-Level API</h1>\n<h2>2.1 GlobalTransaction</h2>\n<p>全局事务：包括开启事务、提交、回滚、获取当前状态等方法。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GlobalTransaction</span> </span>{\n\n    <span class=\"hljs-comment\">/**\n     * 开启一个全局事务（使用默认的事务名和超时时间）\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 开启一个全局事务，并指定超时时间（使用默认的事务名）\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> timeout)</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 开启一个全局事务，并指定事务名和超时时间\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> timeout, String name)</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 全局提交\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">commit</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 全局回滚\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">rollback</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 获取事务的当前状态\n     */</span>\n    <span class=\"hljs-function\">GlobalStatus <span class=\"hljs-title\">getStatus</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n\n    <span class=\"hljs-comment\">/**\n     * 获取事务的 XID\n     */</span>\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">getXid</span><span class=\"hljs-params\">()</span></span>;\n\n}\n</code></pre>\n<h2>2.2 GlobalTransactionContext</h2>\n<p>GlobalTransaction 实例的获取需要通过 GlobalTransactionContext：</p>\n<pre><code class=\"language-java\">\n    <span class=\"hljs-comment\">/**\n     * 获取当前的全局事务实例，如果没有则创建一个新的实例。\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> GlobalTransaction <span class=\"hljs-title\">getCurrentOrCreate</span><span class=\"hljs-params\">()</span> </span>{\n        GlobalTransaction tx = getCurrent();\n        <span class=\"hljs-keyword\">if</span> (tx == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> createNew();\n        }\n        <span class=\"hljs-keyword\">return</span> tx;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 重新载入给定 XID 的全局事务实例，这个实例不允许执行开启事务的操作。\n     * 这个 API 通常用于失败的事务的后续集中处理。\n     * 比如：全局提交超时，后续集中处理通过重新载入该实例，通过实例方法获取事务当前状态，并根据状态判断是否需要重试全局提交操作。\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> GlobalTransaction <span class=\"hljs-title\">reload</span><span class=\"hljs-params\">(String xid)</span> <span class=\"hljs-keyword\">throws</span> TransactionException </span>{\n        GlobalTransaction tx = <span class=\"hljs-keyword\">new</span> DefaultGlobalTransaction(xid, GlobalStatus.UnKnown, GlobalTransactionRole.Launcher) {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> timeout, String name)</span> <span class=\"hljs-keyword\">throws</span> TransactionException </span>{\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalStateException(<span class=\"hljs-string\">\"Never BEGIN on a RELOADED GlobalTransaction. \"</span>);\n            }\n        };\n        <span class=\"hljs-keyword\">return</span> tx;\n    }\n</code></pre>\n<h2>2.3 TransactionalTemplate</h2>\n<p>事务化模板：通过上述 GlobalTransaction 和 GlobalTransactionContext API 把一个业务服务的调用包装成带有分布式事务支持的服务。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TransactionalTemplate</span> </span>{\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(TransactionalExecutor business)</span> <span class=\"hljs-keyword\">throws</span> TransactionalExecutor.ExecutionException </span>{\n\n        <span class=\"hljs-comment\">// 1. 获取当前全局事务实例或创建新的实例</span>\n        GlobalTransaction tx = GlobalTransactionContext.getCurrentOrCreate();\n\n        <span class=\"hljs-comment\">// 2. 开启全局事务</span>\n        <span class=\"hljs-keyword\">try</span> {\n            tx.begin(business.timeout(), business.name());\n\n        } <span class=\"hljs-keyword\">catch</span> (TransactionException txe) {\n            <span class=\"hljs-comment\">// 2.1 开启失败</span>\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> TransactionalExecutor.ExecutionException(tx, txe,\n                TransactionalExecutor.Code.BeginFailure);\n\n        }\n\n        Object rs = <span class=\"hljs-keyword\">null</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 3. 调用业务服务</span>\n            rs = business.execute();\n\n        } <span class=\"hljs-keyword\">catch</span> (Throwable ex) {\n\n            <span class=\"hljs-comment\">// 业务调用本身的异常</span>\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-comment\">// 全局回滚</span>\n                tx.rollback();\n\n                <span class=\"hljs-comment\">// 3.1 全局回滚成功：抛出原始业务异常</span>\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> TransactionalExecutor.ExecutionException(tx, TransactionalExecutor.Code.RollbackDone, ex);\n\n            } <span class=\"hljs-keyword\">catch</span> (TransactionException txe) {\n                <span class=\"hljs-comment\">// 3.2 全局回滚失败：</span>\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> TransactionalExecutor.ExecutionException(tx, txe,\n                    TransactionalExecutor.Code.RollbackFailure, ex);\n\n            }\n\n        }\n\n        <span class=\"hljs-comment\">// 4. 全局提交</span>\n        <span class=\"hljs-keyword\">try</span> {\n            tx.commit();\n\n        } <span class=\"hljs-keyword\">catch</span> (TransactionException txe) {\n            <span class=\"hljs-comment\">// 4.1 全局提交失败：</span>\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> TransactionalExecutor.ExecutionException(tx, txe,\n                TransactionalExecutor.Code.CommitFailure);\n\n        }\n        <span class=\"hljs-keyword\">return</span> rs;\n    }\n\n}\n</code></pre>\n<p>模板方法执行的异常：ExecutionException</p>\n<pre><code>    class ExecutionException extends Exception {\n\n        // 发生异常的事务实例\n        private GlobalTransaction transaction;\n\n        // 异常编码：\n        // BeginFailure（开启事务失败）\n        // CommitFailure（全局提交失败）\n        // RollbackFailure（全局回滚失败）\n        // RollbackDone（全局回滚成功）\n        private Code code;\n\n        // 触发回滚的业务原始异常\n        private Throwable originalException;\n</code></pre>\n<p>外层调用逻辑 try-catch 这个异常，根据异常编码进行处理：</p>\n<ul>\n<li><strong>BeginFailure</strong> （开启事务失败）：getCause() 得到开启事务失败的框架异常，getOriginalException() 为空。</li>\n<li><strong>CommitFailure</strong> （全局提交失败）：getCause() 得到全局提交失败的框架异常，getOriginalException() 为空。</li>\n<li><strong>RollbackFailure</strong> （全局回滚失败）：getCause() 得到全局回滚失败的框架异常，getOriginalException() 业务应用的原始异常。</li>\n<li><strong>RollbackDone</strong> （全局回滚成功）：getCause() 为空，getOriginalException() 业务应用的原始异常。</li>\n</ul>\n<h1>3. Low-Level API</h1>\n<h2>3.1 RootContext</h2>\n<p>事务的根上下文：负责在应用的运行时，维护 XID 。</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-comment\">/**\n     * 得到当前应用运行时的全局事务 XID\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">getXID</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> CONTEXT_HOLDER.get(KEY_XID);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 将全局事务 XID 绑定到当前应用的运行时中\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">bind</span><span class=\"hljs-params\">(String xid)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(<span class=\"hljs-string\">\"bind \"</span> + xid);\n        }\n        CONTEXT_HOLDER.put(KEY_XID, xid);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 将全局事务 XID 从当前应用的运行时中解除绑定，同时将 XID 返回\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">unbind</span><span class=\"hljs-params\">()</span> </span>{\n        String xid = CONTEXT_HOLDER.remove(KEY_XID);\n        <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(<span class=\"hljs-string\">\"unbind \"</span> + xid);\n        }\n        <span class=\"hljs-keyword\">return</span> xid;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 判断当前应用的运行时是否处于全局事务的上下文中\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">inGlobalTransaction</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> CONTEXT_HOLDER.get(KEY_XID) != <span class=\"hljs-keyword\">null</span>;\n    }\n</code></pre>\n<p>High-Level API 的实现都是基于 RootContext 中维护的 XID 来做的。</p>\n<p>应用的当前运行的操作是否在一个全局事务的上下文中，就是看 RootContext 中是否有 XID。</p>\n<p>RootContext 的默认实现是基于 ThreadLocal 的，即 XID 保存在当前线程上下文中。</p>\n<p>Low-Level API 的两个典型的应用场景：</p>\n<h3>1. 远程调用事务上下文的传播</h3>\n<p>远程调用前获取当前 XID：</p>\n<pre><code class=\"language-java\">String xid = RootContext.getXID();\n</code></pre>\n<p>远程调用过程把 XID 也传递到服务提供方，在执行服务提供方的业务逻辑前，把 XID 绑定到当前应用的运行时：</p>\n<pre><code class=\"language-java\">RootContext.bind(rpcXid);\n</code></pre>\n<h3>2. 事务的暂停和恢复</h3>\n<p>在一个全局事务中，如果需要某些业务逻辑不在全局事务的管辖范围内，则在调用前，把 XID 解绑：</p>\n<pre><code class=\"language-java\">String unbindXid = RootContext.unbind();\n</code></pre>\n<p>待相关业务逻辑执行完成，再把 XID 绑定回去，即可实现全局事务的恢复：</p>\n<pre><code class=\"language-java\">RootContext.bind(unbindXid);\n</code></pre>\n",
  "link": "/zh-cn/docs/user/api.html",
  "meta": {
    "title": "Seata api",
    "keywords": "Seata",
    "description": "Seata API 分为两大类：High-Level API 和 Low-Level API。"
  }
}