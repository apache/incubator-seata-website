{
  "filename": "xa-mode.md",
  "__html": "<h1>Seata XA 模式</h1>\n<h2>前提</h2>\n<ul>\n<li>支持XA 事务的数据库。</li>\n<li>Java 应用，通过 JDBC 访问数据库。</li>\n</ul>\n<h2>整体机制</h2>\n<p>在 Seata 定义的分布式事务框架内，利用事务资源（数据库、消息服务等）对 XA 协议的支持，以 XA 协议的机制来管理分支事务的一种 事务模式。</p>\n<img src=\"https://img.alicdn.com/tfs/TB1hSpccIVl614jSZKPXXaGjpXa-1330-924.png\" style=\"zoom:50%;\" />\n<ul>\n<li>\n<p>执行阶段：</p>\n</li>\n<li>\n<ul>\n<li>可回滚：业务 SQL 操作放在 XA 分支中进行，由资源对 XA 协议的支持来保证 <em>可回滚</em></li>\n<li>持久化：XA 分支完成后，执行 XA prepare，同样，由资源对 XA 协议的支持来保证 <em>持久化</em>（即，之后任何意外都不会造成无法回滚的情况）</li>\n</ul>\n</li>\n<li>\n<p>完成阶段：</p>\n</li>\n<li>\n<ul>\n<li>分支提交：执行 XA 分支的 commit</li>\n<li>分支回滚：执行 XA 分支的 rollback</li>\n</ul>\n</li>\n</ul>\n<h1>工作机制</h1>\n<h4>1. 整体运行机制</h4>\n<p>XA 模式 运行在 Seata 定义的事务框架内：</p>\n<img src=\"https://img.alicdn.com/tfs/TB1uM2OaSslXu8jSZFuXXXg7FXa-1330-958.png\" alt=\"xa-fw\" style=\"zoom:50%;\" />\n<ul>\n<li>\n<p>执行阶段（E xecute）：</p>\n</li>\n<li>\n<ul>\n<li>XA start/XA end/XA prepare + SQL + 注册分支</li>\n</ul>\n</li>\n<li>\n<p>完成阶段（F inish）：</p>\n</li>\n<li>\n<ul>\n<li>XA commit/XA rollback</li>\n</ul>\n</li>\n</ul>\n<h4>2. 数据源代理</h4>\n<p>XA 模式需要 XAConnection。</p>\n<p>获取 XAConnection 两种方式：</p>\n<ul>\n<li>方式一：要求开发者配置 XADataSource</li>\n<li>方式二：根据开发者的普通 DataSource 来创建</li>\n</ul>\n<p>第一种方式，给开发者增加了认知负担，需要为 XA 模式专门去学习和使用 XA 数据源，与 透明化 XA 编程模型的设计目标相违背。</p>\n<p>第二种方式，对开发者比较友好，和 AT 模式使用一样，开发者完全不必关心 XA 层面的任何问题，保持本地编程模型即可。</p>\n<p>我们优先设计实现第二种方式：数据源代理根据普通数据源中获取的普通 JDBC 连接创建出相应的 XAConnection。</p>\n<p>类比 AT 模式的数据源代理机制，如下：</p>\n<img src=\"https://img.alicdn.com/tfs/TB11_LJcggP7K4jSZFqXXamhVXa-1564-894.png\" alt=\"ds1\" style=\"zoom:50%;\" />\n<p>但是，第二种方法有局限：无法保证兼容的正确性。</p>\n<p>实际上，这种方法是在做数据库驱动程序要做的事情。不同的厂商、不同版本的数据库驱动实现机制是厂商私有的，我们只能保证在充分测试过的驱动程序上是正确的，开发者使用的驱动程序版本差异很可能造成机制的失效。</p>\n<p>这点在 Oracle 上体现非常明显。参见 Druid issue：<a href=\"https://github.com/alibaba/druid/issues/3707\">https://github.com/alibaba/druid/issues/3707</a></p>\n<p>综合考虑，XA 模式的数据源代理设计需要同时支持第一种方式：基于 XA 数据源进行代理。</p>\n<p>类比 AT 模式的数据源代理机制，如下：</p>\n<img src=\"https://img.alicdn.com/tfs/TB1qJ57XZieb18jSZFvXXaI3FXa-1564-894.png\" alt=\"ds2\" style=\"zoom:50%;\" />\n<h4>3. 分支注册</h4>\n<p>XA start 需要 Xid 参数。</p>\n<p>这个 Xid 需要和 Seata 全局事务的 XID 和 BranchId 关联起来，以便由 TC 驱动 XA 分支的提交或回滚。</p>\n<p>目前 Seata 的 BranchId 是在分支注册过程，由 TC 统一生成的，所以 XA 模式分支注册的时机需要在 XA start 之前。</p>\n<p>将来一个可能的优化方向：</p>\n<p>把分支注册尽量延后。类似 AT 模式在本地事务提交之前才注册分支，避免分支执行失败情况下，没有意义的分支注册。</p>\n<p>这个优化方向需要 BranchId 生成机制的变化来配合。BranchId 不通过分支注册过程生成，而是生成后再带着 BranchId 去注册分支。</p>\n<h2>XA 模式的使用</h2>\n<p>从编程模型上，XA 模式与 AT 模式保持完全一致。</p>\n<p>可以参考 Seata 官网的样例：<a href=\"https://github.com/seata/seata-samples/tree/master/seata-xa\">seata-xa</a></p>\n<p>样例场景是 Seata 经典的，涉及库存、订单、账户 3 个微服务的商品订购业务。</p>\n<p>在样例中，上层编程模型与 AT 模式完全相同。只需要修改数据源代理，即可实现 XA 模式与 AT 模式之间的切换。</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-meta\">@Bean</span>(<span class=\"hljs-string\">\"dataSource\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> DataSource <span class=\"hljs-title\">dataSource</span><span class=\"hljs-params\">(DruidDataSource druidDataSource)</span> </span>{\n        <span class=\"hljs-comment\">// DataSourceProxy for AT mode</span>\n        <span class=\"hljs-comment\">// return new DataSourceProxy(druidDataSource);</span>\n\n        <span class=\"hljs-comment\">// DataSourceProxyXA for XA mode</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> DataSourceProxyXA(druidDataSource);\n    }\n</code></pre>\n",
  "link": "/zh-cn/docs/dev/mode/xa-mode.html",
  "meta": {
    "title": "Seata XA 模式",
    "keywords": "Seata",
    "description": "Seata XA 模式。"
  }
}