{
  "filename": "what-is-seata.md",
  "__html": "<h1>Seata 是什么?</h1>\n<p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>\n<h1>AT 模式</h1>\n<h2>前提</h2>\n<ul>\n<li>基于支持本地 ACID 事务的关系型数据库。</li>\n<li>Java 应用，通过 JDBC 访问数据库。</li>\n</ul>\n<h2>整体机制</h2>\n<p>两阶段提交协议的演变：</p>\n<ul>\n<li>\n<p>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</p>\n</li>\n<li>\n<p>二阶段：</p>\n<ul>\n<li>提交异步化，非常快速地完成。</li>\n<li>回滚通过一阶段的回滚日志进行反向补偿。</li>\n</ul>\n</li>\n</ul>\n<h1>写隔离</h1>\n<ul>\n<li>一阶段本地事务提交前，需要确保先拿到 <strong>全局锁</strong> 。</li>\n<li>拿不到 <strong>全局锁</strong> ，不能提交本地事务。</li>\n<li>拿 <strong>全局锁</strong> 的尝试被限制在一定范围内，超出范围将放弃，并回滚本地事务，释放本地锁。</li>\n</ul>\n<p>以一个示例来说明：</p>\n<p>两个全局事务 tx1 和 tx2，分别对 a 表的 m 字段进行更新操作，m 的初始值 1000。</p>\n<p>tx1 先开始，开启本地事务，拿到本地锁，更新操作 m = 1000 - 100 = 900。本地事务提交前，先拿到该记录的 <strong>全局锁</strong> ，本地提交释放本地锁。\ntx2 后开始，开启本地事务，拿到本地锁，更新操作 m = 900 - 100 = 800。本地事务提交前，尝试拿该记录的 <strong>全局锁</strong> ，tx1 全局提交前，该记录的全局锁被 tx1 持有，tx2 需要重试等待 <strong>全局锁</strong> 。</p>\n<p><img src=\"/img/overview-1.png\" alt=\"Write-Isolation: Commit\"></p>\n<p>tx1 二阶段全局提交，释放 <strong>全局锁</strong> 。tx2 拿到 <strong>全局锁</strong> 提交本地事务。</p>\n<p><img src=\"/img/overview-2.png\" alt=\"Write-Isolation: Rollback\"></p>\n<p>如果 tx1 的二阶段全局回滚，则 tx1 需要重新获取该数据的本地锁，进行反向补偿的更新操作，实现分支的回滚。</p>\n<p>此时，如果 tx2 仍在等待该数据的 <strong>全局锁</strong>，同时持有本地锁，则 tx1 的分支回滚会失败。分支的回滚会一直重试，直到 tx2 的 <strong>全局锁</strong> 等锁超时，放弃 <strong>全局锁</strong> 并回滚本地事务释放本地锁，tx1 的分支回滚最终成功。</p>\n<p>因为整个过程 <strong>全局锁</strong> 在 tx1 结束前一直是被 tx1 持有的，所以不会发生 <strong>脏写</strong> 的问题。</p>\n<h1>读隔离</h1>\n<p>在数据库本地事务隔离级别 <strong>读已提交（Read Committed）</strong> 或以上的基础上，Seata（AT 模式）的默认全局隔离级别是 <strong>读未提交（Read Uncommitted）</strong> 。</p>\n<p>如果应用在特定场景下，必需要求全局的 <strong>读已提交</strong> ，目前 Seata 的方式是通过 SELECT FOR UPDATE 语句的代理。</p>\n<p><img src=\"/img/overview-3.png\" alt=\"Read Isolation: SELECT FOR UPDATE\"></p>\n<p>SELECT FOR UPDATE 语句的执行会申请 <strong>全局锁</strong> ，如果 <strong>全局锁</strong> 被其他事务持有，则释放本地锁（回滚 SELECT FOR UPDATE 语句的本地执行）并重试。这个过程中，查询是被 block 住的，直到 <strong>全局锁</strong> 拿到，即读取的相关数据是 <strong>已提交</strong> 的，才返回。</p>\n<p>出于总体性能上的考虑，Seata 目前的方案并没有对所有 SELECT 语句都进行代理，仅针对 FOR UPDATE 的 SELECT 语句。</p>\n<h1>工作机制</h1>\n<p>以一个示例来说明整个 AT 分支的工作过程。</p>\n<p>业务表：<code>product</code></p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n<th>Key</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>id</td>\n<td>bigint(20)</td>\n<td>PRI</td>\n</tr>\n<tr>\n<td>name</td>\n<td>varchar(100)</td>\n<td></td>\n</tr>\n<tr>\n<td>since</td>\n<td>varchar(100)</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>AT 分支事务的业务逻辑：</p>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">update</span> product <span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">name</span> = <span class=\"hljs-string\">'GTS'</span> <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">name</span> = <span class=\"hljs-string\">'TXC'</span>;\n</code></pre>\n<h2>一阶段</h2>\n<p>过程：</p>\n<ol>\n<li>解析 SQL：得到 SQL 的类型（UPDATE），表（product），条件（where name = 'TXC'）等相关的信息。</li>\n<li>查询前镜像：根据解析得到的条件信息，生成查询语句，定位数据。</li>\n</ol>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, since <span class=\"hljs-keyword\">from</span> product <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">name</span> = <span class=\"hljs-string\">'TXC'</span>;\n</code></pre>\n<p>得到前镜像：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>since</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>TXC</td>\n<td>2014</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>执行业务 SQL：更新这条记录的 name 为 'GTS'。</li>\n<li>查询后镜像：根据前镜像的结果，通过 <strong>主键</strong> 定位数据。</li>\n</ol>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">id</span>, <span class=\"hljs-keyword\">name</span>, since <span class=\"hljs-keyword\">from</span> product <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">id</span> = <span class=\"hljs-number\">1</span><span class=\"hljs-string\">`;\n</span></code></pre>\n<p>得到后镜像：</p>\n<table>\n<thead>\n<tr>\n<th>id</th>\n<th>name</th>\n<th>since</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>GTS</td>\n<td>2014</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"5\">\n<li>插入回滚日志：把前后镜像数据以及业务 SQL 相关的信息组成一条回滚日志记录，插入到 <code>UNDO_LOG</code> 表中。</li>\n</ol>\n<pre><code class=\"language-json\">{\n\t<span class=\"hljs-attr\">\"branchId\"</span>: <span class=\"hljs-number\">641789253</span>,\n\t<span class=\"hljs-attr\">\"undoItems\"</span>: [{\n\t\t<span class=\"hljs-attr\">\"afterImage\"</span>: {\n\t\t\t<span class=\"hljs-attr\">\"rows\"</span>: [{\n\t\t\t\t<span class=\"hljs-attr\">\"fields\"</span>: [{\n\t\t\t\t\t<span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"id\"</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-number\">4</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-number\">1</span>\n\t\t\t\t}, {\n\t\t\t\t\t<span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"name\"</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-number\">12</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-string\">\"GTS\"</span>\n\t\t\t\t}, {\n\t\t\t\t\t<span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"since\"</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-number\">12</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-string\">\"2014\"</span>\n\t\t\t\t}]\n\t\t\t}],\n\t\t\t<span class=\"hljs-attr\">\"tableName\"</span>: <span class=\"hljs-string\">\"product\"</span>\n\t\t},\n\t\t<span class=\"hljs-attr\">\"beforeImage\"</span>: {\n\t\t\t<span class=\"hljs-attr\">\"rows\"</span>: [{\n\t\t\t\t<span class=\"hljs-attr\">\"fields\"</span>: [{\n\t\t\t\t\t<span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"id\"</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-number\">4</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-number\">1</span>\n\t\t\t\t}, {\n\t\t\t\t\t<span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"name\"</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-number\">12</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-string\">\"TXC\"</span>\n\t\t\t\t}, {\n\t\t\t\t\t<span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"since\"</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"type\"</span>: <span class=\"hljs-number\">12</span>,\n\t\t\t\t\t<span class=\"hljs-attr\">\"value\"</span>: <span class=\"hljs-string\">\"2014\"</span>\n\t\t\t\t}]\n\t\t\t}],\n\t\t\t<span class=\"hljs-attr\">\"tableName\"</span>: <span class=\"hljs-string\">\"product\"</span>\n\t\t},\n\t\t<span class=\"hljs-attr\">\"sqlType\"</span>: <span class=\"hljs-string\">\"UPDATE\"</span>\n\t}],\n\t<span class=\"hljs-attr\">\"xid\"</span>: <span class=\"hljs-string\">\"xid:xxx\"</span>\n}\n</code></pre>\n<ol start=\"6\">\n<li>提交前，向 TC 注册分支：申请 <code>product</code> 表中，主键值等于 1 的记录的 <strong>全局锁</strong> 。</li>\n<li>本地事务提交：业务数据的更新和前面步骤中生成的 UNDO LOG 一并提交。</li>\n<li>将本地事务提交的结果上报给 TC。</li>\n</ol>\n<h2>二阶段-回滚</h2>\n<ol>\n<li>收到 TC 的分支回滚请求，开启一个本地事务，执行如下操作。</li>\n<li>通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。</li>\n<li>数据校验：拿 UNDO LOG 中的后镜与当前数据进行比较，如果有不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理，详细的说明在另外的文档中介绍。</li>\n<li>根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句：</li>\n</ol>\n<pre><code class=\"language-sql\"><span class=\"hljs-keyword\">update</span> product <span class=\"hljs-keyword\">set</span> <span class=\"hljs-keyword\">name</span> = <span class=\"hljs-string\">'TXC'</span> <span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">id</span> = <span class=\"hljs-number\">1</span>;\n</code></pre>\n<ol start=\"5\">\n<li>提交本地事务。并把本地事务的执行结果（即分支事务回滚的结果）上报给 TC。</li>\n</ol>\n<h2>二阶段-提交</h2>\n<ol>\n<li>收到 TC 的分支提交请求，把请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。</li>\n<li>异步任务阶段的分支提交请求将异步和批量地删除相应 UNDO LOG 记录。</li>\n</ol>\n<h1>附录</h1>\n<h2>回滚日志表</h2>\n<p>UNDO_LOG Table：不同数据库在类型上会略有差别。</p>\n<p>以 MySQL 为例：</p>\n<table>\n<thead>\n<tr>\n<th>Field</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>branch_id</td>\n<td>bigint     PK</td>\n</tr>\n<tr>\n<td>xid</td>\n<td>varchar(100)</td>\n</tr>\n<tr>\n<td>context</td>\n<td>varchar(128)</td>\n</tr>\n<tr>\n<td>rollback_info</td>\n<td>longblob</td>\n</tr>\n<tr>\n<td>log_status</td>\n<td>tinyint</td>\n</tr>\n<tr>\n<td>log_created</td>\n<td>datetime</td>\n</tr>\n<tr>\n<td>log_modified</td>\n<td>datetime</td>\n</tr>\n</tbody>\n</table>\n<pre><code class=\"language-sql\"><span class=\"hljs-comment\">-- 注意此处0.7.0+ 增加字段 context</span>\n<span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> <span class=\"hljs-string\">`undo_log`</span> (\n  <span class=\"hljs-string\">`id`</span> <span class=\"hljs-built_in\">bigint</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span> AUTO_INCREMENT,\n  <span class=\"hljs-string\">`branch_id`</span> <span class=\"hljs-built_in\">bigint</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span>,\n  <span class=\"hljs-string\">`xid`</span> <span class=\"hljs-built_in\">varchar</span>(<span class=\"hljs-number\">100</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span>,\n  <span class=\"hljs-string\">`context`</span> <span class=\"hljs-built_in\">varchar</span>(<span class=\"hljs-number\">128</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span>,\n  <span class=\"hljs-string\">`rollback_info`</span> longblob <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span>,\n  <span class=\"hljs-string\">`log_status`</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span>,\n  <span class=\"hljs-string\">`log_created`</span> datetime <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span>,\n  <span class=\"hljs-string\">`log_modified`</span> datetime <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-literal\">NULL</span>,\n  PRIMARY <span class=\"hljs-keyword\">KEY</span> (<span class=\"hljs-string\">`id`</span>),\n  <span class=\"hljs-keyword\">UNIQUE</span> <span class=\"hljs-keyword\">KEY</span> <span class=\"hljs-string\">`ux_undo_log`</span> (<span class=\"hljs-string\">`xid`</span>,<span class=\"hljs-string\">`branch_id`</span>)\n) <span class=\"hljs-keyword\">ENGINE</span>=<span class=\"hljs-keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">CHARSET</span>=utf8;\n</code></pre>\n<h1>TCC 模式</h1>\n<p>回顾总览中的描述：一个分布式的全局事务，整体是 <strong>两阶段提交</strong> 的模型。全局事务是由若干分支事务组成的，分支事务要满足 <strong>两阶段提交</strong> 的模型要求，即需要每个分支事务都具备自己的：</p>\n<ul>\n<li>一阶段 prepare 行为</li>\n<li>二阶段 commit 或 rollback 行为</li>\n</ul>\n<p><img src=\"/img/overview-4.png\" alt=\"Overview of a global transaction\"></p>\n<p>根据两阶段行为模式的不同，我们将分支事务划分为 <strong>Automatic (Branch) Transaction Mode</strong> 和 <strong>Manual (Branch) Transaction Mode</strong>.</p>\n<p>AT 模式（<a href=\"\">参考链接 TBD</a>）基于 <strong>支持本地 ACID 事务</strong> 的 <strong>关系型数据库</strong>：</p>\n<ul>\n<li>一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录。</li>\n<li>二阶段 commit 行为：马上成功结束，<strong>自动</strong> 异步批量清理回滚日志。</li>\n<li>二阶段 rollback 行为：通过回滚日志，<strong>自动</strong> 生成补偿操作，完成数据回滚。</li>\n</ul>\n<p>相应的，TCC 模式，不依赖于底层数据资源的事务支持：</p>\n<ul>\n<li>一阶段 prepare 行为：调用 <strong>自定义</strong> 的 prepare 逻辑。</li>\n<li>二阶段 commit 行为：调用 <strong>自定义</strong> 的 commit 逻辑。</li>\n<li>二阶段 rollback 行为：调用 <strong>自定义</strong> 的 rollback 逻辑。</li>\n</ul>\n<p>所谓 TCC 模式，是指支持把 <strong>自定义</strong> 的分支事务纳入到全局事务的管理中。</p>\n<h1>Saga 模式</h1>\n<p>Saga模式是SEATA提供的长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者，一阶段正向服务和二阶段补偿服务都由业务开发实现。</p>\n<p><img src=\"/img/saga/sagas.png\" alt=\"Saga模式示意图\"></p>\n<p>理论基础：Hector &amp; Kenneth 发表论⽂ Sagas （1987）</p>\n<h2>适用场景：</h2>\n<ul>\n<li>业务流程长、业务流程多</li>\n<li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li>\n</ul>\n<h2>优势：</h2>\n<ul>\n<li>一阶段提交本地事务，无锁，高性能</li>\n<li>事件驱动架构，参与者可异步执行，高吞吐</li>\n<li>补偿服务易于实现</li>\n</ul>\n<h2>缺点：</h2>\n<ul>\n<li>不保证隔离性（应对方案见<a href=\"../user/saga.html\">用户文档</a>）</li>\n</ul>\n",
  "link": "/zh-cn/docs/overview/what-is-seata.html",
  "meta": {
    "title": "Seata 是什么",
    "keywords": "Seata",
    "description": "Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。"
  }
}