<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="Seata, undo_log, compress" />
	<meta name="description" content="seata-feature-undo-log-compress" />
	<!-- 网页标签标题 -->
	<title>Seata新特性支持 -- undo_log压缩</title>
  <link rel="shortcut icon" href="/img/seata_logo_small.jpeg"/>
	<link rel="stylesheet" href="/build/blogDetail.css" />
</head>
<body>
	<div id="root"><div class="blog-detail-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="//img.alicdn.com/tfs/TB1gqL1w4D1gK0jSZFyXXciOVXa-1497-401.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="https://img.alicdn.com/tfs/TB14eEmw7P2gK0jSZPxXXacQpXa-38-32.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/overview/what-is-seata.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developers/developers_dev.html" target="_self">开发者</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li><li class="menu-item menu-item-normal"><a href="https://github.com/seata/seata/issues/3741" target="_self">暑期2021</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html" target="_self">社区</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/download.html" target="_self">下载</a></li></ul></div></div></header><section class="blog-content markdown-body"><h1>Seata新特性支持 -- undo_log压缩</h1>
<h3>现状 &amp; 痛点</h3>
<p>对于Seata而言，是通过记录DML操作的前后的数据用于进行后续可能的回滚操作的，并且把这些数据保存到数据库的一个blob的字段里面。对于批量插入，更新，删除等操作，其影响的行数可能会比较多，拼接成一个大的字段插入到数据库，可能会带来以下问题：</p>
<ol>
<li>超出数据库单次操作的最大写入限制(比如MySQL的max_allowed_package参数)；</li>
<li>较大的数据量带来的网络IO和数据库磁盘IO开销比较大。</li>
</ol>
<h3>头脑风暴</h3>
<p>对于第1点的问题，可以根据业务的实际情况，调大max_allowed_package参数的限制，从而避免出现query is too large的问题；对于第2点，可以通过提高带宽和选用高性能的SSD作为数据库的存储介质。</p>
<p>以上都是通过外部方案或者加钱方案去解决的。那么有没有框架层面解决方案以解决上面的痛点？</p>
<p>此时结合到以上的痛点出现的根源，在于生成的数据字段过大。为此，如果可以把对应的数据进行业务方压缩之后，再进行数据传输以及落库，理论上也可以解决上面的问题。</p>
<h3>可行性分析</h3>
<p>结合以上头脑风暴的内容，考虑在实际开发中，当需要进行大批量操作的时候，大多会选在较少用户操作，并发相对较低的时间点执行，此时CPU，内存等资源可以相对占用多一点以快速完成对应的操作。因此，可以通过消耗CPU资源和内存资源，来对对应的回滚的数据进行压缩，从而缩小数据传输和存储的大小。</p>
<p>此时，还需要证明以下两件事：</p>
<ol>
<li>经过压缩之后，可以减少网络IO和数据库磁盘IO的压力，这里可以采用数据压缩+落库完成的总时间作为侧面参考指标。</li>
<li>经过压缩之后，数据大小跟原来比较的压缩效率有多高，这里使用压缩前后的数据大小来作为指标。</li>
</ol>
<p>压缩网络用时指标测试：</p>
<p><img src="https://user-images.githubusercontent.com/22959373/95567752-f55ddf80-0a55-11eb-8092-1f1d99855bdd.png" alt="image"></p>
<p>压缩比测试：</p>
<p><img src="https://user-images.githubusercontent.com/22959373/95567834-0ad30980-0a56-11eb-9d7e-48b74babbea4.png" alt="image"></p>
<p>通过以上的测试结果，可以明显的看出，使用gzip或zip进行压缩的情况下，可以较大程度的减少数据库的压力和网络传输的压力，同时也可以较大幅度的减少保存的数据的大小。</p>
<h3>实现</h3>
<h4>实现思路</h4>
<p><img src="https://user-images.githubusercontent.com/22959373/116281711-8f039900-a7bc-11eb-91f8-82afdbb9f932.png" alt="压缩"></p>
<h4>部分代码</h4>
<p>properties配置：</p>
<pre><code class="language-properties"><span class="hljs-comment"># 是否开启undo_log压缩，默认为true</span>
<span class="hljs-meta">seata.client.undo.compress.enable</span>=<span class="hljs-string">true</span>
<span class="hljs-comment"># 压缩器类型，默认为zip，一般建议都是zip</span>
<span class="hljs-meta">seata.client.undo.compress.type</span>=<span class="hljs-string">zip</span>
<span class="hljs-comment"># 启动压缩的阈值，默认为64k</span>
<span class="hljs-meta">seata.client.undo.compress.threshold</span>=<span class="hljs-string">64k</span>
</code></pre>
<p>判断是否开启了undo_log压缩功能以及是否达到压缩的阈值：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">needCompress</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] undoLogContent)</span> </span>{
    <span class="hljs-comment">// 1. 判断是否开启了undo_log压缩功能(1.4.2默认开启)</span>
    <span class="hljs-comment">// 2. 判断是否达到了压缩的阈值(默认64k)</span>
    <span class="hljs-comment">// 如果都满足返回需要对对应的undoLogContent进行压缩</span>
    <span class="hljs-keyword">return</span> ROLLBACK_INFO_COMPRESS_ENABLE 
        &amp;&amp; undoLogContent.length &gt; ROLLBACK_INFO_COMPRESS_THRESHOLD;
}
</code></pre>
<p>确定需要压缩后，对undo_log进行压缩：</p>
<pre><code class="language-java"><span class="hljs-comment">// 如果需要压缩，对undo_log进行压缩</span>
<span class="hljs-keyword">if</span> (needCompress(undoLogContent)) {
    <span class="hljs-comment">// 获取压缩类型，默认zip</span>
    compressorType = ROLLBACK_INFO_COMPRESS_TYPE;
    <span class="hljs-comment">// 获取对应的压缩器，并且进行压缩</span>
    undoLogContent = CompressorFactory.getCompressor(compressorType.getCode()).compress(undoLogContent);
}
<span class="hljs-comment">// else 不需要压缩就不需要做任何操作</span>
</code></pre>
<p>将压缩类型同步保存到数据库，供回滚时使用：</p>
<pre><code class="language-java"><span class="hljs-function"><span class="hljs-keyword">protected</span> String <span class="hljs-title">buildContext</span><span class="hljs-params">(String serializer, CompressorType compressorType)</span> </span>{
    Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    map.put(UndoLogConstants.SERIALIZER_KEY, serializer);
    <span class="hljs-comment">// 保存压缩类型到数据库</span>
    map.put(UndoLogConstants.COMPRESSOR_TYPE_KEY, compressorType.name());
    <span class="hljs-keyword">return</span> CollectionUtils.encodeMap(map);
}
</code></pre>
<p>回滚时解压缩对应的信息：</p>
<pre><code class="language-java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">byte</span>[] getRollbackInfo(ResultSet rs) <span class="hljs-keyword">throws</span> SQLException  {
    <span class="hljs-comment">// 获取保存到数据库的回滚信息的字节数组</span>
    <span class="hljs-keyword">byte</span>[] rollbackInfo = rs.getBytes(ClientTableColumnsName.UNDO_LOG_ROLLBACK_INFO);
    <span class="hljs-comment">// 获取压缩类型</span>
    <span class="hljs-comment">// getOrDefault使用默认值CompressorType.NONE来兼容1.4.2之前的版本直接升级1.4.2+</span>
    String rollbackInfoContext = rs.getString(ClientTableColumnsName.UNDO_LOG_CONTEXT);
    Map&lt;String, String&gt; context = CollectionUtils.decodeMap(rollbackInfoContext);
    CompressorType compressorType = CompressorType.getByName(context.getOrDefault(UndoLogConstants.COMPRESSOR_TYPE_KEY,
    CompressorType.NONE.name()));
    <span class="hljs-comment">// 获取对应的压缩器，并且解压缩</span>
    <span class="hljs-keyword">return</span> CompressorFactory.getCompressor(compressorType.getCode())
        .decompress(rollbackInfo);
}
</code></pre>
<h3>结语</h3>
<p>通过对undo_log的压缩，在框架层面，进一步提高Seata在处理数据量较大的时候的性能。同时，也提供了对应的开关和相对合理的默认值，既方便用户进行开箱即用，也方便用户根据实际需求进行一定的调整，使得对应的功能更适合实际使用场景。</p>
</section><footer class="footer-container"><div class="footer-body"><img src="//img.alicdn.com/tfs/TB1dGrSwVT7gK0jSZFpXXaTkpXa-4802-1285.png"/><p class="docsite-power">website powered by docsite</p><div class="cols-container"><div class="col col-12"><h3>愿景</h3><p>Seata 是一款阿里巴巴开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/overview/what-is-seata.html" target="_self">Seata 是什么？</a></dd><dd><a href="/zh-cn/docs/user/quickstart.html" target="_self">快速开始</a></dd><dd><a href="https://github.com/seata/seata.github.io/issues/new" target="_self">报告文档问题</a></dd><dd><a href="https://github.com/seata/seata.github.io" target="_self">在Github上编辑此文档</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2021 Seata</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/blogDetail.js"></script>
	<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?104e73ef0c18b416b27abb23757ed8ee";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
</body>
</html>
