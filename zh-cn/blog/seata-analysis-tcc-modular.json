{
  "filename": "seata-analysis-tcc-modular.md",
  "__html": "<h2>一  .导读</h2>\n<p>spring 模块分析中讲到，Seata 的 spring 模块会对涉及到分布式业务的 bean 进行处理。项目启动时，当 GlobalTransactionalScanner 扫描到 TCC 服务的 reference 时（即tcc事务参与方），会对其进行动态代理，即给 bean 织入 TCC 模式下的 MethodInterceptor 的实现类。tcc 事务发起方依然使用 @GlobalTransactional 注解开启，织入的是通用的 MethodInterceptor 的实现类。</p>\n<p>TCC 模式下的 MethodInterceptor 实现类即 TccActionInterceptor(spring模块) ，这个类中调用了 ActionInterceptorHandler(tcc模块) 进行 TCC 模式下事务流程的处理。</p>\n<p>TCC 动态代理的主要功能是：生成TCC运行时上下文、透传业务参数、注册分支事务记录。</p>\n<h2>二  .TCC模式介绍</h2>\n<p>在2PC（两阶段提交）协议中，事务管理器分两阶段协调资源管理，资源管理器对外提供三个操作，分别是一阶段的准备操作，和二阶段的提交操作和回滚操作。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">TccAction</span> </span>{\n\n    <span class=\"hljs-meta\">@TwoPhaseBusinessAction</span>(name = <span class=\"hljs-string\">\"tccActionForTest\"</span> , commitMethod = <span class=\"hljs-string\">\"commit\"</span>, rollbackMethod = <span class=\"hljs-string\">\"rollback\"</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">prepare</span><span class=\"hljs-params\">(BusinessActionContext actionContext,\n                           @BusinessActionContextParameter(paramName = <span class=\"hljs-string\">\"a\"</span>)</span> <span class=\"hljs-keyword\">int</span> a,\n                           @<span class=\"hljs-title\">BusinessActionContextParameter</span><span class=\"hljs-params\">(paramName = <span class=\"hljs-string\">\"b\"</span>, index = <span class=\"hljs-number\">0</span>)</span> List b,\n                           @<span class=\"hljs-title\">BusinessActionContextParameter</span><span class=\"hljs-params\">(isParamInProperty = <span class=\"hljs-keyword\">true</span>)</span> TccParam tccParam)</span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">commit</span><span class=\"hljs-params\">(BusinessActionContext actionContext)</span></span>;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">rollback</span><span class=\"hljs-params\">(BusinessActionContext actionContext)</span></span>;\n}\n</code></pre>\n<p>这是 TCC 参与者实例，参与者需要实现三个方法，第一个参数必须是 BusinessActionContext ，方法返回类型固定，对外发布成微服务，供事务管理器调用。</p>\n<p>prepare：资源的检查和预留。例：扣减账户的余额，并增加相同的冻结余额。</p>\n<p>commit：使用预留的资源，完成真正的业务操作。例：减少冻结余额，扣减资金业务完成。</p>\n<p>cancel：释放预留资源。例：冻结余额加回账户的余额。</p>\n<p>其中 BusinessActionContext 封装了本次事务的上下文环境：xid、branchId、actionName 和被 @BusinessActionContextParam 注解的参数等。</p>\n<p>参与方业务有几个需要注意的地方：\n1.控制业务幂等性，需要支持同一笔事务的重复提交和重复回滚。\n2.防悬挂，即二阶段的回滚，比一阶段的 try 先执行。\n3.放宽一致性协议，最终一致，所以是读已修改</p>\n<h2>三  . remoting 包解析</h2>\n<p><img src=\"https://img-blog.csdnimg.cn/20191124211806237.png?\" alt=\"在这里插入图片描述\"></p>\n<p>包中所有的类都是为包中的 DefaultRemotingParser 服务，Dubbo、LocalTCC、SofaRpc 分别负责解析各自RPC协议下的类。</p>\n<p>DefaultRemotingParser 的主要方法：\n1.判断 bean 是否是 remoting bean，代码：</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isRemoting</span><span class=\"hljs-params\">(Object bean, String beanName)</span> <span class=\"hljs-keyword\">throws</span> FrameworkException </span>{\n        <span class=\"hljs-comment\">//判断是否是服务调用方或者是否是服务提供方</span>\n        <span class=\"hljs-keyword\">return</span> isReference(bean, beanName) || isService(bean, beanName);\n    }\n</code></pre>\n<p>2.远程 bean 解析，把 rpc类 解析成 RemotingDesc，，代码：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isRemoting</span><span class=\"hljs-params\">(Object bean, String beanName)</span> <span class=\"hljs-keyword\">throws</span> FrameworkException </span>{\n        <span class=\"hljs-comment\">//判断是否是服务调用方或者是否是服务提供方</span>\n        <span class=\"hljs-keyword\">return</span> isReference(bean, beanName) || isService(bean, beanName);\n    }\n</code></pre>\n<p>利用 allRemotingParsers 来解析远程 bean 。allRemotingParsers是在：initRemotingParser()  中调用EnhancedServiceLoader.loadAll(RemotingParser.class) 动态进行 RemotingParser 子类的加载，即 SPI 加载机制。</p>\n<p>如果想扩展，比如实现一个feign远程调用的解析类，只要把RemotingParser相关实现类写在 SPI 的配置中就可以了，扩展性很强。</p>\n<p>RemotingDesc 事务流程需要的远程 bean 的一些具体信息，比如 targetBean、interfaceClass、interfaceClassName、protocol、isReference等等。</p>\n<p>3.TCC资源注册</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> RemotingDesc <span class=\"hljs-title\">parserRemotingServiceInfo</span><span class=\"hljs-params\">(Object bean, String beanName)</span> </span>{\n        RemotingDesc remotingBeanDesc = getServiceDesc(bean, beanName);\n        <span class=\"hljs-keyword\">if</span> (remotingBeanDesc == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">null</span>;\n        }\n        remotingServiceMap.put(beanName, remotingBeanDesc);\n\n        Class&lt;?&gt; interfaceClass = remotingBeanDesc.getInterfaceClass();\n        Method[] methods = interfaceClass.getMethods();\n        <span class=\"hljs-keyword\">if</span> (isService(bean, beanName)) {\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-comment\">//service bean, registry resource</span>\n                Object targetBean = remotingBeanDesc.getTargetBean();\n                <span class=\"hljs-keyword\">for</span> (Method m : methods) {\n                    TwoPhaseBusinessAction twoPhaseBusinessAction = m.getAnnotation(TwoPhaseBusinessAction.class);\n                    <span class=\"hljs-keyword\">if</span> (twoPhaseBusinessAction != <span class=\"hljs-keyword\">null</span>) {\n                        TCCResource tccResource = <span class=\"hljs-keyword\">new</span> TCCResource();\n                        tccResource.setActionName(twoPhaseBusinessAction.name());\n                        tccResource.setTargetBean(targetBean);\n                        tccResource.setPrepareMethod(m);\n                        tccResource.setCommitMethodName(twoPhaseBusinessAction.commitMethod());\n                        tccResource.setCommitMethod(ReflectionUtil\n                            .getMethod(interfaceClass, twoPhaseBusinessAction.commitMethod(),\n                                <span class=\"hljs-keyword\">new</span> Class[] {BusinessActionContext.class}));\n                        tccResource.setRollbackMethodName(twoPhaseBusinessAction.rollbackMethod());\n                        tccResource.setRollbackMethod(ReflectionUtil\n                            .getMethod(interfaceClass, twoPhaseBusinessAction.rollbackMethod(),\n                                <span class=\"hljs-keyword\">new</span> Class[] {BusinessActionContext.class}));\n                        <span class=\"hljs-comment\">//registry tcc resource</span>\n                        DefaultResourceManager.get().registerResource(tccResource);\n                    }\n                }\n            } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> FrameworkException(t, <span class=\"hljs-string\">\"parser remoting service error\"</span>);\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (isReference(bean, beanName)) {\n            <span class=\"hljs-comment\">//reference bean, TCC proxy</span>\n            remotingBeanDesc.setReference(<span class=\"hljs-keyword\">true</span>);\n        }\n        <span class=\"hljs-keyword\">return</span> remotingBeanDesc;\n    }\n</code></pre>\n<p>首先判断是否是事务参与方，如果是，拿到 RemotingDesc 中的 interfaceClass，遍历接口中的方法，判断方法上是否有@TwoParserBusinessAction 注解，如果有，把参数封装成 TCCRecource，通过 DefaultResourceManager 进行 TCC 资源的注册。</p>\n<p>这里 DefaultResourceManager 会根据 Resource 的 BranchType 来寻找对应的资源管理器，TCC 模式下资源管理类，在 tcc 模块中。</p>\n<p>这个 rpc 解析类主要提供给 spring 模块进行使用。parserRemotingServiceInfo() 被封装到了 spring 模块的 TCCBeanParserUtils 工具类中。spring 模块的 GlobalTransactionScanner 在项目启动的时候，通过工具类解析 TCC bean，工具类 TCCBeanParserUtils 会调用 TCCResourceManager 进行资源的注册，并且如果是全局事务的服务提供者，会织入 TccActionInterceptor 代理。这些个流程是 spring 模块的功能，tcc 模块是提供功能类给 spring 模块使用。</p>\n<h2>三  .tcc 资源管理器</h2>\n<p>TCCResourceManager 负责管理 TCC 模式下资源的注册、分支的注册、提交、和回滚。</p>\n<p>1.在项目启动时， spring 模块的 GlobalTransactionScanner 扫描到 bean 是 tcc bean 时，会本地缓存资源，并向 server 注册：</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerResource</span><span class=\"hljs-params\">(Resource resource)</span> </span>{\n        TCCResource tccResource = (TCCResource)resource;\n        tccResourceCache.put(tccResource.getResourceId(), tccResource);\n        <span class=\"hljs-keyword\">super</span>.registerResource(tccResource);\n    }\n</code></pre>\n<p>与server通信的逻辑被封装在了父类 AbstractResourceManage 中，这里根据 resourceId 对 TCCResource 进行缓存。父类 AbstractResourceManage  注册资源的时候，使用 resourceGroupId + actionName，actionName 就是 @TwoParseBusinessAction 注解中的 name，resourceGroupId 默认是 DEFAULT。</p>\n<p>2.事务分支的注册在 rm-datasource 包下的 AbstractResourceManager 中，注册时参数 lockKeys 为 null，和 AT 模式下事务分支的注册还是有些不一样的。</p>\n<p>3.分支的提交或者回滚：</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BranchStatus <span class=\"hljs-title\">branchCommit</span><span class=\"hljs-params\">(BranchType branchType, String xid, <span class=\"hljs-keyword\">long</span> branchId, String resourceId,\n                                     String applicationData)</span> <span class=\"hljs-keyword\">throws</span> TransactionException </span>{\n        TCCResource tccResource = (TCCResource)tccResourceCache.get(resourceId);\n        <span class=\"hljs-keyword\">if</span> (tccResource == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ShouldNeverHappenException(<span class=\"hljs-string\">\"TCC resource is not exist, resourceId:\"</span> + resourceId);\n        }\n        Object targetTCCBean = tccResource.getTargetBean();\n        Method commitMethod = tccResource.getCommitMethod();\n        <span class=\"hljs-keyword\">if</span> (targetTCCBean == <span class=\"hljs-keyword\">null</span> || commitMethod == <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ShouldNeverHappenException(<span class=\"hljs-string\">\"TCC resource is not available, resourceId:\"</span> + resourceId);\n        }\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">boolean</span> result = <span class=\"hljs-keyword\">false</span>;\n            <span class=\"hljs-comment\">//BusinessActionContext</span>\n            BusinessActionContext businessActionContext = getBusinessActionContext(xid, branchId, resourceId,\n                applicationData);\n            Object ret = commitMethod.invoke(targetTCCBean, businessActionContext);\n            <span class=\"hljs-keyword\">if</span> (ret != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-keyword\">if</span> (ret <span class=\"hljs-keyword\">instanceof</span> TwoPhaseResult) {\n                    result = ((TwoPhaseResult)ret).isSuccess();\n                } <span class=\"hljs-keyword\">else</span> {\n                    result = (<span class=\"hljs-keyword\">boolean</span>)ret;\n                }\n            }\n            <span class=\"hljs-keyword\">return</span> result ? BranchStatus.PhaseTwo_Committed : BranchStatus.PhaseTwo_CommitFailed_Retryable;\n        } <span class=\"hljs-keyword\">catch</span> (Throwable t) {\n            LOGGER.error(msg, t);\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> FrameworkException(t, msg);\n        }\n    }\n</code></pre>\n<p>通过参数 xid、branchId、resourceId、applicationData 恢复业务的上下文 businessActionContext。</p>\n<p>根据获取到的上下文通过反射执行 commit 方法，并返回执行结果。回滚方法类似。</p>\n<p>这里 branchCommit() 和 branchRollback() 提供给 rm 模块资源处理的抽象类 AbstractRMHandler 调用，这个 handler 是 core 模块定义的模板方法的进一步实现类。和 registerResource() 不一样，后者是 spring 扫描时主动注册资源。</p>\n<h2>四  . tcc 模式事务处理</h2>\n<p>spring 模块中的 TccActionInterceptor 的 invoke() 方法在被代理的 rpc bean 被调用时执行。该方法先获取 rpc 拦截器透传过来的全局事务 xid ，然后 TCC 模式下全局事务参与者的事务流程还是交给 tcc 模块 ActionInterceptorHandler  处理。</p>\n<p>也就是说，事务参与者，在项目启动的时候，被代理。真实的业务方法，在 ActionInterceptorHandler 中，通过回调执行。</p>\n<pre><code class=\"language-java\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Map&lt;String, Object&gt; <span class=\"hljs-title\">proceed</span><span class=\"hljs-params\">(Method method, Object[] arguments, String xid, TwoPhaseBusinessAction businessAction,\n                                       Callback&lt;Object&gt; targetCallback)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        Map&lt;String, Object&gt; ret = <span class=\"hljs-keyword\">new</span> HashMap&lt;String, Object&gt;(<span class=\"hljs-number\">4</span>);\n\n        <span class=\"hljs-comment\">//TCC name</span>\n        String actionName = businessAction.name();\n        BusinessActionContext actionContext = <span class=\"hljs-keyword\">new</span> BusinessActionContext();\n        actionContext.setXid(xid);\n        <span class=\"hljs-comment\">//set action anme</span>\n        actionContext.setActionName(actionName);\n\n        <span class=\"hljs-comment\">//Creating Branch Record</span>\n        String branchId = doTccActionLogStore(method, arguments, businessAction, actionContext);\n        actionContext.setBranchId(branchId);\n\n        <span class=\"hljs-comment\">//set the parameter whose type is BusinessActionContext</span>\n        Class&lt;?&gt;[] types = method.getParameterTypes();\n        <span class=\"hljs-keyword\">int</span> argIndex = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (Class&lt;?&gt; cls : types) {\n            <span class=\"hljs-keyword\">if</span> (cls.getName().equals(BusinessActionContext.class.getName())) {\n                arguments[argIndex] = actionContext;\n                <span class=\"hljs-keyword\">break</span>;\n            }\n            argIndex++;\n        }\n        <span class=\"hljs-comment\">//the final parameters of the try method</span>\n        ret.put(Constants.TCC_METHOD_ARGUMENTS, arguments);\n        <span class=\"hljs-comment\">//the final result</span>\n        ret.put(Constants.TCC_METHOD_RESULT, targetCallback.execute());\n        <span class=\"hljs-keyword\">return</span> ret;\n    }\n</code></pre>\n<p>这里有两个重要操作：</p>\n<p>1.doTccActionLogStore() 这个方法中，调用了两个比较重要的方法：\nfetchActionRequestContext(method, arguments)，这个方法把被 @BusinessActionContextParam 注解的参数取出来，在下面的 init 方法中塞入 BusinessActionComtext ，同时塞入的还有事务相关参数。\nDefaultResourceManager.get().branchRegister(BranchType.TCC, actionName, null, xid,applicationContextStr, null)，这个方法执行 TCC 模式下事务参与者事务分支的注册。</p>\n<p>2.回调执行 targetCallback.execute() ，被代理的 bean 具体的业务，即 prepare() 方法。</p>\n<h2>五  .总结</h2>\n<p>tcc模块，主要提供以下功能 ：</p>\n<ol>\n<li>定义两阶段协议注解，提供 tcc 模式下事务流程需要的属性。</li>\n<li>提供解析不同 rpc 框架 remoting bean 的 ParserRemoting 实现，供 spring 模块调用。</li>\n<li>提供 TCC 模式下资源管理器，进行资源注册、事务分支注册提交回滚等。</li>\n<li>提供 TCC 模式下事务流程的处理类，让 MethodInterceptor 代理类不执行具体模式的事务流程，而是下放到 tcc 模块。</li>\n</ol>\n<h2>五  .相关</h2>\n<p>作者：赵润泽，<a href=\"https://blog.csdn.net/qq_37804737/category_9530078.html\">系列地址</a>。</p>\n",
  "link": "/zh-cn/blog/seata-analysis-tcc-modular.html",
  "meta": {
    "title": "Seata tcc 模块源码分析",
    "author": "赵润泽",
    "keywords": "Seata、分布式事务",
    "date": "2019/12/25"
  }
}