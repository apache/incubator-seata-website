<!doctype html>
<html lang="zh-CN" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">Seata数据源代理解析 | Seata</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://seata.io/zh-cn/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://seata.io/zh-cn/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://seata.io/zh-cn/blog/seata-datasource-proxy"><meta data-rh="true" name="docusaurus_locale" content="zh-cn"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-cn"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Seata数据源代理解析 | Seata"><meta data-rh="true" name="description" content="本文主要介绍Seata数据源代理实现原理及使用时可能会遇到的问题"><meta data-rh="true" property="og:description" content="本文主要介绍Seata数据源代理实现原理及使用时可能会遇到的问题"><meta data-rh="true" name="keywords" content="Seata、数据源、数据源代理、多数据源"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2020-10-16T00:00:00.000Z"><link data-rh="true" rel="icon" href="/zh-cn/img/seata_logo_small.jpeg"><link data-rh="true" rel="canonical" href="https://seata.io/zh-cn/blog/seata-datasource-proxy"><link data-rh="true" rel="alternate" href="https://seata.io/en/blog/seata-datasource-proxy" hreflang="en-US"><link data-rh="true" rel="alternate" href="https://seata.io/zh-cn/blog/seata-datasource-proxy" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://seata.io/blog/seata-datasource-proxy" hreflang="default"><link data-rh="true" rel="alternate" href="https://seata.io/blog/seata-datasource-proxy" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://ICHFIJRDZF-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/zh-cn/blog/rss.xml" title="Seata RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh-cn/blog/atom.xml" title="Seata Atom Feed">


<link rel="search" type="application/opensearchdescription+xml" title="Seata" href="/zh-cn/opensearch.xml">

<meta name="aes-config" content="pid=xux-opensource&amp;user_type=101&amp;uid=&amp;username=&amp;dim10=seata">
<link rel="stylesheet" href="//g.alicdn.com/mamba/assets/0.0.19/mse-arc-ui.min.css">
<script src="//g.alicdn.com/mamba/assets/0.0.19/mse-arc-ui.min.js"></script>
<script src="https://www.googletagmanager.com/gtag/js?id=G-X4LJGF90X2" async></script><link rel="stylesheet" href="/zh-cn/assets/css/styles.4de6876d.css">
<link rel="preload" href="/zh-cn/assets/js/runtime~main.b56bbcbc.js" as="script">
<link rel="preload" href="/zh-cn/assets/js/main.23eb4378.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script>


<script src="https://hm.baidu.com/hm.js?104e73ef0c18b416b27abb23757ed8ee"></script>
<script src="//g.alicdn.com/alilog/mlog/aplus_v2.js" id="beacon-aplus" exparams="clog=o&amp;aplus&amp;sidx=aplusSidx&amp;ckx=aplusCkx"></script>
<script src="//g.alicdn.com/aes/??tracker/1.0.34/index.js,tracker-plugin-pv/2.4.5/index.js,tracker-plugin-event/1.2.5/index.js,tracker-plugin-jserror/1.0.13/index.js,tracker-plugin-api/1.1.14/index.js,tracker-plugin-perf/1.1.8/index.js,tracker-plugin-eventTiming/1.0.4/index.js"></script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/zh-cn/"><div class="navbar__logo"><img src="/zh-cn/img/seata_logo.png" alt="Seata Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/zh-cn/img/seata_logo.png" alt="Seata Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate"></b></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/zh-cn/">首页</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" aria-haspopup="true" aria-expanded="false" role="button" docid="/overview/what-is-seata" href="/zh-cn/docs/overview/what-is-seata">v2.0</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/zh-cn/docs/next/overview/what-is-seata">用户文档</a></li><li><a class="dropdown__link" href="/zh-cn/docs/overview/what-is-seata">v2.0</a></li><li><a class="dropdown__link" href="/zh-cn/docs/v1.8/overview/what-is-seata">v1.8</a></li><li><a class="dropdown__link" href="/zh-cn/docs/v1.7/overview/what-is-seata">v1.7</a></li><li><a class="dropdown__link" href="/zh-cn/docs/v1.6/overview/what-is-seata">v1.6</a></li><li><a class="dropdown__link" href="/zh-cn/docs/v1.5/overview/what-is-seata">v1.5</a></li><li><a class="dropdown__link" href="/zh-cn/docs/v1.4/overview/what-is-seata">v1.4</a></li><li><a class="dropdown__link" href="/zh-cn/docs/v1.3/overview/what-is-seata">v1.3</a></li><li><a class="dropdown__link" href="/zh-cn/docs/v1.2/overview/what-is-seata">v1.2</a></li><li><a class="dropdown__link" href="/zh-cn/docs/v1.1/overview/what-is-seata">v1.1</a></li><li><a class="dropdown__link" href="/zh-cn/docs/v1.0/overview/what-is-seata">v1.0</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">解决方案</a><ul class="dropdown__menu"><li><a href="https://www.aliyun.com/product/aliware/mse?spm=seata-website.topbar.0.0.0" target="_blank" rel="noopener noreferrer" class="dropdown__link">Seata in Cloud<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li><a href="https://help.aliyun.com/document_detail/132903.html?spm=seata-website.topbar.0.0.0" target="_blank" rel="noopener noreferrer" class="dropdown__link">SOFA分布式事务<svg width="12" height="12" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><a href="https://free.aliyun.com/?searchKey=nacos&amp;spm=seata-website.topbar.0.0.0" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">免费试用<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><a class="navbar__item navbar__link" href="/zh-cn/docs/developers/developers_dev">开发者</a><a href="https://mp.weixin.qq.com/s/nvDmIJEuDaNEY3RfTA3UyA" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">团队招聘</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/zh-cn/blog">博客</a><a class="navbar__item navbar__link" href="/zh-cn/community">社区</a><a class="navbar__item navbar__link" href="/zh-cn/docs/download">下载</a><a href="http://demo.seata.io/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">控制台样例</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_DSK9"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>中</a><ul class="dropdown__menu"><li><a href="/en/blog/seata-datasource-proxy" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en-US">En</a></li><li><a href="/zh-cn/blog/seata-datasource-proxy" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-CN">中</a></li></ul></div><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">所有文章</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/explore-seata-journey">探索 Seata 项目开源开发之旅</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-raft-detailed-explanation">Seata-Raft 存储模式详解及入门</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-connect-data-and-application">Seata：连接数据与应用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-observable-practice">Seata的可观测实践</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-go-1.2.0">生产环境可用的 seata-go 1.2.0 来了！！！</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/iscas2023">6大课题现已开放挑选 | 欢迎报名 Seata 开源之夏</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-1.6.0">Seata 1.6.0 重磅发布，大幅提升性能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-1.5.2">Seata 1.5.2 重磅发布，支持xid负载均衡</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-tcc-fence">阿里 Seata 新版本终于解决了 TCC 模式的幂等、悬挂和空回滚问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-tcc">深度剖析 Seata TCC 模式（一）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-at-lock">详解 Seata AT 模式事务隔离级别与全局锁设计</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-snowflake-explain">关于新版雪花算法的答疑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-analysis-UUID-generator">Seata基于改良版雪花算法的分布式UUID生成器分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-feature-undo-log-compress">Seata新特性支持 -- undo_log压缩</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-dsproxy-deadlock">ConcurrentHashMap导致的Seata死锁问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-client-start-analysis-02">Seata应用侧启动过程剖析——注册中心与配置中心模块</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-client-start-analysis-01">Seata应用侧启动过程剖析——RM &amp; TM如何与TC建立连接</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/integrate-seata-tcc-mode-with-spring-cloud">Spring Cloud集成Seata分布式事务-TCC模式</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-config-manager">Seata配置管理原理解析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-golang-communication-mode">seata-golang 通信模型详解</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/zh-cn/blog/seata-datasource-proxy">Seata数据源代理解析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-sourcecode-client-bootstrap">分布式事务Seata源码-Client端启动流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-at-demo-in-mac">Mac下的Seata Demo环境搭建（AT模式）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-rpc-refactor">Seata RPC 模块的重构之路</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-sourcecode-server-bootstrap">分布式事务Seata源码-Server端启动流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-xa-introduce">分布式事务如何实现？深入解读 Seata 的 XA 模式</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-quick-start">Seata 极简入门</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-ha-practice">Seata 高可用部署实践</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-analysis-config-modular">Seata config 模块源码分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-analysis-dubbo-transmit-xid">源码分析Seata-XID传递 Dubbo篇</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-analysis-tcc-modular">Seata tcc 模块源码分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-community-meetup-hangzhou-ready">Seata Community Meetup·杭州站</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-analysis-core-modular">Seata core 模块源码分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-spring-boot-aop-aspectj">通过AOP动态创建/关闭Seata分布式事务</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-dynamic-config-and-dynamic-disable">Seata 动态配置订阅与降级实现原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-config-center">Seata 配置中心实现原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-nacos-docker">Docker部署Seata与Nacos整合</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-nacos-analysis">Seata分布式事务启用Nacos做配置中心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-meetup-hangzhou">Seata Community Meetup·杭州站</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-mybatisplus-analysis">透过源码解决SeataAT模式整合Mybatis-Plus失去MP特性的问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/springboot-dubbo-mybatisplus-seata">SpringBoot+Dubbo+MybatisPlus整合seata分布式事务</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-at-mode-start-rm-tm">Seata 客户端需要同时启动 RM 和 TM 吗？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-at-mode-start">Seata AT 模式启动源码分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/design-more-flexable-application-by-saga">基于 Seata Saga 设计更有弹性的金融应用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-at-tcc-saga">分布式事务 Seata 及其三种模式详解</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-at-mode-design">分布式事务中间件 Seata 的设计原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-analysis-go-server">Seata分布式Go Server正式开源-TaaS设计简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/how-to-support-spring-cloud">Fescar 与 Spring Cloud 集成源码深度剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/integrate-seata-with-spring-cloud">Seata（Fescar）分布式事务 整合 Spring Cloud</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-analysis-java-client">分布式事务之Seata-Client原理及流程详解</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-analysis-java-server">深度剖析一站式分布式事务方案Seata-Server</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/tcc-mode-applicable-scenario-analysis">TCC适用模型与适用场景分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/tcc-mode-design-principle">TCC 理论及设计实现指南介绍</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/quick-start-use-seata-and-dubbo-services">如何使用Seata保证Dubbo微服务间的一致性</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/seata-analysis-simple">Fescar分布式事务原理解析探秘</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/zh-cn/blog/manual-transaction-mode">MT 模式</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">Seata数据源代理解析</h1><div class="container_mt6G margin-vert--md"><time datetime="2020-10-16T00:00:00.000Z" itemprop="datePublished">2020年10月16日</time> · <!-- -->阅读需 37 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><span itemprop="name">罗小勇</span></div></div></div></div></div></header><div id="__blog-post-container" class="markdown" itemprop="articleBody"><p>在Seata1.3.0版本中，数据源自动代理和手动代理一定不能混合使用，否则会导致多层代理，从而导致以下问题：</p><ol><li>单数据源情况下：导致分支事务提交时，undo_log本身也被代理，即<code>为 undo_log 生成了 undo_log， 假设为undo_log2</code>，此时undo_log将被当作分支事务来处理；分支事务回滚时，因为<code>undo_log2</code>生成的有问题，在<code>undo_log对应的事务分支</code>回滚时会将<code>业务表关联的undo_log</code>也一起删除，从而导致<code>业务表对应的事务分支</code>回滚时发现undo_log不存在，从而又多生成一条状态为1的undo_log。这时候整体逻辑已经乱了，很严重的问题</li><li>多数据源和<code>逻辑数据源被代理</code>情况下：除了单数据源情况下会出现的问题，还可能会造成死锁问题。死锁的原因就是针对undo_log的操作，本该在一个事务中执行的<code>select for update</code> 和 <code>delete</code> 操作，被分散在多个事务中执行，导致一个事务在执行完<code>select for update</code>后一直不提交，一个事务在执行<code>delete</code>时一直等待锁，直到超时</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="代理描述">代理描述<a href="#代理描述" class="hash-link" aria-label="代理描述的直接链接" title="代理描述的直接链接">​</a></h2><p>即对DataSource代理一层，重写一些方法。比如<code>getConnection</code>方法，这时不直接返回一个<code>Connection</code>，而是返回<code>ConnectionProxy</code>，其它的以此类推</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// DataSourceProxy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public DataSourceProxy(DataSource targetDataSource) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this(targetDataSource, DEFAULT_RESOURCE_GROUP_ID);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void init(DataSource dataSource, String resourceGroupId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DefaultResourceManager.get().registerResource(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public Connection getPlainConnection() throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return targetDataSource.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public ConnectionProxy getConnection() throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Connection targetConnection = targetDataSource.getConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new ConnectionProxy(this, targetConnection);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="手动代理">手动代理<a href="#手动代理" class="hash-link" aria-label="手动代理的直接链接" title="手动代理的直接链接">​</a></h2><p>即手动注入一个<code>DataSourceProxy</code>，如下</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public DataSource druidDataSource() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new DruidDataSource()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Primary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Bean(&quot;dataSource&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public DataSourceProxy dataSource(DataSource druidDataSource) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new DataSourceProxy(druidDataSource);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="自动代理">自动代理<a href="#自动代理" class="hash-link" aria-label="自动代理的直接链接" title="自动代理的直接链接">​</a></h2><p>针对<code>DataSource</code>创建一个代理类，在代理类里面基于<code>DataSource</code>获取<code>DataSourceProxy(如果没有就创建)</code>，然后调用<code>DataSourceProxy</code>的相关方法。核心逻辑在<code>SeataAutoDataSourceProxyCreator</code>中</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SeataAutoDataSourceProxyCreator extends AbstractAutoProxyCreator {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Logger LOGGER = LoggerFactory.getLogger(SeataAutoDataSourceProxyCreator.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final String[] excludes;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Advisor advisor = new DefaultIntroductionAdvisor(new SeataAutoDataSourceProxyAdvice());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SeataAutoDataSourceProxyCreator(boolean useJdkProxy, String[] excludes) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.excludes = excludes;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        setProxyTargetClass(!useJdkProxy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource customTargetSource) throws BeansException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (LOGGER.isInfoEnabled()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            LOGGER.info(&quot;Auto proxy of [{}]&quot;, beanName);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Object[]{advisor};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return SeataProxy.class.isAssignableFrom(beanClass) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                DataSourceProxy.class.isAssignableFrom(beanClass) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                !DataSource.class.isAssignableFrom(beanClass) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                Arrays.asList(excludes).contains(beanClass.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SeataAutoDataSourceProxyAdvice implements MethodInterceptor, IntroductionInfo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object invoke(MethodInvocation invocation) throws Throwable {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        DataSourceProxy dataSourceProxy = DataSourceProxyHolder.get().putDataSource((DataSource) invocation.getThis());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method method = invocation.getMethod();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Object[] args = invocation.getArguments();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        Method m = BeanUtils.findDeclaredMethod(DataSourceProxy.class, method.getName(), method.getParameterTypes());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (m != null) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return m.invoke(dataSourceProxy, args);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return invocation.proceed();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Class&lt;?&gt;[] getInterfaces() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new Class[]{SeataProxy.class};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="数据源多层代理">数据源多层代理<a href="#数据源多层代理" class="hash-link" aria-label="数据源多层代理的直接链接" title="数据源多层代理的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@DependsOn(&quot;strangeAdapter&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public DataSource druidDataSource(StrangeAdapter strangeAdapter) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    doxx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new DruidDataSource()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Primary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Bean(&quot;dataSource&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public DataSourceProxy dataSource(DataSource druidDataSource) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new DataSourceProxy(druidDataSource);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>首先我们在配置类里面注入了两个<code>DataSource</code>，分别为： <code>DruidDataSource</code>和<code>DataSourceProxy</code>， 其中<code>DruidDataSource 作为 DataSourceProxy 的 targetDataSource 属性</code>，并且<code>DataSourceProxy</code>为使用了<code>@Primary</code>注解声明</li><li>应用默认开启了数据源自动代理，所以在调用<code>DruidDataSource</code>相关方法时，又会为为<code>DruidDataSource</code>创建一个对应的数据源代理<code>DataSourceProxy2</code></li><li>当我们在程序中想获取一个Connection时会发生什么？<ol><li>先获取一个<code>DataSource</code>，因为<code>DataSourceProxy</code>为<code>Primary</code>，所以此时拿到的是<code>DataSourceProxy</code></li><li>基于<code>DataSource</code>获取一个<code>Connection</code>，即通过<code>DataSourceProxy</code>获取<code>Connection</code>。此时会先调用<code>targetDataSource 即 DruidDataSource 的 getConnection 方法</code>，但因为切面会对<code>DruidDataSource</code>进行拦截，根据步骤2的拦截逻辑可以知道，此时会自动创建一个<code>DataSourceProxy2</code>，然后调用<code>DataSourceProxy2#getConnection</code>，然后再调用<code>DruidDataSource#getConnection</code>。最终形成了双层代理， 返回的<code>Connection</code>也是一个双层的<code>ConnectionProxy</code></li></ol></li></ol><p><img loading="lazy" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ac0b91bd8fc4c48aa68afd5c58a42d5~tplv-k3u1fbpfcp-watermark.image" class="img_ev3q"></p><p>上面其实是改造之后的代理逻辑，Seata默认的自动代理会对<code>DataSourceProxy</code>再次进行代理，后果就是代理多了一层此时对应的图如下</p><p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/837aa0462d994e9a8614707c6a50b5ae~tplv-k3u1fbpfcp-watermark.image" class="img_ev3q"></p><p>数据源多层代理会导致的两个问题在文章开头处已经总结了，下面会有案例介绍。</p><h1>分支事务提交</h1><p>通过<code>ConnectionProxy</code>中执行对应的方法，会发生什么？以update操作涉及到的一个分支事务提交为例：</p><ol><li>执行<code>ConnectionProxy#prepareStatement</code>， 返回一个<code>PreparedStatementProxy</code></li><li>执行<code>PreparedStatementProxy#executeUpdate</code>，<code>PreparedStatementProxy#executeUpdate</code>大概会帮做两件事情: 执行业务SQL和提交undo_log</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="提交业务sql">提交业务SQL<a href="#提交业务sql" class="hash-link" aria-label="提交业务SQL的直接链接" title="提交业务SQL的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ExecuteTemplate#execute</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (sqlRecognizers.size() == 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    SQLRecognizer sqlRecognizer = sqlRecognizers.get(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    switch (sqlRecognizer.getSQLType()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case INSERT:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor = EnhancedServiceLoader.load(InsertExecutor.class, dbType,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    new Class[]{StatementProxy.class, StatementCallback.class, SQLRecognizer.class},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    new Object[]{statementProxy, statementCallback, sqlRecognizer});</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case UPDATE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor = new UpdateExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case DELETE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor = new DeleteExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case SELECT_FOR_UPDATE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor = new SelectForUpdateExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor = new PlainExecutor&lt;&gt;(statementProxy, statementCallback);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    executor = new MultiExecutor&lt;&gt;(statementProxy, statementCallback, sqlRecognizers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>主要流程就是： 先执行业务SQL，然后执行ConnectionProxy的commit方法，在这个方法中，会先帮我们执行对应的 undo_log SQL，然后提交事务</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">PreparedStatementProxy#executeUpdate =&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ExecuteTemplate#execute =&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">BaseTransactionalExecutor#execute =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">AbstractDMLBaseExecutor#doExecute =&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">AbstractDMLBaseExecutor#executeAutoCommitTrue =&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">AbstractDMLBaseExecutor#executeAutoCommitFalse =&gt; 在这一步操中，会触发statementCallback#execute方法，即调用调用原生PreparedStatement#executeUpdate方法</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ConnectionProxy#commit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ConnectionProxy#processGlobalTransactionCommit</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="undo_log插入">UNDO_LOG插入<a href="#undo_log插入" class="hash-link" aria-label="UNDO_LOG插入的直接链接" title="UNDO_LOG插入的直接链接">​</a></h2><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// ConnectionProxy#processGlobalTransactionCommit</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">private void processGlobalTransactionCommit() throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 注册分支事务，简单理解向server发一个请求，然后server在branch_table表里插入一条记录，不关注</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        register();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (TransactionException e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果没有for update 的sql,会直接在commit之前做注册,此时不止插入一条branch记录,而会附带锁信息进行竞争,下方的异常一般就是在注册时没拿到锁抛出,一般就是纯update语句的并发下会触发竞争锁失败的异常 @FUNKYE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        recognizeLockKeyConflictException(e, context.buildLockKeys());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // undo_log处理，期望用 targetConnection 处理           @1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        UndoLogManagerFactory.getUndoLogManager(this.getDbType()).flushUndoLogs(this);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 提交本地事务，期望用 targetConnection 处理             @2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        targetConnection.commit();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (Throwable ex) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOGGER.error(&quot;process connectionProxy commit error: {}&quot;, ex.getMessage(), ex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        report(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new SQLException(ex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (IS_REPORT_SUCCESS_ENABLE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        report(true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.reset();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>undo_log处理@1，解析当前事务分支涉及到的<code>undo_log</code>，然后使用<code>TargetConnection</code>， 写到数据库</li></ol><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public void flushUndoLogs(ConnectionProxy cp) throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ConnectionContext connectionContext = cp.getContext();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!connectionContext.hasUndoLog()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    String xid = connectionContext.getXid();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long branchId = connectionContext.getBranchId();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BranchUndoLog branchUndoLog = new BranchUndoLog();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    branchUndoLog.setXid(xid);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    branchUndoLog.setBranchId(branchId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    branchUndoLog.setSqlUndoLogs(connectionContext.getUndoItems());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    UndoLogParser parser = UndoLogParserFactory.getInstance();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    byte[] undoLogContent = parser.encode(branchUndoLog);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (LOGGER.isDebugEnabled()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOGGER.debug(&quot;Flushing UNDO LOG: {}&quot;, new String(undoLogContent, Constants.DEFAULT_CHARSET));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    insertUndoLogWithNormal(xid, branchId, buildContext(parser.getName()), undoLogContent,cp.getTargetConnection());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol start="2"><li>提交本地事务@2，即通过<code>TargetConnection</code>提交事务。即 <code>务SQL执行</code>、<code>undo_log写入</code>、<code>即事务提交</code> 用的都是同一个<code>TargetConnection</code></li></ol><blockquote><p>lcn的内置数据库方案,lcn是将undolog写到他内嵌的h2(忘了是不是这个来着了)数据库上,此时会变成2个本地事务,一个是h2的undolog插入事务,一个是业务数据库的事务,如果在h2插入后,业务数据库异常,lcn的方案就会出现数据冗余,回滚数据的时候也是一样,删除undolog跟回滚业务数据不是一个本地事务.
但是lcn这样的好处就是入侵小,不需要另外添加undolog表。 感谢@FUNKYE大佬给的建议，对lcn不太了解，有机会好好研究一下</p></blockquote><h1>分支事务回滚</h1><ol><li>Server端向Client端发送回滚请求</li><li>Client端接收到Server发过来的请求，经过一系列处理，最终会到<code>DataSourceManager#branchRollback</code>方法</li><li>先根据resourceId从<code>DataSourceManager.dataSourceCache</code>中获取对应的<code>DataSourceProxy</code>，此时为<code>masterSlaveProxy</code>(回滚阶段我们就不考代理数据源问题，简单直接一些，反正最终拿到的都是<code>TragetConnection</code>)</li><li>根据Server端发过来的xid和branchId查找对应的undo_log并解析其<code>rollback_info</code>属性，每条undo_log可能会解析出多条<code>SQLUndoLog</code>,每个<code>SQLUndoLog</code>可以理解成是一个操作。比如一个分支事务先更新A表，再更新B表，这时候针对该分支事务生成的undo_log就包含两个<code>SQLUndoLog</code>：第一个<code>SQLUndoLog</code>对应的是更新A表的前后快照；第二个<code>SQLUndoLog</code>对应的是更新B表的前后快照</li><li>针对每条<code>SQLUndoLog</code>执行对应的回滚操作，比如一个<code>SQLUndoLog</code>对应的操作是<code>INSERT</code>，则其对应的回滚操作就是<code>DELETE</code></li><li>根据xid和branchId删除该undo_log</li></ol><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// AbstractUndoLogManager#undo   删除了部分非关键代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public void undo(DataSourceProxy dataSourceProxy, String xid, long branchId) throws TransactionException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Connection conn = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ResultSet rs = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    PreparedStatement selectPST = null;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean originalAutoCommit = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (; ; ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 获取原生数据源的Connection, 回滚阶段我们不管代理数据源问题，最终拿到的都是 TargetConnection</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            conn = dataSourceProxy.getPlainConnection();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 将回滚操作放在一个本地事务中，手动提交，确保最终业务SQL操作和undo_log删除操作一起提交</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (originalAutoCommit = conn.getAutoCommit()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                conn.setAutoCommit(false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 根据xid 和 branchId 查询 undo_log，注意此时的SQL语句  SELECT * FROM undo_log WHERE branch_id = ? AND xid = ? FOR UPDATE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectPST = conn.prepareStatement(SELECT_UNDO_LOG_SQL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectPST.setLong(1, branchId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectPST.setString(2, xid);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rs = selectPST.executeQuery();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            boolean exists = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (rs.next()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                exists = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // status == 1 undo_log不处理，和防悬挂相关</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (!canUndo(state)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 解析undo_log</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                byte[] rollbackInfo = getRollbackInfo(rs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                BranchUndoLog branchUndoLog = UndoLogParserFactory.getInstance(serializer).decode(rollbackInfo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    setCurrentSerializer(parser.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    List&lt;SQLUndoLog&gt; sqlUndoLogs = branchUndoLog.getSqlUndoLogs();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    if (sqlUndoLogs.size() &gt; 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        Collections.reverse(sqlUndoLogs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    for (SQLUndoLog sqlUndoLog : sqlUndoLogs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        AbstractUndoExecutor undoExecutor = UndoExecutorFactory.getUndoExecutor(dataSourceProxy.getDbType(), sqlUndoLog);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        // 执行对应的回滚操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        undoExecutor.executeOn(conn);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                } </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (exists) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                LOGGER.error(&quot;\n delete from undo_log where xid={} AND branchId={} \n&quot;, xid, branchId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                deleteUndoLog(xid, branchId, conn);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                conn.commit();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 和防悬挂相关 如果根据 xid和branchId 没有查到undo_log，说明这个分支事务有异常：例如业务处理超时，导致全局事务回滚，但这时候业务undo_log并没有插入</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                LOGGER.error(&quot;\n insert into undo_log xid={},branchId={} \n&quot;, xid, branchId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                insertUndoLogWithGlobalFinished(xid, branchId, UndoLogParserFactory.getInstance(), conn);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                conn.commit();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Throwable e) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new BranchTransactionException(BranchRollbackFailed_Retriable, String</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .format(&quot;Branch session rollback failed and try again later xid = %s branchId = %s %s&quot;, xid,branchId, e.getMessage()), e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>有以下几个注意点：</p><ol><li>回滚时不考虑数据源代理问题，最终都是使用<code>TargetConnection</code></li><li>设置atuoCommit为false，即需要手动提交事务</li><li>根据xid和branchId查询undo_log时加了<code>for update</code>，也就是说，这个事务会持有这条undo_log的锁直到所有回滚操作都完成，因为完成之后才会</li></ol><h1>多层代理问题</h1><p>数据源多层代理会导致的几个问题在文章开头的时候已经提到过了，重点分析一下为什么会造成以上问题：</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="对分支事务提交的影响">对分支事务提交的影响<a href="#对分支事务提交的影响" class="hash-link" aria-label="对分支事务提交的影响的直接链接" title="对分支事务提交的影响的直接链接">​</a></h2><p>先分析一下，如果使用双层代理会发生什么？我们从两个方面来分析：<code>业务SQL</code>和<code>undo_log</code></p><ol><li>业务SQL</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">PreparedStatementProxy1.executeUpdate =&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">statementCallback#executeUpdate(PreparedStatementProxy2#executeUpdate) =&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PreparedStatement#executeUpdate</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>好像没啥影响，就是多绕了一圈，最终还是通过<code>PreparedStatement</code>执行</p><ol start="2"><li>undo_log</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ConnectionProxy1#getTargetConnection -&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ConnectionProxy2#prepareStatement -&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PreparedStatementProxy2#executeUpdate -&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PreparedStatement#executeUpdate(原生的undo_log写入，在此之前会对为该 undo_log 生成 undo_log2(即 undo_log 的 undo_log)) -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ConnectionProxy2#commit -&gt; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ConnectionProxy2#processGlobalTransactionCommit(写入undo_log2) -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ConnectionProxy2#getTargetConnection -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TargetConnection#prepareStatement -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PreparedStatement#executeUpdate</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="对分支事务回滚的影响">对分支事务回滚的影响<a href="#对分支事务回滚的影响" class="hash-link" aria-label="对分支事务回滚的影响的直接链接" title="对分支事务回滚的影响的直接链接">​</a></h2><blockquote><p>在事务回滚之后，为何undo_log没有被删除呢？</p></blockquote><p>其实并不是没有被删除。前面已经说过，双层代理会导致<code>undo_log</code>被当作分支事务来处理，所以也会为该 <code>undo_log</code>生成一个undo_log(假设为<code>undo_log2</code>),而<code>undo_log2</code>生成的有问题(其实也没问题，就应该这样生成)，从而导致回滚时会将<code>业务表关联的undo_log</code>也一起删除，最终导致<code>业务表对应的事务分支</code>回滚时发现undo_log不存在，从而又多生成一条状态为为1的undo_log</p><p><strong>回滚之前</strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// undo_log</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">84  59734070967644161   172.16.120.59:23004:59734061438185472 serializer=jackson 1.1KB  0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">85  59734075254222849   172.16.120.59:23004:59734061438185472 serializer=jackson 4.0KB  0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// branch_table</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59734070967644161   172.16.120.59:23004:59734061438185472       jdbc:mysql://172.16.248.10:3306/tuya_middleware</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59734075254222849   172.16.120.59:23004:59734061438185472       jdbc:mysql://172.16.248.10:3306/tuya_middleware</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// lock_table</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">jdbc:mysql://xx^^^seata_storage^^^1 59734070967644161   jdbc:mysql://172.16.248.10:3306/tuya_middleware seata_storage     1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">jdbc:mysql://xx^^^undo_log^^^84     59734075254222849   jdbc:mysql://172.16.248.10:3306/tuya_middleware undo_log          84</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>回滚之后</strong></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 生成了一条状态为1的undo_log，对应的日志为: undo_log added with GlobalFinished</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">86  59734070967644161   172.16.120.59:23004:59734061438185472 serializer=jackson 1.0Byte  1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="问题分析">问题分析<a href="#问题分析" class="hash-link" aria-label="问题分析的直接链接" title="问题分析的直接链接">​</a></h3><ol><li>根据xid和branchId找到对应的undo_log日志</li><li>对undo_log进行解析，主要就是解析它的<code>rollback_info</code>字段，<code>rollback_info</code>解析出来就是一个<code>SQLUndoLog集合</code>，每条<code>SQLUndoLog</code>对应着一个操作，里面包含了该操作的前后的快照，然后执行对应的回滚</li><li>根据xid和branchId删除undo_log日志</li></ol><p>因为双层代理问题，导致一条undo_log变成了一个分支事务，所以发生回滚时，我们也需要对undo_log分支事务进行回滚：
1、首先根据xid和branchId找到对应的<code>undo_log</code>并解析其<code>rollback_info</code>属性，这里解析出来的rollback_info包含了两条<code>SQLUndoLog</code>。为什么有两条？</p><blockquote><p>仔细想想也可以可以理解，第一层代理针对<code>seata_storage</code>的操作，放到缓存中，本来执行完之后是需要清掉的，但因为这里是双层代理，所以这时候这个流程并没有结束。轮到第二层代理对<code>undo_log</code>操作时，将该操作放到缓存中，此时缓存中有两个操作，分别为<code>seata_storage的UPDATE</code> 和 <code>undo_log的INSERT</code>。所以这也就很好理解为什么针对<code>undo_log操作</code>的那条undo_log格外大(4KB)，因为它的<code>rollback_info</code>包含了两个操作。</p></blockquote><p>有一点需要注意的是，第一条<code>SQLUndoLog</code>对应的after快照，里面的branchId=<code>59734070967644161</code> pk=<code>84</code>， 即 <code>seata_storage分支对应的branchId</code>  和 <code>seata_storage对应的undo_log PK</code>。也就是说，undo_log回滚时候 把<code>seata_storage对应的undo_log</code>删掉了。
那undo_log本身对应的undo_log 如何删除呢？在接下来的逻辑中会根据xid和branchId删除</p><p>2、解析第一条<code>SQLUndoLog</code>，此时对应的是<code>undo_log的INSERT</code>操作，所以其对应的回滚操作是<code>DELETE</code>。因为<code>undo_log</code>此时被当作了业务表。所以这一步会将<code>59734075254222849</code>对应的undo_log删除，<strong>但这个其实是业务表对应的对应的<code>undo_log</code></strong></p><p>3、解析第二条<code>SQLUndoLog</code>，此时对应的是<code>seata_storage的UPDATE</code>操作，这时会通过快照将<code>seata_storage</code>对应的记录恢复</p><p>4、根据xid和branchId删除undo_log日志，这里删除的是<code>undo_log 的 undo_log , 即 undo_log2</code>。所以，执行到这里，两条undo_log就已经被删除了</p><p>5、接下来回滚<code>seata_storage</code>，因为这时候它对应的undo_log已经在步骤2删掉了，所以此时查不到undo_log，然后重新生成一条<code>status == 1 的 undo_log</code></p><h1>案例分析</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="背景">背景<a href="#背景" class="hash-link" aria-label="背景的直接链接" title="背景的直接链接">​</a></h2><p>1、配置了三个数据源: 两个物理数据源、一个逻辑数据源，但是两个物理数据源对应的连接地址是一样的。这样做有意思吗？</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Bean(&quot;dsMaster&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DynamicDataSource dsMaster() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new DynamicDataSource(masterDsRoute);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Bean(&quot;dsSlave&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DynamicDataSource dsSlave() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new DynamicDataSource(slaveDsRoute);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Primary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Bean(&quot;masterSlave&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DataSource masterSlave(@Qualifier(&quot;dsMaster&quot;) DataSource dataSourceMaster,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        @Qualifier(&quot;dsSlave&quot;) DataSource dataSourceSlave) throws SQLException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, DataSource&gt; dataSourceMap = new HashMap&lt;&gt;(2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //主库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dataSourceMap.put(&quot;dsMaster&quot;, dataSourceMaster);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    //从库</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dataSourceMap.put(&quot;dsSlave&quot;, dataSourceSlave);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 配置读写分离规则</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    MasterSlaveRuleConfiguration masterSlaveRuleConfig = new MasterSlaveRuleConfiguration(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            &quot;masterSlave&quot;, &quot;dsMaster&quot;, Lists.newArrayList(&quot;dsSlave&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Properties shardingProperties = new Properties();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shardingProperties.setProperty(&quot;sql.show&quot;, &quot;true&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    shardingProperties.setProperty(&quot;sql.simple&quot;, &quot;true&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 获取数据源对象</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DataSource dataSource = MasterSlaveDataSourceFactory.createDataSource(dataSourceMap, masterSlaveRuleConfig, shardingProperties);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.info(&quot;datasource initialized!&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return dataSource;˚</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3e05c8fc0294a8caf4d0883a4676750~tplv-k3u1fbpfcp-watermark.image" class="img_ev3q"></p><p>2、开启seata的数据源动态代理，根据seata的数据源代理逻辑可以知道，最终会生成三个代理数据源，原生数据源和代理数据源的关系缓存在<code>DataSourceProxyHolder.dataSourceProxyMap</code>中，假如原生数据源和代理数据源对应的关系如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dsMaster(DynamicDataSource)           =&gt;       dsMasterProxy(DataSourceProxy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dsSlave(DynamicDataSource)           =&gt;       dsSlaveProxy(DataSourceProxy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">masterSlave(MasterSlaveDataSource)       =&gt;       masterSlaveProxy(DataSourceProxy)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>所以，最终在IOC容器中存在的数据源是这三个： dsMasterProxy 、 dsSlaveProxy 、 masterSlaveProxy 。根据@Primary的特性可以知道，当我们从容器中获取一个DataSource的时候，默认返回的就是代理数据源 masterSlaveProxy</p><blockquote><p>对shardingjdbc没有具体的研究过，只是根据debug时看到的代码猜测它的工作机制，又不对的地方，还请大佬指出来</p></blockquote><p><code>masterSlaveProxy</code>可以看成是<code>被 DataSourceProxy 包装后的 MasterSlaveDataSource</code>。我们可以大胆的猜测<code>MasterSlaveDataSource</code>并不是一个物理数据源，而是一个逻辑数据源，可以简单的认为里面包含了路由的逻辑。当我们获取一个连接时，会通过里面的路由规则选择到具体的物理数据源，然后通过该物理数据源获取一个真实的连接。
路由规则应该可以自己定义，根据debug时观察到的现象，默认的路由规则应该是：</p><ol><li>针对select 读操作，会路由到从库，即我们的 dsSlave</li><li>针对update 写操作，会路由到主库，即我们的 dsMaster</li></ol><p>3、每个DataSourceProxy在初始化的时候，会解析该真实DataSource的连接地址，然后将该<code>连接地址和DataSourceProxy本身</code>维护<code>DataSourceManager.dataSourceCache</code>中。<code>DataSourceManager.dataSourceCache</code>有一个作用是用于回滚：回滚时根据连接地址找到对应的<code>DataSourceProxy</code>,然后基于该<code>DataSourceProxy</code>做回滚操作。
但我们可以发现这个问题，这三个数据源解析出来的连接地址是一样的，也就是key重复了，所以在<code>DataSourceManager.dataSourceCache</code>中中，当连接地相同时，后注册的数据源会覆盖已存在的。即： <code>DataSourceManager.dataSourceCache</code>最终存在的是<code>masterSlaveProxy</code>,也就是说，最终会通过<code>masterSlaveProxy</code>进行回滚，这点很重要。</p><p>4、涉及到的表：很简单，我们期待的就一个业务表<code>seata_account</code>，但因为重复代理问题，导致seata将undo_log也当成了一个业务表</p><ol><li>seata_account</li><li>undo_log</li></ol><p>好了，这里简单介绍一下背景，接下来进入Seata环节</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="需求">需求<a href="#需求" class="hash-link" aria-label="需求的直接链接" title="需求的直接链接">​</a></h2><p>我们的需求很简单，就是在分支事务里面执行一条简单的update操作，更新<code>seata_account</code>的count值。在更新完之后，手动抛出一个异常，触发全局事务的回滚。
为了更便于排查问题，减少干扰，我们全局事务中就使用一个分支事务，没有其它分支事务了。SQL如下:</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">update seata_account set count = count - 1 where id = 100;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="问题现象">问题现象<a href="#问题现象" class="hash-link" aria-label="问题现象的直接链接" title="问题现象的直接链接">​</a></h2><p>Client：在控制台日志中，不断重复打印以下日志</p><ol><li>以上日志打印的间隔为20s，而我查看了数据库的<code>innodb_lock_wait_timeout</code>属性值，刚好就是20，说明每次回滚请求过来的时候，都因为获取锁超时(20)而回滚失败</li><li>为什么会没过20s打印一次？因为Server端会有定时处理回滚请求</li></ol><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// 分支事务开始回滚</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Branch rollback start: 172.16.120.59:23004:59991911632711680 59991915571163137 jdbc:mysql://172.16.248.10:3306/tuya_middleware</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// undo_log事务分支 原始操作对应是 insert, 所以其回滚为 delete</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">undoSQL undoSQL=DELETE FROM undo_log WHERE id = ?  ， PK=[[id,139]] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 因为第一层代理对应的操作也在上下文中，undo_log分支事务 提交时候， 对应的undo_log包含两个操作</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">undoSQL undoSQL=UPDATE seata_account SET money = ? WHERE id = ?  ， PK=[[id,1]] </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 该分支事务回滚完成之后，再删除该分支事务的对应的 undo_log</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">delete from undo_log where xid=172.16.120.59:23004:59991911632711680 AND branchId=59991915571163137 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 抛出异常，提示回滚失败，失败原因是`Lock wait timeout exceeded`， 在根据xid和branchId删除undo_log时失败，失败原因是获取锁超时，说明此时有另一个操作持有该记录的锁没有释放</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">branchRollback failed. branchType:[AT], xid:[172.16.120.59:23004:59991911632711680], branchId:[59991915571163137], resourceId:[jdbc:mysql://172.16.248.10:3306/tuya_middleware], applicationData:[null]. reason:[Branch session rollback failed and try again later xid = 172.16.120.59:23004:59991911632711680 branchId = 59991915571163137 Lock wait timeout exceeded; try restarting transaction]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Server：每20s打印以下日志，说明server在不断的重试发送回滚请求</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Rollback branch transaction fail and will retry, xid = 172.16.120.59:23004:59991911632711680 branchId = 59991915571163137</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在该过程中，涉及到的SQL大概如下：</p><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token number" style="color:#36acaa">1.</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> undo_log </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> branch_id </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> ? </span><span class="token operator" style="color:#393A34">AND</span><span class="token plain"> xid </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> ? </span><span class="token keyword" style="color:#00009f">FOR</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">UPDATE</span><span class="token plain">                            slaveDS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">2.</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> undo_log </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">id </span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">in</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">?</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">                                                     slaveDS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">3.</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">DELETE</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> undo_log </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> id </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> ?                                                                          masterDS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">4.</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> seata_account </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">id </span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">in</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">?</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">                                              masterDS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">5.</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">UPDATE</span><span class="token plain"> seata_account </span><span class="token keyword" style="color:#00009f">SET</span><span class="token plain"> money </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> ? </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> id </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> ?                                                      masterDS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token number" style="color:#36acaa">6.</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">DELETE</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> undo_log </span><span class="token keyword" style="color:#00009f">WHERE</span><span class="token plain"> branch_id </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> ? </span><span class="token operator" style="color:#393A34">AND</span><span class="token plain"> xid </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> ?                                               masterDS</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此时查看数据库的 事务情况、锁情况 、锁等待关系
1、查当前正在执行的事务</p><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> information_schema</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">INNODB_TRX</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d9852b91a9949f781e1f90bffe95fbf~tplv-k3u1fbpfcp-watermark.image" class="img_ev3q"></p><p>2、查当前锁情况</p><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> information_schema</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">INNODB_LOCKs</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a29748a3af34e7c90e3aa7cb78564bc~tplv-k3u1fbpfcp-watermark.image" class="img_ev3q"></p><p>3、查当前锁等待关系</p><div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"> information_schema</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">INNODB_LOCK_waits</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">SELECT</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block_trx</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">trx_mysql_thread_id </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> 已经持有锁的sessionID</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    request_trx</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">trx_mysql_thread_id </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> 正在申请锁的sessionID</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    block_trx</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">trx_query </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> 已经持有锁的</span><span class="token keyword" style="color:#00009f">SQL</span><span class="token plain">语句</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    request_trx</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">trx_query </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> 正在申请锁的</span><span class="token keyword" style="color:#00009f">SQL</span><span class="token plain">语句</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    waits</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">blocking_trx_id </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> 已经持有锁的事务ID</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    waits</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">requesting_trx_id </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> 正在申请锁的事务ID</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    waits</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">requested_lock_id </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> 锁对象的ID</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    locks</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">lock_table </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> lock_table</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">                     </span><span class="token comment" style="color:#999988;font-style:italic">-- 锁对象所锁定的表</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    locks</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">lock_type </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> lock_type</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">                       </span><span class="token comment" style="color:#999988;font-style:italic">-- 锁类型</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    locks</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">lock_mode </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> lock_mode                            </span><span class="token comment" style="color:#999988;font-style:italic">-- 锁模式</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">FROM</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    information_schema</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">innodb_lock_waits </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> waits</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">INNER</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">JOIN</span><span class="token plain"> information_schema</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">innodb_trx </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> block_trx </span><span class="token keyword" style="color:#00009f">ON</span><span class="token plain"> waits</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">blocking_trx_id </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> block_trx</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">trx_id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">INNER</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">JOIN</span><span class="token plain"> information_schema</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">innodb_trx </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> request_trx </span><span class="token keyword" style="color:#00009f">ON</span><span class="token plain"> waits</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">requesting_trx_id </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> request_trx</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">trx_id</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">INNER</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">JOIN</span><span class="token plain"> information_schema</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">innodb_locks </span><span class="token keyword" style="color:#00009f">AS</span><span class="token plain"> locks </span><span class="token keyword" style="color:#00009f">ON</span><span class="token plain"> waits</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">requested_lock_id </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> locks</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">lock_id</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ca5b50cab534a69a49c3e470518e3b6~tplv-k3u1fbpfcp-watermark.image" class="img_ev3q"></p><ol><li>涉及到到记录为 <code>branch_id = 59991915571163137 AND xid = 172.16.120.59:23004:59991911632711680</code></li><li>事务ID<code>1539483284</code>持有该记录的锁，但是它对应的SQL为空，那应该是在等待commit</li><li>事务ID<code>1539483286</code>在尝试获取该记录的锁，但从日志可以发现，它一直锁等待超时</li></ol><p>大概可以猜测是 <code>select for update</code> 和 <code>delete from undo ...</code> 发生了冲突。根据代码中的逻辑，这两个操作应该是放在一个事务中提交了，为什么被分开到两个事务了？</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="问题分析-1">问题分析<a href="#问题分析-1" class="hash-link" aria-label="问题分析的直接链接" title="问题分析的直接链接">​</a></h2><p>结合上面的介绍的回滚流程看看我们这个例子在回滚时会发生什么</p><ol><li>先获取数据源，此时dataSourceProxy.getPlainConnection()获取到的是<code>MasterSlaveDataSource</code>数据源</li><li>在<code>select for update</code>操作的时候，通过<code>MasterSlaveDataSource</code>获取一个<code>Connection</code>，前面说到过<code>MasterSlaveDataSource</code>是一个逻辑数据源，里面有路由逻辑，根据上面介绍的，这时候拿到的是<code>dsSlave</code>的<code>Connection</code></li><li>在执行<code>delete from undo ...</code>操作的时候，这时候拿到的是<code>dsMaster</code>的<code>Connection</code></li><li>虽然<code>dsSlave</code>和<code>dsMaster</code>对应的是相同的地址，但此时获取到的肯定是不同的连接，所以此时两个操作肯定是分布在两个事务中</li><li>执行<code>select for update</code>的事务，会一直等待直到删除undo_log完成才会提交</li><li>执行<code>delete from undo ...</code>的事务，会一直等待<code>select for update</code>的事务释放锁</li><li>典型的死锁问题</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="验证猜想">验证猜想<a href="#验证猜想" class="hash-link" aria-label="验证猜想的直接链接" title="验证猜想的直接链接">​</a></h2><p>我尝试用了两个方法验证这个问题：</p><ol><li>修改Seata代码，将<code>select for update</code>改成<code>select</code>，此时在查询undo_log就不需要持有该记录的锁，也就不会造成死锁</li></ol><ol start="2"><li>修改数据源代理逻辑，这才是问题的关键，该问题主要原因不是<code>select for update</code>。在此之前多层代理问题已经产生，然后才会造成死锁问题。从头到尾我们就不应该对<code>masterSlave</code>数据源进行代理。它只是一个逻辑数据源，为什么要对它进行代理呢？如果代理<code>masterSlave</code>，就不会造成多层代理问题，也就不会造成删除undo_log时的死锁问题</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="最终实现">最终实现<a href="#最终实现" class="hash-link" aria-label="最终实现的直接链接" title="最终实现的直接链接">​</a></h2><p><code>masterSlave</code>也是一个<code>DataSource</code>类型，该如何仅仅对<code>dsMaster</code> 和 <code>dsSlave</code> 代理而不对<code>masterSlave</code>代理呢？观察<code>SeataAutoDataSourceProxyCreator#shouldSkip</code>方法，我们可以通过EnableAutoDataSourceProxy注解的<code>excludes</code>属性解决这个问题</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">protected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return SeataProxy.class.isAssignableFrom(beanClass) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            DataSourceProxy.class.isAssignableFrom(beanClass) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            !DataSource.class.isAssignableFrom(beanClass) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            Arrays.asList(excludes).contains(beanClass.getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>即: 将数据源自动代理关闭，然后在启动类加上这个注解</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@EnableAutoDataSourceProxy(excludes = {&quot;org.apache.shardingsphere.shardingjdbc.jdbc.core.datasource.MasterSlaveDataSource&quot;})</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>自动代理在新版本中的优化</h1><p>因为<code>Seata 1.4.0</code>还没有正式发布，我目前看的是<code>1.4.0-SNAPSHOT</code>版本的代码，即当前时间<code>ddevelop</code>分支最新的代码</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="代码改动">代码改动<a href="#代码改动" class="hash-link" aria-label="代码改动的直接链接" title="代码改动的直接链接">​</a></h2><p>主要改动如下，一些小的细节就不过多说明了：</p><ol><li><code>DataSourceProxyHolder</code>调整</li><li><code>DataSourceProxy</code>调整</li><li><code>SeataDataSourceBeanPostProcessor</code>新增</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="datasourceproxyholder">DataSourceProxyHolder<a href="#datasourceproxyholder" class="hash-link" aria-label="DataSourceProxyHolder的直接链接" title="DataSourceProxyHolder的直接链接">​</a></h3><p>在这个类改动中，最主要是其<code>putDataSource</code>方法的改动</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public SeataDataSourceProxy putDataSource(DataSource dataSource, BranchType dataSourceProxyMode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    DataSource originalDataSource;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (dataSource instanceof SeataDataSourceProxy) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SeataDataSourceProxy dataSourceProxy = (SeataDataSourceProxy) dataSource;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果是代理数据源，并且和当前应用配置的数据源代理模式(AT/XA)一样, 则直接返回</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (dataSourceProxyMode == dataSourceProxy.getBranchType()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            return (SeataDataSourceProxy)dataSource;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果是代理数据源，和当前应用配置的数据源代理模式(AT/XA)不一样，则需要获取其TargetDataSource,然后为其创建一个代理数据源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        originalDataSource = dataSourceProxy.getTargetDataSource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        originalDataSource = dataSource;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果有必要，基于 TargetDataSource 创建 代理数据源</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return this.dataSourceProxyMap.computeIfAbsent(originalDataSource,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            BranchType.XA == dataSourceProxyMode ? DataSourceProxyXA::new : DataSourceProxy::new);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>DataSourceProxyHolder#putDataSource</code>方法主要在两个地方被用到：一个是在<code>SeataAutoDataSourceProxyAdvice</code>切面中；一个是在<code>SeataDataSourceBeanPostProcessor</code>中。
这段判断为我们解决了什么问题？数据源多层代理问题。在开启了数据源自动代理的前提下，思考以下场景：</p><ol><li>如果我们在项目中手动注入了一个<code>DataSourceProxy</code>，这时候在切面调用<code>DataSourceProxyHolder#putDataSource</code>方法时会直接返回该<code>DataSourceProxy</code>本身，而不会为其再创建一个<code>DataSourceProxy</code></li><li>如果我们在项目中手动注入了一个<code>DruidSource</code>，这时候在切面调用<code>DataSourceProxyHolder#putDataSource</code>方法时会为其再创建一个<code>DataSourceProxy</code>并返回</li></ol><p>这样看好像问题已经解决了，有没有可能会有其它的问题呢？看看下面的代码</p><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public DataSourceProxy dsA(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new DataSourceProxy(druidA)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@Bean</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">public DataSourceProxy dsB(DataSourceProxy dsA){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new DataSourceProxy(dsA)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li>这样写肯定是不对，但如果他就要这样写你也没办法</li><li><code>dsA</code>没什么问题，但<code>dsB</code>还是会产生双层代理的问题，因为此时<code>dsB 的 TargetDataSource</code>是<code>dsA</code></li><li>这就涉及到<code>DataSourceProxy</code>的改动</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="datasourceproxy">DataSourceProxy<a href="#datasourceproxy" class="hash-link" aria-label="DataSourceProxy的直接链接" title="DataSourceProxy的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public DataSourceProxy(DataSource targetDataSource, String resourceGroupId) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 下面这个判断，保证了在我们传入一个DataSourceProxy的时候，也不会产生双层代理问题</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (targetDataSource instanceof SeataDataSourceProxy) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOGGER.info(&quot;Unwrap the target data source, because the type is: {}&quot;, targetDataSource.getClass().getName());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        targetDataSource = ((SeataDataSourceProxy) targetDataSource).getTargetDataSource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.targetDataSource = targetDataSource;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    init(targetDataSource, resourceGroupId);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="seatadatasourcebeanpostprocessor">SeataDataSourceBeanPostProcessor<a href="#seatadatasourcebeanpostprocessor" class="hash-link" aria-label="SeataDataSourceBeanPostProcessor的直接链接" title="SeataDataSourceBeanPostProcessor的直接链接">​</a></h3><div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">public class SeataDataSourceBeanPostProcessor implements BeanPostProcessor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Logger LOGGER = LoggerFactory.getLogger(SeataDataSourceBeanPostProcessor.class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ......</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (bean instanceof DataSource) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //When not in the excludes, put and init proxy.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!excludes.contains(bean.getClass().getName())) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                //Only put and init proxy, not return proxy.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                DataSourceProxyHolder.get().putDataSource((DataSource) bean, dataSourceProxyMode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            //If is SeataDataSourceProxy, return the original data source.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (bean instanceof SeataDataSourceProxy) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                LOGGER.info(&quot;Unwrap the bean of the data source,&quot; +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    &quot; and return the original data source to replace the data source proxy.&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return ((SeataDataSourceProxy) bean).getTargetDataSource();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return bean;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ol><li><code>SeataDataSourceBeanPostProcessor</code>实现了<code>BeanPostProcessor</code>接口，在一个bean初始化后，会执行<code>BeanPostProcessor#postProcessAfterInitialization</code>方法。也就是说，在<code>postProcessAfterInitialization</code>方法中，这时候的bean已经是可用状态了</li><li>为什么要提供这么一个类呢？从它的代码上来看，仅仅是为了再bean初始化之后，为数据源初始化对应的<code>DataSourceProxy</code>，但为什么要这样做呢？<blockquote><p>因为有些数据源在应用启动之后，可能并不会初始化(即不会调用数据源的相关方法)。如果没有提供<code>SeataDataSourceBeanPostProcessor</code>类，那么就只有在<code>SeataAutoDataSourceProxyAdvice</code>切面中才会触发<code>DataSourceProxyHolder#putDataSource</code>方法。假如有一个客户端在回滚的时候宕机了，在重启之后，Server端通过定时任务向其派发回滚请求，这时候客户端需要先根据<code>rsourceId</code>(连接地址)找到对应的<code>DatasourceProxy</code>。但如果在此之前客户端还没有主动触发数据源的相关方法，就不会进入<code>SeataAutoDataSourceProxyAdvice</code>切面逻辑，也就不会为该数据源初始化对应的<code>DataSourceProxy</code>，从而导致回滚失败</p></blockquote></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="多层代理总结">多层代理总结<a href="#多层代理总结" class="hash-link" aria-label="多层代理总结的直接链接" title="多层代理总结的直接链接">​</a></h2><p>通过上面的分析，我们大概已经知道了seata在避免多层代理上的一些优化，但其实还有一个问题需要注意：<strong>逻辑数据源的代理</strong>
<img loading="lazy" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6910095aadab436eaffe03a752e44240~tplv-k3u1fbpfcp-watermark.image" class="img_ev3q"></p><p>这时候的调用关系为： <code>masterSlaveProxy -&gt;　masterSlave -&gt;  masterproxy/slaveProxy -&gt;  master/slave</code></p><p>此时可以通过<code>excludes</code>属性排除逻辑数据源，从而不为其创建数据源代理。</p><p>总结一下：</p><ol><li>在为<code>数据源</code>初始化对应的<code>DataSourceProxy</code>时，判断是否有必要为其创建对应的<code>DataSourceProxy</code>，如果本身就是<code>DataSourceProxy</code>，就直接返回</li><li>针对一些<code>数据源</code>手动注入的情况，为了避免一些人为误操作的导致的多层代理问题，在<code>DataSourceProxy</code>构造函数中添加了判断，<code>如果入参TragetDatasource本身就是一个DataSourceProxy， 则获取其target属性作为新DataSourceProxy的tragetDatasource</code></li><li>针对一些其它情况，比如<strong>逻辑数据源代理问题</strong>，通过<code>excludes</code>属性添加排除项，这样可以避免为逻辑数据源创建<code>DataSourceProxy</code></li></ol><h1>全局事务和本地事务使用建议</h1><p>有一个问题，如果在一个方法里涉及到多个DB操作，比如涉及到3条update操作，我们需不需在这个方法使用spring中的<code>@Transactional</code>注解？针对这个问题，我们分别从两个角度考虑：不使用<code>@Transactional</code>注解 和 使用<code>@Transactional</code>注解</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="不使用transactional注解">不使用<code>@Transactional</code>注解<a href="#不使用transactional注解" class="hash-link" aria-label="不使用transactional注解的直接链接" title="不使用transactional注解的直接链接">​</a></h2><ol><li>在提交阶段，因为该分支事务有3条update操作，每次执行update操作的时候，都会通过数据代理向TC注册一个分支事务，并为其生成对应的undo_log，最终3个update操作被当作3个分支事务来处理</li><li>在回滚阶段，需要回滚3个分支事务</li><li>数据的一致性通过seata全局事务来保证</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="使用transactional注解">使用<code>@Transactional</code>注解<a href="#使用transactional注解" class="hash-link" aria-label="使用transactional注解的直接链接" title="使用transactional注解的直接链接">​</a></h2><ol><li>在提交阶段，3个update操作被当作一个分支事务来提交，所以最终只会注册一个分支事务</li><li>在回滚阶段，需要回滚1个分支事务</li><li>数据的一致性：这3个update的操作通过本地事务的一致性保证；全局一致性由seata全局事务来保证。此时3个update仅仅是一个分支事务而已</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="结论">结论<a href="#结论" class="hash-link" aria-label="结论的直接链接" title="结论的直接链接">​</a></h2><p>通过上面的对比，答案是显而易见的，合理的使用本地事务，可以大大的提升全局事务的处理速度。上面仅仅是3个DB操作，如果一个方法里面涉及到的DB操作更多呢，这时候两种方式的差别是不是更大呢？</p><p>最后，感谢@FUNKYE大佬为我解答了很多问题并提供了宝贵建议！</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/zh-cn/blog/seata-golang-communication-mode"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">seata-golang 通信模型详解</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/zh-cn/blog/seata-sourcecode-client-bootstrap"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">分布式事务Seata源码-Client端启动流程</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#代理描述" class="table-of-contents__link toc-highlight">代理描述</a></li><li><a href="#手动代理" class="table-of-contents__link toc-highlight">手动代理</a></li><li><a href="#自动代理" class="table-of-contents__link toc-highlight">自动代理</a></li><li><a href="#数据源多层代理" class="table-of-contents__link toc-highlight">数据源多层代理</a></li><li><a href="#提交业务sql" class="table-of-contents__link toc-highlight">提交业务SQL</a></li><li><a href="#undo_log插入" class="table-of-contents__link toc-highlight">UNDO_LOG插入</a></li><li><a href="#对分支事务提交的影响" class="table-of-contents__link toc-highlight">对分支事务提交的影响</a></li><li><a href="#对分支事务回滚的影响" class="table-of-contents__link toc-highlight">对分支事务回滚的影响</a><ul><li><a href="#问题分析" class="table-of-contents__link toc-highlight">问题分析</a></li></ul></li><li><a href="#背景" class="table-of-contents__link toc-highlight">背景</a></li><li><a href="#需求" class="table-of-contents__link toc-highlight">需求</a></li><li><a href="#问题现象" class="table-of-contents__link toc-highlight">问题现象</a></li><li><a href="#问题分析-1" class="table-of-contents__link toc-highlight">问题分析</a></li><li><a href="#验证猜想" class="table-of-contents__link toc-highlight">验证猜想</a></li><li><a href="#最终实现" class="table-of-contents__link toc-highlight">最终实现</a></li><li><a href="#代码改动" class="table-of-contents__link toc-highlight">代码改动</a><ul><li><a href="#datasourceproxyholder" class="table-of-contents__link toc-highlight">DataSourceProxyHolder</a></li><li><a href="#datasourceproxy" class="table-of-contents__link toc-highlight">DataSourceProxy</a></li><li><a href="#seatadatasourcebeanpostprocessor" class="table-of-contents__link toc-highlight">SeataDataSourceBeanPostProcessor</a></li></ul></li><li><a href="#多层代理总结" class="table-of-contents__link toc-highlight">多层代理总结</a></li><li><a href="#不使用transactional注解" class="table-of-contents__link toc-highlight">不使用<code>@Transactional</code>注解</a></li><li><a href="#使用transactional注解" class="table-of-contents__link toc-highlight">使用<code>@Transactional</code>注解</a></li><li><a href="#结论" class="table-of-contents__link toc-highlight">结论</a></li></ul></div></div></div></div></div></div>
<script src="/zh-cn/assets/js/runtime~main.b56bbcbc.js"></script>
<script src="/zh-cn/assets/js/main.23eb4378.js"></script>
</body>
</html>