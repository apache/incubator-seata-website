{
  "filename": "seata-feature-undo-log-compress.md",
  "__html": "<h1>Seata新特性支持 -- undo_log压缩</h1>\n<h3>现状 &amp; 痛点</h3>\n<p>对于Seata而言，是通过记录DML操作的前后的数据用于进行后续可能的回滚操作的，并且把这些数据保存到数据库的一个blob的字段里面。对于批量插入，更新，删除等操作，其影响的行数可能会比较多，拼接成一个大的字段插入到数据库，可能会带来以下问题：</p>\n<ol>\n<li>超出数据库单次操作的最大写入限制(比如MySQL的max_allowed_package参数)；</li>\n<li>较大的数据量带来的网络IO和数据库磁盘IO开销比较大。</li>\n</ol>\n<h3>头脑风暴</h3>\n<p>对于第1点的问题，可以根据业务的实际情况，调大max_allowed_package参数的限制，从而避免出现query is too large的问题；对于第2点，可以通过提高带宽和选用高性能的SSD作为数据库的存储介质。</p>\n<p>以上都是通过外部方案或者加钱方案去解决的。那么有没有框架层面解决方案以解决上面的痛点？</p>\n<p>此时结合到以上的痛点出现的根源，在于生成的数据字段过大。为此，如果可以把对应的数据进行业务方压缩之后，再进行数据传输以及落库，理论上也可以解决上面的问题。</p>\n<h3>可行性分析</h3>\n<p>结合以上头脑风暴的内容，考虑在实际开发中，当需要进行大批量操作的时候，大多会选在较少用户操作，并发相对较低的时间点执行，此时CPU，内存等资源可以相对占用多一点以快速完成对应的操作。因此，可以通过消耗CPU资源和内存资源，来对对应的回滚的数据进行压缩，从而缩小数据传输和存储的大小。</p>\n<p>此时，还需要证明以下两件事：</p>\n<ol>\n<li>经过压缩之后，可以减少网络IO和数据库磁盘IO的压力，这里可以采用数据压缩+落库完成的总时间作为侧面参考指标。</li>\n<li>经过压缩之后，数据大小跟原来比较的压缩效率有多高，这里使用压缩前后的数据大小来作为指标。</li>\n</ol>\n<p>压缩网络用时指标测试：</p>\n<p><img src=\"https://user-images.githubusercontent.com/22959373/95567752-f55ddf80-0a55-11eb-8092-1f1d99855bdd.png\" alt=\"image\"></p>\n<p>压缩比测试：</p>\n<p><img src=\"https://user-images.githubusercontent.com/22959373/95567834-0ad30980-0a56-11eb-9d7e-48b74babbea4.png\" alt=\"image\"></p>\n<p>通过以上的测试结果，可以明显的看出，使用gzip或zip进行压缩的情况下，可以较大程度的减少数据库的压力和网络传输的压力，同时也可以较大幅度的减少保存的数据的大小。</p>\n<h3>实现</h3>\n<h4>实现思路</h4>\n<p><img src=\"https://user-images.githubusercontent.com/22959373/116281711-8f039900-a7bc-11eb-91f8-82afdbb9f932.png\" alt=\"压缩\"></p>\n<h4>部分代码</h4>\n<p>properties配置：</p>\n<pre><code class=\"language-properties\"><span class=\"hljs-comment\"># 是否开启undo_log压缩，默认为true</span>\n<span class=\"hljs-meta\">seata.client.undo.compress.enable</span>=<span class=\"hljs-string\">true</span>\n<span class=\"hljs-comment\"># 压缩器类型，默认为zip，一般建议都是zip</span>\n<span class=\"hljs-meta\">seata.client.undo.compress.type</span>=<span class=\"hljs-string\">zip</span>\n<span class=\"hljs-comment\"># 启动压缩的阈值，默认为64k</span>\n<span class=\"hljs-meta\">seata.client.undo.compress.threshold</span>=<span class=\"hljs-string\">64k</span>\n</code></pre>\n<p>判断是否开启了undo_log压缩功能以及是否达到压缩的阈值：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">needCompress</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">byte</span>[] undoLogContent)</span> </span>{\n    <span class=\"hljs-comment\">// 1. 判断是否开启了undo_log压缩功能(1.4.2默认开启)</span>\n    <span class=\"hljs-comment\">// 2. 判断是否达到了压缩的阈值(默认64k)</span>\n    <span class=\"hljs-comment\">// 如果都满足返回需要对对应的undoLogContent进行压缩</span>\n    <span class=\"hljs-keyword\">return</span> ROLLBACK_INFO_COMPRESS_ENABLE \n        &amp;&amp; undoLogContent.length &gt; ROLLBACK_INFO_COMPRESS_THRESHOLD;\n}\n</code></pre>\n<p>确定需要压缩后，对undo_log进行压缩：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 如果需要压缩，对undo_log进行压缩</span>\n<span class=\"hljs-keyword\">if</span> (needCompress(undoLogContent)) {\n    <span class=\"hljs-comment\">// 获取压缩类型，默认zip</span>\n    compressorType = ROLLBACK_INFO_COMPRESS_TYPE;\n    <span class=\"hljs-comment\">// 获取对应的压缩器，并且进行压缩</span>\n    undoLogContent = CompressorFactory.getCompressor(compressorType.getCode()).compress(undoLogContent);\n}\n<span class=\"hljs-comment\">// else 不需要压缩就不需要做任何操作</span>\n</code></pre>\n<p>将压缩类型同步保存到数据库，供回滚时使用：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> String <span class=\"hljs-title\">buildContext</span><span class=\"hljs-params\">(String serializer, CompressorType compressorType)</span> </span>{\n    Map&lt;String, String&gt; map = <span class=\"hljs-keyword\">new</span> HashMap&lt;&gt;();\n    map.put(UndoLogConstants.SERIALIZER_KEY, serializer);\n    <span class=\"hljs-comment\">// 保存压缩类型到数据库</span>\n    map.put(UndoLogConstants.COMPRESSOR_TYPE_KEY, compressorType.name());\n    <span class=\"hljs-keyword\">return</span> CollectionUtils.encodeMap(map);\n}\n</code></pre>\n<p>回滚时解压缩对应的信息：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">byte</span>[] getRollbackInfo(ResultSet rs) <span class=\"hljs-keyword\">throws</span> SQLException  {\n    <span class=\"hljs-comment\">// 获取保存到数据库的回滚信息的字节数组</span>\n    <span class=\"hljs-keyword\">byte</span>[] rollbackInfo = rs.getBytes(ClientTableColumnsName.UNDO_LOG_ROLLBACK_INFO);\n    <span class=\"hljs-comment\">// 获取压缩类型</span>\n    <span class=\"hljs-comment\">// getOrDefault使用默认值CompressorType.NONE来兼容1.4.2之前的版本直接升级1.4.2+</span>\n    String rollbackInfoContext = rs.getString(ClientTableColumnsName.UNDO_LOG_CONTEXT);\n    Map&lt;String, String&gt; context = CollectionUtils.decodeMap(rollbackInfoContext);\n    CompressorType compressorType = CompressorType.getByName(context.getOrDefault(UndoLogConstants.COMPRESSOR_TYPE_KEY,\n    CompressorType.NONE.name()));\n    <span class=\"hljs-comment\">// 获取对应的压缩器，并且解压缩</span>\n    <span class=\"hljs-keyword\">return</span> CompressorFactory.getCompressor(compressorType.getCode())\n        .decompress(rollbackInfo);\n}\n</code></pre>\n<h3>结语</h3>\n<p>通过对undo_log的压缩，在框架层面，进一步提高Seata在处理数据量较大的时候的性能。同时，也提供了对应的开关和相对合理的默认值，既方便用户进行开箱即用，也方便用户根据实际需求进行一定的调整，使得对应的功能更适合实际使用场景。</p>\n",
  "link": "/zh-cn/blog/seata-feature-undo-log-compress.html",
  "meta": {
    "title": "Seata新特性支持 -- undo_log压缩",
    "author": "chd",
    "keywords": "Seata, undo_log, compress",
    "date": "2021/05/07"
  }
}