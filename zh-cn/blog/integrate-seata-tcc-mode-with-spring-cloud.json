{
  "filename": "integrate-seata-tcc-mode-with-spring-cloud.md",
  "__html": "<h1>Spring Cloud集成Seata分布式事务-TCC模式</h1>\n<p>本文将介绍基于Spring Cloud + feign 如何集成 Seata(1.4.0)的TCC模式。实际上，Seata的AT模式基本上能满足我们使用分布式事务80%的需求，但涉及不支持事务的数据库与中间件（如redis）等的操作，或AT模式暂未支持的数据库（目前AT支持Mysql、Oracle与PostgreSQL）、跨公司服务的调用、跨语言的应用调用或有手动控制整个二阶段提交过程的需求，则需要结合TCC模式。不仅如此，TCC模式还支持与AT模式混合使用。</p>\n<p>本文作者：弓行（谭志坚）</p>\n<h1>一、TCC模式的概念</h1>\n<p>一个分布式的全局事务，整体是两阶段提交<strong>Try-[Comfirm/Cancel]</strong> 的模型。在Seata中，AT模式与TCC模式事实上都是两阶段提交的具体实现。他们的区别在于：</p>\n<p>AT 模式基于<strong>支持本地 ACID 事务</strong> 的 <strong>关系型数据库</strong>（目前支持Mysql、Oracle与PostgreSQL）：</p>\n<p>一阶段 prepare 行为：在本地事务中，一并提交业务数据更新和相应回滚日志记录。\n二阶段 commit 行为：马上成功结束，<strong>自动</strong>异步批量清理回滚日志。\n二阶段 rollback 行为：通过回滚日志，<strong>自动</strong>生成补偿操作，完成数据回滚。</p>\n<p>相应的，TCC 模式，不依赖于底层数据资源的事务支持：</p>\n<p>一阶段 prepare 行为：调用 自定义 的 prepare 逻辑。\n二阶段 commit 行为：调用 <strong>自定义</strong>的 commit 逻辑。\n二阶段 rollback 行为：调用 <strong>自定义</strong>的 rollback 逻辑。</p>\n<p>所谓 TCC 模式，是指支持把 <strong>自定义</strong> 的分支事务纳入到全局事务的管理中。</p>\n<p>简单点概括，SEATA的TCC模式就是<strong>手工的AT模式</strong>，它允许你自定义两阶段的处理逻辑而不依赖AT模式的undo_log。</p>\n<h1>二、前提准备</h1>\n<ul>\n<li>注册中心 <a href=\"https://nacos.io/zh-cn/\" title=\"nacos\">nacos</a></li>\n<li><a href=\"http://seata.io/zh-cn/docs/ops/deploy-guide-beginner.html\" title=\"seata服务端(TC）\">seata服务端(TC）</a></li>\n</ul>\n<h1>三、TM与TCC-RM的搭建</h1>\n<p>本章着重讲基于Spring Cloud + Feign的TCC的实现，项目的搭建直接看源码(本工程提供了AT模式与TCC模式的DEMO)</p>\n<p><a href=\"https://github.com/tanzzj/springcloud-seata-feign\" title=\"服务端搭建文档\">DEMO工程源码</a></p>\n<h2>3.1 seata服务端的搭建</h2>\n<p><a href=\"http://seata.io/zh-cn/docs/ops/deploy-guide-beginner.html\" title=\"服务端搭建文档\">服务端搭建文档</a></p>\n<h2>3.2 TM的搭建</h2>\n<p><a href=\"https://github.com/tanzzj/springcloud-seata-feign/tree/master/service-tm\">service-tm</a></p>\n<h2>3.3 RM-TCC的搭建</h2>\n<h3>3.3.1 定义TCC接口</h3>\n<p>由于我们使用的是 SpringCloud + Feign，Feign的调用基于http，因此此处我们使用<code>@LocalTCC</code>便可。值得注意的是，<code>@LocalTCC</code>一定需要注解在接口上，此接口可以是寻常的业务接口，只要实现了TCC的两阶段提交对应方法便可，TCC相关注解如下：</p>\n<ul>\n<li><code>@LocalTCC</code> 适用于SpringCloud+Feign模式下的TCC</li>\n<li><code>@TwoPhaseBusinessAction</code> 注解try方法，其中name为当前tcc方法的bean名称，写方法名便可（全局唯一），commitMethod指向提交方法，rollbackMethod指向事务回滚方法。指定好三个方法之后，seata会根据全局事务的成功或失败，去帮我们自动调用提交方法或者回滚方法。</li>\n<li><code>@BusinessActionContextParameter</code> 注解可以将参数传递到二阶段（commitMethod/rollbackMethod）的方法。</li>\n<li><code>BusinessActionContext</code> 便是指TCC事务上下文</li>\n</ul>\n<p>实例如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n * 这里定义tcc的接口\n * 一定要定义在接口上\n * 我们使用springCloud的远程调用\n * 那么这里使用LocalTCC便可\n *\n * <span class=\"hljs-doctag\">@author</span> tanzj\n */</span>\n<span class=\"hljs-meta\">@LocalTCC</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">TccService</span> </span>{\n \n    <span class=\"hljs-comment\">/**\n     * 定义两阶段提交\n     * name = 该tcc的bean名称,全局唯一\n     * commitMethod = commit 为二阶段确认方法\n     * rollbackMethod = rollback 为二阶段取消方法\n     * BusinessActionContextParameter注解 传递参数到二阶段中\n     *\n     * <span class=\"hljs-doctag\">@param</span> params  -入参\n     * <span class=\"hljs-doctag\">@return</span> String\n     */</span>\n    <span class=\"hljs-meta\">@TwoPhaseBusinessAction</span>(name = <span class=\"hljs-string\">\"insert\"</span>, commitMethod = <span class=\"hljs-string\">\"commitTcc\"</span>, rollbackMethod = <span class=\"hljs-string\">\"cancel\"</span>)\n    <span class=\"hljs-function\">String <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(\n            @BusinessActionContextParameter(paramName = <span class=\"hljs-string\">\"params\"</span>)</span> Map&lt;String, String&gt; params\n    )</span>;\n \n    <span class=\"hljs-comment\">/**\n     * 确认方法、可以另命名，但要保证与commitMethod一致\n     * context可以传递try方法的参数\n     *\n     * <span class=\"hljs-doctag\">@param</span> context 上下文\n     * <span class=\"hljs-doctag\">@return</span> boolean\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">commitTcc</span><span class=\"hljs-params\">(BusinessActionContext context)</span></span>;\n \n    <span class=\"hljs-comment\">/**\n     * 二阶段取消方法\n     *\n     * <span class=\"hljs-doctag\">@param</span> context 上下文\n     * <span class=\"hljs-doctag\">@return</span> boolean\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">cancel</span><span class=\"hljs-params\">(BusinessActionContext context)</span></span>;\n}\n</code></pre>\n<h3>3.3.2 TCC接口的业务实现</h3>\n<p>为了保证代码的简洁，此处将路由层与业务层结合讲解，实际项目则不然。</p>\n<ul>\n<li>在try方法中使用<code>@Transational</code>可以直接通过spring事务回滚关系型数据库中的操作，而非关系型数据库等中间件的回滚操作可以交给rollbackMethod方法处理。</li>\n<li>使用context.getActionContext(&quot;params&quot;)便可以得到一阶段try中定义的参数，在二阶段对此参数进行业务回滚操作。</li>\n<li>**注意1：**此处亦不可以捕获异常（同理切面处理异常），否则TCC将识别该操作为成功，二阶段直接执行commitMethod。</li>\n<li><strong>注意2：<strong>TCC模式要</strong>开发者自行</strong>保证幂等和事务防悬挂</li>\n</ul>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Slf</span>4j\n<span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TccServiceImpl</span> <span class=\"hljs-keyword\">implements</span>  <span class=\"hljs-title\">TccService</span> </span>{\n \n    <span class=\"hljs-meta\">@Autowired</span>\n    TccDAO tccDAO;\n \n    <span class=\"hljs-comment\">/**\n     * tcc服务t（try）方法\n     * 根据实际业务场景选择实际业务执行逻辑或者资源预留逻辑\n     *\n     * <span class=\"hljs-doctag\">@param</span> params - name\n     * <span class=\"hljs-doctag\">@return</span> String\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-meta\">@PostMapping</span>(<span class=\"hljs-string\">\"/tcc-insert\"</span>)\n    <span class=\"hljs-meta\">@Transactional</span>(rollbackFor = Exception.class, propagation = Propagation.REQUIRED)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(@RequestBody Map&lt;String, String&gt; params)</span> </span>{\n        log.info(<span class=\"hljs-string\">\"xid = \"</span> + RootContext.getXID());\n        <span class=\"hljs-comment\">//todo 实际的操作，或操作MQ、redis等</span>\n        tccDAO.insert(params);\n        <span class=\"hljs-comment\">//放开以下注解抛出异常</span>\n        <span class=\"hljs-comment\">//throw new RuntimeException(\"服务tcc测试回滚\");</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"success\"</span>;\n    }\n \n    <span class=\"hljs-comment\">/**\n     * tcc服务 confirm方法\n     * 若一阶段采用资源预留，在二阶段确认时要提交预留的资源\n     *\n     * <span class=\"hljs-doctag\">@param</span> context 上下文\n     * <span class=\"hljs-doctag\">@return</span> boolean\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">commitTcc</span><span class=\"hljs-params\">(BusinessActionContext context)</span> </span>{\n        log.info(<span class=\"hljs-string\">\"xid = \"</span> + context.getXid() + <span class=\"hljs-string\">\"提交成功\"</span>);\n        <span class=\"hljs-comment\">//todo 若一阶段资源预留，这里则要提交资源</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n \n    <span class=\"hljs-comment\">/**\n     * tcc 服务 cancel方法\n     *\n     * <span class=\"hljs-doctag\">@param</span> context 上下文\n     * <span class=\"hljs-doctag\">@return</span> boolean\n     */</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">cancel</span><span class=\"hljs-params\">(BusinessActionContext context)</span> </span>{\n        <span class=\"hljs-comment\">//todo 这里写中间件、非关系型数据库的回滚操作</span>\n        System.out.println(<span class=\"hljs-string\">\"please manually rollback this data:\"</span> + context.getActionContext(<span class=\"hljs-string\">\"params\"</span>));\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n}\n</code></pre>\n<h3>3.3.3 在TM中开启全局事务，调用RM-TCC接口</h3>\n<p>工程源码见3.2</p>\n<hr>\n<p>至此，Spring Cloud整合TCC模式完成</p>\n",
  "link": "/zh-cn/blog/integrate-seata-tcc-mode-with-spring-cloud.html",
  "meta": {
    "title": "Spring Cloud集成Seata分布式事务-TCC模式",
    "keywords": "TCC,Seata,Spring Cloud,分布式,事务",
    "description": "本文主要介绍Spring Cloud集成Seata分布式事务TCC模式",
    "author": "弓行（谭志坚）",
    "date": "2021-01-23"
  }
}