{
  "filename": "seata-at-mode-start.md",
  "__html": "<h1>前言</h1>\n<p>从上一篇文章「<a href=\"https://mp.weixin.qq.com/s/Pypkm5C9aLPJHYwcM6tAtA\">分布式事务中间件Seata的设计原理</a>」讲了下 Seata AT 模式的一些设计原理，从中也知道了 AT 模式的三个角色（RM、TM、TC），接下来我会更新 Seata 源码分析系列文章。今天就来分析 Seata AT 模式在启动的时候都做了哪些操作。</p>\n<h1>客户端启动逻辑</h1>\n<p>TM 是负责整个全局事务的管理器，因此一个全局事务是由 TM 开启的，TM 有个全局管理类 GlobalTransaction，结构如下：</p>\n<p>io.seata.tm.api.GlobalTransaction</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GlobalTransaction</span> </span>{\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> timeout)</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">begin</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> timeout, String name)</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">commit</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">rollback</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n  \n  <span class=\"hljs-function\">GlobalStatus <span class=\"hljs-title\">getStatus</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> TransactionException</span>;\n  \n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>可以通过 GlobalTransactionContext 创建一个 GlobalTransaction，然后用 GlobalTransaction 进行全局事务的开启、提交、回滚等操作，因此我们直接用 API 方式使用 Seata AT 模式：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">//init seata;</span>\nTMClient.init(applicationId, txServiceGroup);\nRMClient.init(applicationId, txServiceGroup);\n<span class=\"hljs-comment\">//trx</span>\nGlobalTransaction tx = GlobalTransactionContext.getCurrentOrCreate();\n<span class=\"hljs-keyword\">try</span> {\n  tx.begin(<span class=\"hljs-number\">60000</span>, <span class=\"hljs-string\">\"testBiz\"</span>);\n  <span class=\"hljs-comment\">// 事务处理</span>\n  <span class=\"hljs-comment\">// ...</span>\n  tx.commit();\n} <span class=\"hljs-keyword\">catch</span> (Exception exx) {\n  tx.rollback();\n  <span class=\"hljs-keyword\">throw</span> exx;\n}\n</code></pre>\n<p>如果每次使用全局事务都这样写，难免会造成代码冗余，我们的项目都是基于 Spring 容器，这时我们可以利用 Spring AOP 的特性，用模板模式把这些冗余代码封装模版里，参考 Mybatis-spring 也是做了这么一件事情，那么接下来我们来分析一下基于 Spring 的项目启动 Seata 并注册全局事务时都做了哪些工作。</p>\n<p>我们开启一个全局事务是在方法上加上 <code>@GlobalTransactional</code>注解，Seata 的 Spring 模块中，有个 GlobalTransactionScanner，它的继承关系如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GlobalTransactionScanner</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">AbstractAutoProxyCreator</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">InitializingBean</span>, <span class=\"hljs-title\">ApplicationContextAware</span>, <span class=\"hljs-title\">DisposableBean</span> </span>{\n  <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>在基于 Spring 项目的启动过程中，对该类会有如下初始化流程：</p>\n<p><img src=\"https://gitee.com/objcoding/md-picture/raw/master/img/image-20191124155455309.png\" alt=\"image-20191124155455309\"></p>\n<p>InitializingBean 的 afterPropertiesSet() 方法调用了 initClient() 方法：</p>\n<p>io.seata.spring.annotation.GlobalTransactionScanner#initClient</p>\n<pre><code class=\"language-java\">TMClient.init(applicationId, txServiceGroup);\nRMClient.init(applicationId, txServiceGroup);\n</code></pre>\n<p>对 TM 和 RM 做了初始化操作。</p>\n<ul>\n<li>TM 初始化</li>\n</ul>\n<p>io.seata.tm.TMClient#init</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(String applicationId, String transactionServiceGroup)</span> </span>{\n  <span class=\"hljs-comment\">// 获取 TmRpcClient 实例</span>\n  TmRpcClient tmRpcClient = TmRpcClient.getInstance(applicationId, transactionServiceGroup);\n  <span class=\"hljs-comment\">// 初始化 TM Client</span>\n  tmRpcClient.init();\n}\n</code></pre>\n<p>调用 TmRpcClient.getInstance() 方法会获取一个 TM 客户端实例，在获取过程中，会创建 Netty 客户端配置文件对象，以及创建 messageExecutor 线程池，该线程池用于在处理各种与服务端的消息交互，在创建 TmRpcClient 实例时，创建 ClientBootstrap，用于管理 Netty 服务的启停，以及 ClientChannelManager，它是专门用于管理 Netty 客户端对象池，Seata 的 Netty 部分配合使用了对象池，后面在分析网络模块会讲到。</p>\n<p>io.seata.core.rpc.netty.AbstractRpcRemotingClient#init</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span> </span>{\n  clientBootstrap.start();\n  <span class=\"hljs-comment\">// 定时尝试连接服务端</span>\n  timerExecutor.scheduleAtFixedRate(<span class=\"hljs-keyword\">new</span> Runnable() {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n      clientChannelManager.reconnect(getTransactionServiceGroup());\n    }\n  }, SCHEDULE_INTERVAL_MILLS, SCHEDULE_INTERVAL_MILLS, TimeUnit.SECONDS);\n  mergeSendExecutorService = <span class=\"hljs-keyword\">new</span> ThreadPoolExecutor(MAX_MERGE_SEND_THREAD,\n                                                    MAX_MERGE_SEND_THREAD,\n                                                    KEEP_ALIVE_TIME, TimeUnit.MILLISECONDS,\n                                                    <span class=\"hljs-keyword\">new</span> LinkedBlockingQueue&lt;&gt;(),\n                                                    <span class=\"hljs-keyword\">new</span> NamedThreadFactory(getThreadPrefix(), MAX_MERGE_SEND_THREAD));\n  mergeSendExecutorService.submit(<span class=\"hljs-keyword\">new</span> MergedSendRunnable());\n  <span class=\"hljs-keyword\">super</span>.init();\n}\n</code></pre>\n<p>调用 TM 客户端 init() 方法，最终会启动 netty 客户端（此时还未真正启动，在对象池被调用时才会被真正启动）；开启一个定时任务，定时重新发送 RegisterTMRequest（RM 客户端会发送 RegisterRMRequest）请求尝试连接服务端，具体逻辑是在 NettyClientChannelManager 中的 channels 中缓存了客户端 channel，如果此时 channels 不存在获取已过期，那么就会尝试连接服务端以重新获取 channel 并将其缓存到 channels 中；开启一条单独线程，用于处理异步请求发送，这里用得很巧妙，之后在分析网络模块在具体对其进行分析。</p>\n<p>io.seata.core.rpc.netty.AbstractRpcRemoting#init</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span> </span>{\n  timerExecutor.scheduleAtFixedRate(<span class=\"hljs-keyword\">new</span> Runnable() {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>{\n      <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;Integer, MessageFuture&gt; entry : futures.entrySet()) {\n        <span class=\"hljs-keyword\">if</span> (entry.getValue().isTimeout()) {\n          futures.remove(entry.getKey());\n          entry.getValue().setResultMessage(<span class=\"hljs-keyword\">null</span>);\n          <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(<span class=\"hljs-string\">\"timeout clear future: {}\"</span>, entry.getValue().getRequestMessage().getBody());\n          }\n        }\n      }\n\n      nowMills = System.currentTimeMillis();\n    }\n  }, TIMEOUT_CHECK_INTERNAL, TIMEOUT_CHECK_INTERNAL, TimeUnit.MILLISECONDS);\n}\n</code></pre>\n<p>在 AbstractRpcRemoting 的 init 方法中，又是开启了一个定时任务，该定时任务主要是用于定时清除 futures 已过期的 futrue，futures 是保存发送请求需要返回结果的 future 对象，该对象有个超时时间，过了超时时间就会自动抛异常，因此需要定时清除已过期的 future 对象。</p>\n<ul>\n<li>RM 初始化</li>\n</ul>\n<p>io.seata.rm.RMClient#init</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(String applicationId, String transactionServiceGroup)</span> </span>{\n  RmRpcClient rmRpcClient = RmRpcClient.getInstance(applicationId, transactionServiceGroup);\n  rmRpcClient.setResourceManager(DefaultResourceManager.get());\n  rmRpcClient.setClientMessageListener(<span class=\"hljs-keyword\">new</span> RmMessageListener(DefaultRMHandler.get()));\n  rmRpcClient.init();\n}\n</code></pre>\n<p>RmRpcClient.getInstance 处理逻辑与 TM 大致相同；ResourceManager 是 RM 资源管理器，负责分支事务的注册、提交、上报、以及回滚操作，以及全局锁的查询操作，DefaultResourceManager 会持有当前所有的 RM 资源管理器，进行统一调用处理，而 get() 方法主要是加载当前的资源管理器，主要用了类似 SPI 的机制，进行灵活加载，如下图，Seata 会扫描 META-INF/services/ 目录下的配置类并进行动态加载。</p>\n<p>ClientMessageListener 是 RM 消息处理监听器，用于负责处理从 TC 发送过来的指令，并对分支进行分支提交、分支回滚，以及 undo log 删除操作；最后 init 方法跟 TM 逻辑也大体一致；DefaultRMHandler 封装了 RM 分支事务的一些具体操作逻辑。</p>\n<p>接下来再看看 wrapIfNecessary 方法究竟做了哪些操作。</p>\n<p>io.seata.spring.annotation.GlobalTransactionScanner#wrapIfNecessary</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> Object <span class=\"hljs-title\">wrapIfNecessary</span><span class=\"hljs-params\">(Object bean, String beanName, Object cacheKey)</span> </span>{\n  <span class=\"hljs-comment\">// 判断是否有开启全局事务</span>\n  <span class=\"hljs-keyword\">if</span> (disableGlobalTransaction) {\n    <span class=\"hljs-keyword\">return</span> bean;\n  }\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">synchronized</span> (PROXYED_SET) {\n      <span class=\"hljs-keyword\">if</span> (PROXYED_SET.contains(beanName)) {\n        <span class=\"hljs-keyword\">return</span> bean;\n      }\n      interceptor = <span class=\"hljs-keyword\">null</span>;\n      <span class=\"hljs-comment\">//check TCC proxy</span>\n      <span class=\"hljs-keyword\">if</span> (TCCBeanParserUtils.isTccAutoProxy(bean, beanName, applicationContext)) {\n        <span class=\"hljs-comment\">//TCC interceptor, proxy bean of sofa:reference/dubbo:reference, and LocalTCC</span>\n        interceptor = <span class=\"hljs-keyword\">new</span> TccActionInterceptor(TCCBeanParserUtils.getRemotingDesc(beanName));\n      } <span class=\"hljs-keyword\">else</span> {\n        Class&lt;?&gt; serviceInterface = SpringProxyUtils.findTargetClass(bean);\n        Class&lt;?&gt;[] interfacesIfJdk = SpringProxyUtils.findInterfaces(bean);\n\n        <span class=\"hljs-comment\">// 判断 bean 中是否有 GlobalTransactional 和 GlobalLock 注解</span>\n        <span class=\"hljs-keyword\">if</span> (!existsAnnotation(<span class=\"hljs-keyword\">new</span> Class[]{serviceInterface})\n            &amp;&amp; !existsAnnotation(interfacesIfJdk)) {\n          <span class=\"hljs-keyword\">return</span> bean;\n        }\n\n        <span class=\"hljs-keyword\">if</span> (interceptor == <span class=\"hljs-keyword\">null</span>) {\n          <span class=\"hljs-comment\">// 创建代理类</span>\n          interceptor = <span class=\"hljs-keyword\">new</span> GlobalTransactionalInterceptor(failureHandlerHook);\n        }\n      }\n\n      LOGGER.info(<span class=\"hljs-string\">\"Bean[{}] with name [{}] would use interceptor [{}]\"</span>,\n                  bean.getClass().getName(), beanName, interceptor.getClass().getName());\n      <span class=\"hljs-keyword\">if</span> (!AopUtils.isAopProxy(bean)) {\n        bean = <span class=\"hljs-keyword\">super</span>.wrapIfNecessary(bean, beanName, cacheKey);\n      } <span class=\"hljs-keyword\">else</span> {\n        AdvisedSupport advised = SpringProxyUtils.getAdvisedSupport(bean);\n        <span class=\"hljs-comment\">// 执行包装目标对象到代理对象  </span>\n        Advisor[] advisor = <span class=\"hljs-keyword\">super</span>.buildAdvisors(beanName, getAdvicesAndAdvisorsForBean(<span class=\"hljs-keyword\">null</span>, <span class=\"hljs-keyword\">null</span>, <span class=\"hljs-keyword\">null</span>));\n        <span class=\"hljs-keyword\">for</span> (Advisor avr : advisor) {\n          advised.addAdvisor(<span class=\"hljs-number\">0</span>, avr);\n        }\n      }\n      PROXYED_SET.add(beanName);\n      <span class=\"hljs-keyword\">return</span> bean;\n    }\n  } <span class=\"hljs-keyword\">catch</span> (Exception exx) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(exx);\n  }\n}\n</code></pre>\n<p>GlobalTransactionScanner 继承了 AbstractAutoProxyCreator，用于对 Spring AOP 支持，从代码中可看出，用GlobalTransactionalInterceptor 代替了被 GlobalTransactional 和 GlobalLock 注解的方法。</p>\n<p>GlobalTransactionalInterceptor 实现了 MethodInterceptor：</p>\n<p>io.seata.spring.annotation.GlobalTransactionalInterceptor#invoke</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> MethodInvocation methodInvocation)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n  Class&lt;?&gt; targetClass = methodInvocation.getThis() != <span class=\"hljs-keyword\">null</span> ? AopUtils.getTargetClass(methodInvocation.getThis()) : <span class=\"hljs-keyword\">null</span>;\n  Method specificMethod = ClassUtils.getMostSpecificMethod(methodInvocation.getMethod(), targetClass);\n  <span class=\"hljs-keyword\">final</span> Method method = BridgeMethodResolver.findBridgedMethod(specificMethod);\n\n  <span class=\"hljs-keyword\">final</span> GlobalTransactional globalTransactionalAnnotation = getAnnotation(method, GlobalTransactional.class);\n  <span class=\"hljs-keyword\">final</span> GlobalLock globalLockAnnotation = getAnnotation(method, GlobalLock.class);\n  <span class=\"hljs-keyword\">if</span> (globalTransactionalAnnotation != <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-comment\">// 全局事务注解</span>\n    <span class=\"hljs-keyword\">return</span> handleGlobalTransaction(methodInvocation, globalTransactionalAnnotation);\n  } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (globalLockAnnotation != <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-comment\">// 全局锁注解</span>\n    <span class=\"hljs-keyword\">return</span> handleGlobalLock(methodInvocation);\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> methodInvocation.proceed();\n  }\n}\n</code></pre>\n<p>以上是代理方法执行的逻辑逻辑，其中 handleGlobalTransaction() 方法里面调用了 TransactionalTemplate 模版：</p>\n<p>io.seata.spring.annotation.GlobalTransactionalInterceptor#handleGlobalTransaction</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> Object <span class=\"hljs-title\">handleGlobalTransaction</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> MethodInvocation methodInvocation,\n                                       <span class=\"hljs-keyword\">final</span> GlobalTransactional globalTrxAnno)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-keyword\">return</span> transactionalTemplate.execute(<span class=\"hljs-keyword\">new</span> TransactionalExecutor() {\n      <span class=\"hljs-meta\">@Override</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n        <span class=\"hljs-keyword\">return</span> methodInvocation.proceed();\n      }\n      <span class=\"hljs-meta\">@Override</span>\n      <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> TransactionInfo <span class=\"hljs-title\">getTransactionInfo</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// ...</span>\n      }\n    });\n  } <span class=\"hljs-keyword\">catch</span> (TransactionalExecutor.ExecutionException e) {\n    <span class=\"hljs-comment\">// ...</span>\n  }\n}\n</code></pre>\n<p>handleGlobalTransaction() 方法执行了就是 TransactionalTemplate 模版类的 execute 方法：</p>\n<p>io.seata.tm.api.TransactionalTemplate#execute</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(TransactionalExecutor business)</span> <span class=\"hljs-keyword\">throws</span> Throwable </span>{\n  <span class=\"hljs-comment\">// 1. get or create a transaction</span>\n  GlobalTransaction tx = GlobalTransactionContext.getCurrentOrCreate();\n\n  <span class=\"hljs-comment\">// 1.1 get transactionInfo</span>\n  TransactionInfo txInfo = business.getTransactionInfo();\n  <span class=\"hljs-keyword\">if</span> (txInfo == <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ShouldNeverHappenException(<span class=\"hljs-string\">\"transactionInfo does not exist\"</span>);\n  }\n  <span class=\"hljs-keyword\">try</span> {\n\n    <span class=\"hljs-comment\">// 2. begin transaction</span>\n    beginTransaction(txInfo, tx);\n\n    Object rs = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-keyword\">try</span> {\n\n      <span class=\"hljs-comment\">// Do Your Business</span>\n      rs = business.execute();\n\n    } <span class=\"hljs-keyword\">catch</span> (Throwable ex) {\n\n      <span class=\"hljs-comment\">// 3.the needed business exception to rollback.</span>\n      completeTransactionAfterThrowing(txInfo,tx,ex);\n      <span class=\"hljs-keyword\">throw</span> ex;\n    }\n\n    <span class=\"hljs-comment\">// 4. everything is fine, commit.</span>\n    commitTransaction(tx);\n\n    <span class=\"hljs-keyword\">return</span> rs;\n  } <span class=\"hljs-keyword\">finally</span> {\n    <span class=\"hljs-comment\">//5. clear</span>\n    triggerAfterCompletion();\n    cleanUp();\n  }\n}\n</code></pre>\n<p>以上是不是有一种似曾相识的感觉？没错，以上就是我们使用 API 时经常写的冗余代码，现在 Spring 通过代理模式，把这些冗余代码都封装带模版里面了，它将那些冗余代码统统封装起来统一流程处理，并不需要你显示写出来了，有兴趣的也可以去看看 Mybatis-spring 的源码，也是写得非常精彩。</p>\n<h1>服务端处理逻辑</h1>\n<p>服务端收到客户端的连接，那当然是将其 channel 也缓存起来，前面也说到客户端会发送 RegisterRMRequest/RegisterTMRequest 请求给服务端，服务端收到后会调用 ServerMessageListener 监听器处理：</p>\n<p>io.seata.core.rpc.ServerMessageListener</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">ServerMessageListener</span> </span>{\n  <span class=\"hljs-comment\">// 处理各种事务，如分支注册、分支提交、分支上报、分支回滚等等</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onTrxMessage</span><span class=\"hljs-params\">(RpcMessage request, ChannelHandlerContext ctx, ServerMessageSender sender)</span></span>;\n\t<span class=\"hljs-comment\">// 处理 RM 客户端的注册连接</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onRegRmMessage</span><span class=\"hljs-params\">(RpcMessage request, ChannelHandlerContext ctx,\n                      ServerMessageSender sender, RegisterCheckAuthHandler checkAuthHandler)</span></span>;\n  <span class=\"hljs-comment\">// 处理 TM 客户端的注册连接</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onRegTmMessage</span><span class=\"hljs-params\">(RpcMessage request, ChannelHandlerContext ctx,\n                      ServerMessageSender sender, RegisterCheckAuthHandler checkAuthHandler)</span></span>;\n  <span class=\"hljs-comment\">// 服务端与客户端保持心跳</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">onCheckMessage</span><span class=\"hljs-params\">(RpcMessage request, ChannelHandlerContext ctx, ServerMessageSender sender)</span>\n\n}\n</span></code></pre>\n<p>ChannelManager 是服务端 channel 的管理器，服务端每次和客户端通信，都需要从 ChannelManager 中获取客户端对应的 channel，它用于保存 TM 和 RM 客户端 channel 的缓存结构如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">/**\n * resourceId -&gt; applicationId -&gt; ip -&gt; port -&gt; RpcContext\n */</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, ConcurrentMap&lt;String, ConcurrentMap&lt;Integer,\nRpcContext&gt;&gt;&gt;&gt;\n  RM_CHANNELS = <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, ConcurrentMap&lt;String, ConcurrentMap&lt;Integer,\nRpcContext&gt;&gt;&gt;&gt;();\n\n<span class=\"hljs-comment\">/**\n * ip+appname,port\n */</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> ConcurrentMap&lt;String, ConcurrentMap&lt;Integer, RpcContext&gt;&gt; TM_CHANNELS\n  = <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;String, ConcurrentMap&lt;Integer, RpcContext&gt;&gt;();\n</code></pre>\n<p>以上的 Map 结构有点复杂：</p>\n<p>RM_CHANNELS：</p>\n<ol>\n<li>resourceId 指的是 RM client 的数据库地址；</li>\n<li>applicationId 指的是 RM client 的服务 Id，比如 springboot 的配置 spring.application.name=account-service 中的 account-service 即是  applicationId；</li>\n<li>ip 指的是 RM client 服务地址；</li>\n<li>port 指的是 RM client 服务地址；</li>\n<li>RpcContext 保存了本次注册请求的信息。</li>\n</ol>\n<p>TM_CHANNELS：</p>\n<ol>\n<li>ip+appname：这里的注释应该是写错了，应该是 appname+ip，即 TM_CHANNELS 的 Map 结构第一个 key 为 appname+ip；</li>\n<li>port：客户端的端口号。</li>\n</ol>\n<p>以下是 RM Client 注册逻辑：</p>\n<p>io.seata.core.rpc.ChannelManager#registerRMChannel</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerRMChannel</span><span class=\"hljs-params\">(RegisterRMRequest resourceManagerRequest, Channel channel)</span>\n  <span class=\"hljs-keyword\">throws</span> IncompatibleVersionException </span>{\n  Version.checkVersion(resourceManagerRequest.getVersion());\n  <span class=\"hljs-comment\">// 将 ResourceIds 数据库连接连接信息放入一个set中</span>\n  Set&lt;String&gt; dbkeySet = dbKeytoSet(resourceManagerRequest.getResourceIds());\n  RpcContext rpcContext;\n  <span class=\"hljs-comment\">// 从缓存中判断是否有该channel信息</span>\n  <span class=\"hljs-keyword\">if</span> (!IDENTIFIED_CHANNELS.containsKey(channel)) {\n    <span class=\"hljs-comment\">// 根据请求注册信息，构建 rpcContext</span>\n    rpcContext = buildChannelHolder(NettyPoolKey.TransactionRole.RMROLE, resourceManagerRequest.getVersion(),\n                                    resourceManagerRequest.getApplicationId(), resourceManagerRequest.getTransactionServiceGroup(),\n                                    resourceManagerRequest.getResourceIds(), channel);\n    <span class=\"hljs-comment\">// 将 rpcContext 放入缓存中</span>\n    rpcContext.holdInIdentifiedChannels(IDENTIFIED_CHANNELS);\n  } <span class=\"hljs-keyword\">else</span> {\n    rpcContext = IDENTIFIED_CHANNELS.get(channel);\n    rpcContext.addResources(dbkeySet);\n  }\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">null</span> == dbkeySet || dbkeySet.isEmpty()) { <span class=\"hljs-keyword\">return</span>; }\n  <span class=\"hljs-keyword\">for</span> (String resourceId : dbkeySet) {\n    String clientIp;\n    <span class=\"hljs-comment\">// 将请求信息存入 RM_CHANNELS 中，这里用了 java8 的 computeIfAbsent 方法操作</span>\n    ConcurrentMap&lt;Integer, RpcContext&gt; portMap = RM_CHANNELS.computeIfAbsent(resourceId, resourceIdKey -&gt; <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;&gt;())\n      .computeIfAbsent(resourceManagerRequest.getApplicationId(), applicationId -&gt; <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;&gt;())\n      .computeIfAbsent(clientIp = getClientIpFromChannel(channel), clientIpKey -&gt; <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;&gt;());\n\t\t<span class=\"hljs-comment\">// 将当前 rpcContext 放入 portMap 中</span>\n    rpcContext.holdInResourceManagerChannels(resourceId, portMap);\n    updateChannelsResource(resourceId, clientIp, resourceManagerRequest.getApplicationId());\n  }\n}\n</code></pre>\n<p>从以上代码逻辑能够看出，注册 RM client 主要是将注册请求信息，放入 RM_CHANNELS 缓存中，同时还会从 IDENTIFIED_CHANNELS 中判断本次请求的 channel 是否已验证过，IDENTIFIED_CHANNELS 的结构如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> ConcurrentMap&lt;Channel, RpcContext&gt; IDENTIFIED_CHANNELS\n  = <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;&gt;();\n</code></pre>\n<p>IDENTIFIED_CHANNELS 包含了所有 TM 和 RM 已注册的 channel。</p>\n<p>以下是 TM 注册逻辑：</p>\n<p>io.seata.core.rpc.ChannelManager#registerTMChannel</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">registerTMChannel</span><span class=\"hljs-params\">(RegisterTMRequest request, Channel channel)</span>\n  <span class=\"hljs-keyword\">throws</span> IncompatibleVersionException </span>{\n  Version.checkVersion(request.getVersion());\n  <span class=\"hljs-comment\">// 根据请求注册信息，构建 RpcContext</span>\n  RpcContext rpcContext = buildChannelHolder(NettyPoolKey.TransactionRole.TMROLE, request.getVersion(),\n                                             request.getApplicationId(),\n                                             request.getTransactionServiceGroup(),\n                                             <span class=\"hljs-keyword\">null</span>, channel);\n  <span class=\"hljs-comment\">// 将 RpcContext 放入 IDENTIFIED_CHANNELS 缓存中</span>\n  rpcContext.holdInIdentifiedChannels(IDENTIFIED_CHANNELS);\n  <span class=\"hljs-comment\">// account-service:127.0.0.1:63353</span>\n  String clientIdentified = rpcContext.getApplicationId() + Constants.CLIENT_ID_SPLIT_CHAR\n    + getClientIpFromChannel(channel);\n  <span class=\"hljs-comment\">// 将请求信息存入 TM_CHANNELS 缓存中</span>\n  TM_CHANNELS.putIfAbsent(clientIdentified, <span class=\"hljs-keyword\">new</span> ConcurrentHashMap&lt;Integer, RpcContext&gt;());\n  <span class=\"hljs-comment\">// 将上一步创建好的get出来，之后再将rpcContext放入这个map的value中</span>\n  ConcurrentMap&lt;Integer, RpcContext&gt; clientIdentifiedMap = TM_CHANNELS.get(clientIdentified);\n  rpcContext.holdInClientChannels(clientIdentifiedMap);\n}\n</code></pre>\n<p>TM client 的注册大体类似，把本次注册的信息放入对应的缓存中保存，但比 RM client 的注册逻辑简单一些，主要是 RM client 会涉及分支事务资源的信息，需要注册的信息也会比 TM client 多。</p>\n<p>以上源码分析基于 0.9.0 版本。</p>\n<h1>作者简介</h1>\n<p>张乘辉，目前就职于中通科技信息中心技术平台部，担任 Java 工程师，主要负责中通消息平台与全链路压测项目的研发，热爱分享技术，微信公众号「后端进阶」作者，技术博客（<a href=\"https://objcoding.com/\">https://objcoding.com/</a>）博主，Seata Contributor，GitHub ID：objcoding。</p>\n",
  "link": "/zh-cn/blog/seata-at-mode-start.html",
  "meta": {
    "title": "Seata AT 模式启动源码分析",
    "author": "张乘辉",
    "keywords": "Seata、分布式事务、AT模式",
    "description": "Seata 源码分析系列",
    "date": "2019/11/27"
  }
}