<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="keywords" content="seata-client-start-analysis-01" />
	<meta name="description" content="seata-client-start-analysis-01" />
	<!-- 网页标签标题 -->
	<title>Seata应用侧启动过程剖析——RM &amp; TM如何与TC建立连接</title>
  <link rel="shortcut icon" href="/img/seata_logo_small.jpeg"/>
	<link rel="stylesheet" href="/build/blogDetail.css" />
</head>
<body>
	<div id="root"><div class="blog-detail-page" data-reactroot=""><header class="header-container header-container-normal"><div class="header-body"><a href="/zh-cn/index.html"><img class="logo" src="//img.alicdn.com/tfs/TB1gqL1w4D1gK0jSZFyXXciOVXa-1497-401.png"/></a><div class="search search-normal"><span class="icon-search"></span></div><span class="language-switch language-switch-normal">En</span><div class="header-menu"><img class="header-menu-toggle" src="https://img.alicdn.com/tfs/TB14eEmw7P2gK0jSZPxXXacQpXa-38-32.png"/><ul><li class="menu-item menu-item-normal"><a href="/zh-cn/index.html" target="_self">首页</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/overview/what-is-seata.html" target="_self">文档</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/docs/developers/developers_dev.html" target="_self">开发者</a></li><li class="menu-item menu-item-normal menu-item-normal-active"><a href="/zh-cn/blog/index.html" target="_self">博客</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/community/index.html" target="_self">社区</a></li><li class="menu-item menu-item-normal"><a href="/zh-cn/blog/download.html" target="_self">下载</a></li></ul></div></div></header><section class="blog-content markdown-body"><blockquote>
<p>“刚上手Seata，对其各个模块了解还不够深入？ <br>
想深入研究Seata源码，却还未付诸实践？<br>
想探究下在集成Seata后，自己的应用在启动过程中“偷偷”干了些啥？<br>
想学习Seata作为一款优秀开源框架蕴含的设计理念和最佳实践？<br>
如果你有上述任何想法之一，那么今天这篇文章，就是为你量身打造的~</p>
</blockquote>
<h2>前言</h2>
<p>看过官网README的第一张图片的同学都应该清楚，Seata协调分布式事务的原理便在于通过其<strong>协调器侧</strong>的TC，来与<strong>应用侧</strong>的TM、RM进行各种通信与交互，来保证分布式事务中，多个事务参与者的数据一致性。那么Seata的协调器侧与应用侧之间，是如何建立连接并进行通信的呢？</p>
<p>没错，答案就是Netty，Netty作为一款高性能的RPC通信框架，保证了TC与RM之间的高效通信，关于Netty的详细介绍，本文不再展开，今天我们探究的重点，在于<strong>应用侧在启动过程中，如何通过一系列Seata关键模块之间的协作（如RPC、Config/Registry Center等），来建立与协调器侧之间的通信</strong></p>
<h2>从GlobalTransactionScanner说起</h2>
<p>我们知道Seata提供了多个开发期注解，比如用于开启分布式事务的@GlobalTransactional、用于声明TCC两阶段服务的@TwoPhraseBusinessAction等，它们都是基于Spring AOP机制，对使用了注解的Bean方法分配对应的拦截器进行增强，来完成对应的处理逻辑。而GlobalTransactionScanner这个Spring Bean，就承载着为各个注解分配对应的拦截器的职责，从其Scanner的命名，我们也不难推断出，它是为了在Spring应用启动过程中，对与全局事务（GlobalTransactionScanner）相关的Bean进行扫描、处理的。</p>
<p>除此之外，应用侧RPC客户端（TMClient、RMClient）初始化、与TC建立连接的流程，也是在GlobalTransactionScanner#afterPropertiesSet()中发起的：</p>
<pre><code class="language-js">    <span class="hljs-comment">/**
     * package：io.seata.spring.annotation
     * class：GlobalTransactionScanner
     */</span>
    @Override
    public <span class="hljs-keyword">void</span> afterPropertiesSet() {
        <span class="hljs-keyword">if</span> (disableGlobalTransaction) {
            <span class="hljs-keyword">if</span> (LOGGER.isInfoEnabled()) {
                LOGGER.info(<span class="hljs-string">"Global transaction is disabled."</span>);
            }
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-comment">//在Bean属性初始化之后，执行TM、RM的初始化</span>
        initClient();

    }
</code></pre>
<h2>RM &amp; TM 的初始化与连接过程</h2>
<p>这里，我们以RMClient.init()为例说明，TMClient的初始化过程亦同理。</p>
<h3>类关系的设计</h3>
<p>查看RMClient#init()的源码，我们发现，RMClient先<strong>构造</strong>了一个RmNettyRemotingClient，然后执行其<strong>初始化</strong>init()方法。而RmNettyRemotingClient的<strong>构造器</strong>和<strong>初始化</strong>方法，都会逐层调用父类的构造器与初始化方法</p>
<pre><code class="language-js">    <span class="hljs-comment">/**
     * RMClient的初始化逻辑
     * package：io.seata.rm
     * class：RMClient
     */</span>
    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> init(<span class="hljs-built_in">String</span> applicationId, <span class="hljs-built_in">String</span> transactionServiceGroup) {
        <span class="hljs-comment">//① 首先从RmNettyRemotingClient类开始，依次调用父类的构造器        </span>
        RmNettyRemotingClient rmNettyRemotingClient = RmNettyRemotingClient.getInstance(applicationId, transactionServiceGroup);
        rmNettyRemotingClient.setResourceManager(DefaultResourceManager.get());
        rmNettyRemotingClient.setTransactionMessageHandler(DefaultRMHandler.get());
        <span class="hljs-comment">//② 然后从RmNettyRemotingClient类开始，依次调用父类的init()</span>
        rmNettyRemotingClient.init();
    }
</code></pre>
<p>上述RMClient系列各类之间的关系以及调用构造器和init()初始化方法的过程如下图示意：
<img src="http://booogu.top/img/in-post/rmclient_relation.jpg" alt="RMClient.init简化版流程与主要类之间的关系"></p>
<p>那么为何要将RMClient设计成这样较为复杂的继承关系呢？其实是为了将各层的职责、边界划分清楚，使得各层可以专注于特定逻辑处理，实现更好的扩展性，这部分的详细设计思路，可参考Seata RPC模块重构PR的操刀者乘辉兄的文章<a href="https://mp.weixin.qq.com/s/PCSZ4a8cgmyZNhbUrO-BZQ">Seata-RPC重构之路</a>）</p>
<h3>初始化的完整流程</h3>
<p>各类的构造器与初始化方法中的主要逻辑，大家可以借助下面这个能表意的序列图来梳理下，此图大家也可先跳过不看，在下面我们分析过几个重点类后，再回头来看这些类是何时登场、如何交互的协作的。
<img src="http://booogu.top/img/in-post/rmclient_initialization.png" alt="RMClient的初始化流程"></p>
<h3>抓住核心——Channel的创建</h3>
<p>首先我们需要知道，应用侧与协调器侧的通信是借助Netty的Channel（网络通道）来完成的，因此<strong>通信过程的关键在于Channel的创建</strong>，在Seata中，通过池化的方式（借助了common-pool中的对象池）方式来创建、管理Channel。</p>
<p>这里我们有必要简要介绍下对象池的简单概念及其在Seata中的实现：
涉及到的common-pool中的主要类：</p>
<ul>
<li><strong>GenericKeydObjectPool&lt;K, V&gt;</strong>：KV泛型对象池，提供对所有对象的存取管理，而对象的创建由其内部的工厂类来完成</li>
<li><strong>KeyedPoolableObjectFactory&lt;K, V&gt;</strong>：KV泛型对象工厂，负责池化对象的创建，被对象池持有</li>
</ul>
<p>涉及到的Seata中对象池实现相关的主要类：</p>
<ul>
<li>首先，被池化管理的对象就是<strong>Channel</strong>，对应common-pool中的泛型V</li>
<li><strong>NettyPoolKey</strong>：Channel对应的Key，对应common-pool中的泛型K，NettyPoolKey主要包含两个信息：
<ul>
<li><em>address</em>:创建Channel时，对应的TC Server地址</li>
<li><em>message</em>:创建Channel时，向TC Server发送的RPC消息体</li>
</ul>
</li>
<li><strong>GenericKeydObjectPool&lt;NettyPoolKey,Channel&gt;</strong>：Channel对象池</li>
<li><strong>NettyPoolableFactory</strong>：创建Channel的工厂类</li>
</ul>
<p>认识了上述对象池相关的主要类之后，我们再来看看Seata中涉及Channel管理以及与RPC相关的几个主要类：</p>
<ul>
<li>NettyClientChannelManager：
<ul>
<li>持有Channel对象池</li>
<li>与Channel对象池交互，对应用侧Channel进行管理（获取、释放、销毁、缓存等）</li>
</ul>
</li>
<li>RpcClientBootstrap：RPC客户端核心引导类，持有Netty框架的Bootstrap对象，具备启停能力；具有根据连接地址来获取新Channel的能力，供Channel工厂类调用</li>
<li>AbstractNettyRemotingClient：
<ul>
<li>初始化并持有RpcClientBootstrap</li>
<li>应用侧Netty客户端的顶层抽象，抽象了应用侧RM/TM取得各自Channel对应的NettyPoolKey的能力，供NettyClientChannelManager调用</li>
<li>初始化NettyPoolableFactory</li>
</ul>
</li>
</ul>
<p>了解上述概念后，我们可以把Seata中创建Channel的过程简化如下：
<img src="http://booogu.top/img/in-post/create_channel.jpg" alt="创建Channel对象过程"></p>
<p>看到这里，大家可以回过头再看看上面的<strong>RMClient的初始化序列图</strong>，应该会对图中各类的职责、关系，以及整个初始化过程的意图有一个比较清晰的理解了。</p>
<h3>建立连接的时机与流程</h3>
<p>那么，RMClient是何时与Server建立连接的呢？</p>
<p>在RMClient初始化的过程中，大家会发现，很多init()方法都设定了一些定时任务，而Seata应用侧与协调器的重连（连接）机制，就是通过定时任务来实现的：</p>
<pre><code class="language-js">    <span class="hljs-comment">/**
     * package：io.seata.core.rpcn.netty
     * class：AbstractNettyRemotingClient
     */</span>
    public <span class="hljs-keyword">void</span> init() {
        <span class="hljs-comment">//设置定时器，定时重连TC Server</span>
        timerExecutor.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() {
            @Override
            public <span class="hljs-keyword">void</span> run() {
                clientChannelManager.reconnect(getTransactionServiceGroup());
            }
        }, SCHEDULE_DELAY_MILLS, SCHEDULE_INTERVAL_MILLS, TimeUnit.MILLISECONDS);
        <span class="hljs-keyword">if</span> (NettyClientConfig.isEnableClientBatchSendRequest()) {
            mergeSendExecutorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(MAX_MERGE_SEND_THREAD,
                MAX_MERGE_SEND_THREAD,
                KEEP_ALIVE_TIME, TimeUnit.MILLISECONDS,
                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(),
                <span class="hljs-keyword">new</span> NamedThreadFactory(getThreadPrefix(), MAX_MERGE_SEND_THREAD));
            mergeSendExecutorService.submit(<span class="hljs-keyword">new</span> MergedSendRunnable());
        }
        <span class="hljs-keyword">super</span>.init();
        clientBootstrap.start();
    }
</code></pre>
<p>我们通过跟踪一次reconnect的执行，看看上面探究的几个类之间是如何协作，完成RMClient与TC的连接的（实际上首次连接可能发生在registerResource的过程中，但流程一致）
<img src="http://booogu.top/img/in-post/rmclient_connect_tcserver.png" alt="RMClient与TC Server连接过程"></p>
<p>这个图中，大家可以重点关注这几个点：</p>
<ul>
<li>NettyClientChannelManager执行具体AbstractNettyRemotingClient中，获取NettyPoolKey的回调函数（getPoolKeyFunction()）：应用侧的不同Client（RMClient与TMClient），在创建Channel时使用的Key不同，使<strong>两者在重连TC Server时，发送的注册消息不同</strong>，这也是由两者在Seata中扮演的角色不同而决定的：
<ul>
<li>TMClient：扮演事务管理器角色，创建Channel时，仅向TC发送TM注册请求（RegisterTMRequest）即可</li>
<li>RMClient：扮演资源管理器角色，需要管理应用侧所有的事务资源，因此在创建Channel时，需要在发送RM注册请求（RegesterRMRequest）前，获取应用侧所有事务资源（Resource）信息，注册至TC Server</li>
</ul>
</li>
<li>在Channel对象工厂NettyPoolableFactory的makeObject（制造Channel）方法中，使用NettyPoolKey中的两项信息，完成了两项任务：
<ul>
<li>使用NettyPoolKey的address创建新的Channel</li>
<li>使用NettyPoolKey的message以及新的Channel向TC Server发送注册请求，这就是Client向TC Server的连接（首次执行）或重连（非首次，由定时任务驱动执行）请求</li>
</ul>
</li>
</ul>
<p>以上内容，就是关于Seata应用侧的初始化及其与TC Server协调器侧建立连接的全过程分析。</p>
<p>更深层次的细节，建议大家再根据本文梳理的脉络和提到的几个重点，细致地阅读下源码，相信定会有更深层次的理解和全新的收获！</p>
<blockquote>
<p>后记：考虑到篇幅以及保持一篇源码分析文章较为合适的信息量，本文前言中所说的<strong>配置、注册等模块协作配合</strong>并没有在文章中展开和体现。<br>
在下篇源码剖析中，我会以<strong>配置中心</strong>和<strong>注册中心</strong>为重点，为大家分析，在RMClient/TM Client与TC Server建立连接之前，Seata应用侧是<strong>如何通过服务发现</strong>找到TC Server、如何<strong>从配置模块获取各种信息</strong>的。</p>
</blockquote>
</section><footer class="footer-container"><div class="footer-body"><img src="//img.alicdn.com/tfs/TB1dGrSwVT7gK0jSZFpXXaTkpXa-4802-1285.png"/><p class="docsite-power">website powered by docsite</p><div class="cols-container"><div class="col col-12"><h3>愿景</h3><p>Seata 是一款阿里巴巴开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。</p></div><div class="col col-6"><dl><dt>文档</dt><dd><a href="/zh-cn/docs/overview/what-is-seata.html" target="_self">Seata 是什么？</a></dd><dd><a href="/zh-cn/docs/user/quickstart.html" target="_self">快速开始</a></dd><dd><a href="https://github.com/seata/seata.github.io/issues/new" target="_self">报告文档问题</a></dd><dd><a href="https://github.com/seata/seata.github.io" target="_self">在Github上编辑此文档</a></dd></dl></div><div class="col col-6"><dl><dt>资源</dt><dd><a href="/zh-cn/blog/index.html" target="_self">博客</a></dd><dd><a href="/zh-cn/community/index.html" target="_self">社区</a></dd></dl></div></div><div class="copyright"><span>Copyright © 2019 Seata</span></div></div></footer></div></div>
	<script src="https://f.alicdn.com/react/15.4.1/react-with-addons.min.js"></script>
	<script src="https://f.alicdn.com/react/15.4.1/react-dom.min.js"></script>
	<script>
		window.rootPath = '';
  </script>
	<script src="/build/blogDetail.js"></script>
	<script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?104e73ef0c18b416b27abb23757ed8ee";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
</body>
</html>
