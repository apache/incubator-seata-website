{
  "filename": "seata-client-start-analysis-02.md",
  "__html": "<blockquote>\n<p>“刚上手Seata，对其各个模块了解还不够深入？ <br>\n想深入研究Seata源码，却还未付诸实践？<br>\n想探究下在集成Seata后，自己的应用在启动过程中“偷偷”干了些啥？<br>\n想学习Seata作为一款优秀开源框架蕴含的设计理念和最佳实践？<br>\n如果你有上述任何想法之一，那么今天这篇文章，就是为你量身打造的~</p>\n</blockquote>\n<h2>前言</h2>\n<p>在Seata的应用侧（RM、TM）启动过程中，首先要做的就是与协调器侧（TC）建立通信，这是Seata能够完成分布式事务协调的前提，那么Seata在完成应用侧初始化以及与TC建立连接的过程中，是<strong>如何找到TC事务协调器的集群和地址</strong>的？又是<strong>如何从配置模块中获取各种配置信息</strong>的呢？这正是本文要探究的重点。</p>\n<h2>给个限定</h2>\n<p>Seata作为一款中间件级的底层组件，是很谨慎引入第三方框架具体实现的，感兴趣的同学可以深入了解下Seata的SPI机制，看看Seata是如何通过大量扩展点（Extension），来将依赖组件的具体实现倒置出去，转而依赖抽象接口的，同时，Seata为了更好地融入微服务、云原生等流行架构所衍生出来的生态中，也基于SPI机制对多款主流的微服务框架、注册中心、配置中心以及Java开发框架界“扛把子”——SpringBoot等做了主动集成，在保证微内核架构、松耦合、可扩展的同时，又可以很好地与各类组件“打成一片”，使得采用了各种技术栈的环境都可以比较方便地引入Seata。</p>\n<p>本文为了贴近大家<strong>刚引入Seata试用时</strong>的场景，在以下介绍中，选择<strong>应用侧</strong>的限定条件如下：使用<strong>File（文件）作为配置中心与注册中心</strong>，并基于<strong>SpringBoot</strong>启动。</p>\n<p>有了这个限定条件，接下来就让我们深入Seata源码，一探究竟吧。</p>\n<h2>多模块交替协作的RM/TM初始化过程</h2>\n<p>在<a href=\"http://booogu.top/2021/02/28/seata-client-start-analysis-01/\"> Seata客户端启动过程剖析（一）</a>中，我们分析了Seata应用侧TM与RM的初始化、以及应用侧如何创建Netty Channel并向TC Server发送注册请求的过程。除此之外，在RM初始化过程中，Seata的其他多个模块（注册中心、配置中心、负载均衡）也都纷纷登场，相互协作，共同完成了连接TC Server的过程。</p>\n<p>当执行Client重连TC Server的方法：NettyClientChannelManager.Channreconnect()时，首先需要根据当前的<strong>事务分组</strong>获取可用的TC Server地址列表：</p>\n<pre><code class=\"language-js\">    <span class=\"hljs-comment\">/**\n     * NettyClientChannelManager.reconnect()\n     * Reconnect to remote server of current transaction service group.\n     *\n     * @param transactionServiceGroup transaction service group\n     */</span>\n    <span class=\"hljs-keyword\">void</span> reconnect(<span class=\"hljs-built_in\">String</span> transactionServiceGroup) {\n        List&lt;<span class=\"hljs-built_in\">String</span>&gt; availList = <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">//从注册中心中获取可用的TC Server地址</span>\n            availList = getAvailServerList(transactionServiceGroup);\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            LOGGER.error(<span class=\"hljs-string\">\"Failed to get available servers: {}\"</span>, e.getMessage(), e);\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-comment\">//以下代码略</span>\n    }\n</code></pre>\n<p>关于事务分组的详细概念介绍，大家可以参考官方文档<a href=\"https://seata.io/zh-cn/docs/user/txgroup/transaction-group.html\">事务分组介绍</a>。这里简单介绍一下:</p>\n<ul>\n<li>每个Seata应用侧的RM、TM，都具有一个<strong>事务分组</strong>名</li>\n<li>每个Seata协调器侧的TC，都具有一个<strong>集群名</strong>和<strong>地址</strong>\n应用侧连接协调器侧时，经历如下两步：</li>\n<li>通过事务分组的名称，从配置中获取到该应用侧对应的TC集群名</li>\n<li>通过集群名称，可以从注册中心中获取TC集群的地址列表\n以上概念、关系与过程，如下图所示：\n<img src=\"http://booogu.top/img/in-post/TXGroup_Group_Relation.jpg\" alt=\"Seata事务分组与建立连接的关系\"></li>\n</ul>\n<h3>从<strong>注册中心</strong>获取TC Server集群地址</h3>\n<p>了解RM/TC连接TC时涉及的主要概念与步骤后，我们继续探究getAvailServerList方法：</p>\n<pre><code class=\"language-js\">    private List&lt;<span class=\"hljs-built_in\">String</span>&gt; getAvailServerList(<span class=\"hljs-built_in\">String</span> transactionServiceGroup) throws Exception {\n        <span class=\"hljs-comment\">//① 使用注册中心工厂，获取注册中心实例</span>\n        <span class=\"hljs-comment\">//② 调用注册中心的查找方法lookUp()，根据事务分组名称获取TC集群中可用Server的地址列表</span>\n        List&lt;InetSocketAddress&gt; availInetSocketAddressList = RegistryFactory.getInstance().lookup(transactionServiceGroup);\n        <span class=\"hljs-keyword\">if</span> (CollectionUtils.isEmpty(availInetSocketAddressList)) {\n            <span class=\"hljs-keyword\">return</span> Collections.emptyList();\n        }\n\n        <span class=\"hljs-keyword\">return</span> availInetSocketAddressList.stream()\n                                         .map(NetUtil::toStringAddress)\n                                         .collect(Collectors.toList());\n    }\n</code></pre>\n<h4>用哪个注册中心？<strong>Seata元配置文件</strong>给出答案</h4>\n<p>上面已提到，Seata支持多种注册中心的实现，那么，Seata首先需要从一个地方先获取到“注册中心的类型”这个信息。</p>\n<p>从哪里获取呢？Seata设计了一个“配置文件”用于存放其框架内所用组件的一些基本信息，我更愿意称这个配置文件为 <strong>『元配置文件』</strong>，这是因为它包含的信息，其实是“配置的配置”，也即“元”的概念，大家可以对比数据库表中的信息，和数据库表本身结构的信息（表数据和表元数据）来理解。</p>\n<p>我们可以把注册中心、配置中心中的信息，都看做是<strong>配置信息本身</strong>，而这些<strong>配置信息的配置</strong>是什么？这些信息，就包含在Seata的元配置文件中。实际上，『元配置文件』中只包含<strong>两类信息</strong>：</p>\n<ul>\n<li>一是注册中心的类型：registry.type，以及该类型注册中心的一些基本信息，比如当注册中心类型为文件时，元配置文件中存放了文件的名字信息；当注册中心类型是Nacos时，元配置文件中则存放着Nacos的地址、命名空间、集群名等信息</li>\n<li>二是配置中心的类型：config.type，以及该类型配置中心的一些基本信息，比如当配置中心为文件时，元配置文件中存放了文件的名字信息；当注册中心类型为Consul时，元配置文件中存放了Consul的地址信息</li>\n</ul>\n<p>Seata的元配置文件支持Yaml、Properties等多种格式，而且可以集成到SpringBoot的application.yaml文件中（使用seata-spring-boot-starter即可），方便与SpringBoot集成。</p>\n<p>Seata中自带的默认元配置文件是registry.conf，当我们采用文件作为注册与配置中心时，registry.conf中的内容设置如下：</p>\n<pre><code class=\"language-js\">registry {\n  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa\n  type = \"file\"\n  file {\n    name = \"file.conf\"\n  }\n}\n\nconfig {\n  # file、nacos 、apollo、zk、consul、etcd3\n  type = \"file\"\n  file {\n    name = \"file.conf\"\n  }\n}\n</code></pre>\n<p>在如下源码中，我们可以发现，Seata使用的注册中心的类型，是从ConfigurationFactory.CURRENT_FILE_INSTANCE中获取的，而这个CURRENT_FILE_INSTANCE，就是我们所说的，Seata<strong>元配置文件的实例</strong></p>\n<pre><code class=\"language-js\">    <span class=\"hljs-comment\">//在getInstance()中，调用buildRegistryService，构建具体的注册中心实例</span>\n    public <span class=\"hljs-keyword\">static</span> RegistryService getInstance() {\n        <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-literal\">null</span>) {\n            synchronized (RegistryFactory.class) {\n                <span class=\"hljs-keyword\">if</span> (instance == <span class=\"hljs-literal\">null</span>) {\n                    instance = buildRegistryService();\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> instance;\n    }\n\n    private <span class=\"hljs-keyword\">static</span> RegistryService buildRegistryService() {\n        RegistryType registryType;\n        <span class=\"hljs-comment\">//获取注册中心类型</span>\n        <span class=\"hljs-built_in\">String</span> registryTypeName = ConfigurationFactory.CURRENT_FILE_INSTANCE.getConfig(\n            ConfigurationKeys.FILE_ROOT_REGISTRY + ConfigurationKeys.FILE_CONFIG_SPLIT_CHAR\n                + ConfigurationKeys.FILE_ROOT_TYPE);\n        <span class=\"hljs-keyword\">try</span> {\n            registryType = RegistryType.getType(registryTypeName);\n        } <span class=\"hljs-keyword\">catch</span> (Exception exx) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> NotSupportYetException(<span class=\"hljs-string\">\"not support registry type: \"</span> + registryTypeName);\n        }\n        <span class=\"hljs-keyword\">if</span> (RegistryType.File == registryType) {\n            <span class=\"hljs-keyword\">return</span> FileRegistryServiceImpl.getInstance();\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">//根据注册中心类型，使用SPI的方式加载注册中心的实例</span>\n            <span class=\"hljs-keyword\">return</span> EnhancedServiceLoader.load(RegistryProvider.class, Objects.requireNonNull(registryType).name()).provide();\n        }\n    }\n</code></pre>\n<p>我们来看一下元配置文件的初始化过程，当首次获取静态字段CURRENT_FILE_INSTANCE时，触发ConfigurationFactory类的初始化：</p>\n<pre><code class=\"language-js\">    <span class=\"hljs-comment\">//ConfigurationFactory类的静态块</span>\n    <span class=\"hljs-keyword\">static</span> {\n        load();\n    }\n\n     <span class=\"hljs-comment\">/**\n     * load()方法中，加载Seata的元配置文件\n     */</span>   \n    private <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> load() {\n        <span class=\"hljs-comment\">//元配置文件的名称，支持通过系统变量、环境变量扩展</span>\n        <span class=\"hljs-built_in\">String</span> seataConfigName = System.getProperty(SYSTEM_PROPERTY_SEATA_CONFIG_NAME);\n        <span class=\"hljs-keyword\">if</span> (seataConfigName == <span class=\"hljs-literal\">null</span>) {\n            seataConfigName = System.getenv(ENV_SEATA_CONFIG_NAME);\n        }\n        <span class=\"hljs-keyword\">if</span> (seataConfigName == <span class=\"hljs-literal\">null</span>) {\n            seataConfigName = REGISTRY_CONF_DEFAULT;\n        }\n        <span class=\"hljs-built_in\">String</span> envValue = System.getProperty(ENV_PROPERTY_KEY);\n        <span class=\"hljs-keyword\">if</span> (envValue == <span class=\"hljs-literal\">null</span>) {\n            envValue = System.getenv(ENV_SYSTEM_KEY);\n        }\n        <span class=\"hljs-comment\">//根据元配置文件名称，创建一个实现了Configuration接口的文件配置实例</span>\n        Configuration configuration = (envValue == <span class=\"hljs-literal\">null</span>) ? <span class=\"hljs-keyword\">new</span> FileConfiguration(seataConfigName,\n                <span class=\"hljs-literal\">false</span>) : <span class=\"hljs-keyword\">new</span> FileConfiguration(seataConfigName + <span class=\"hljs-string\">\"-\"</span> + envValue, <span class=\"hljs-literal\">false</span>);\n        Configuration extConfiguration = <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-comment\">//通过SPI加载，来判断是否存在扩展配置提供者</span>\n        <span class=\"hljs-comment\">//当应用侧使用seata-spring-boot-starer时，将通过SpringBootConfigurationProvider作为扩展配置提供者，这时当获取元配置项时，将不再从file.conf（默认）中获取，而是从application.properties/application.yaml中获取</span>\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">//通过ExtConfigurationProvider的provide方法，将原有的Configuration实例替换为扩展配置的实例</span>\n            extConfiguration = EnhancedServiceLoader.load(ExtConfigurationProvider.class).provide(configuration);\n            <span class=\"hljs-keyword\">if</span> (LOGGER.isInfoEnabled()) {\n                LOGGER.info(<span class=\"hljs-string\">\"load Configuration:{}\"</span>, extConfiguration == <span class=\"hljs-literal\">null</span> ? configuration.getClass().getSimpleName()\n                        : extConfiguration.getClass().getSimpleName());\n            }\n        } <span class=\"hljs-keyword\">catch</span> (EnhancedServiceNotFoundException ignore) {\n\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            LOGGER.error(<span class=\"hljs-string\">\"failed to load extConfiguration:{}\"</span>, e.getMessage(), e);\n        }\n        <span class=\"hljs-comment\">//存在扩展配置，则返回扩展配置实例，否则返回文件配置实例</span>\n        CURRENT_FILE_INSTANCE = extConfiguration == <span class=\"hljs-literal\">null</span> ? configuration : extConfiguration;\n    }\n</code></pre>\n<p>load()方法的调用序列图如下：\n<img src=\"http://booogu.top/img/in-post/seata_config_initialization.png\" alt=\"Seata元配置文件的加载过程\"></p>\n<p>上面的序列图中，大家可以关注以下几点：</p>\n<ul>\n<li>Seata元配置文件<strong>名称支持扩展</strong></li>\n<li>Seata元配置文件后缀<strong>支持3种后缀</strong>，分别为yaml/properties/conf，在创建元配置文件实例时，会依次尝试匹配</li>\n<li>Seata中<strong>配置能力相关的顶级接口为Configuration</strong>，各种配置中心均需实现此接口，Seata的元配置文件就是使用FileConfiguration（文件类型的配置中心）实现了此接口</li>\n</ul>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">/**\n * Seata配置能力接口\n * package：io.seata.config\n */</span>\n\npublic interface Configuration {\n    <span class=\"hljs-comment\">/**\n     * Gets short.\n     *\n     * @param dataId       the data id\n     * @param defaultValue the default value\n     * @param timeoutMills the timeout mills\n     * @return the short\n     */</span>\n    short getShort(<span class=\"hljs-built_in\">String</span> dataId, int defaultValue, long timeoutMills);\n\n    <span class=\"hljs-comment\">//以下内容略，主要能力为配置的增删改查</span>\n}\n</code></pre>\n<ul>\n<li>Seata提供了一个类型为ExtConfigurationProvider的扩展点，开放了对配置具体实现的扩展能力，它具有一个provide()方法，接收原有的Configuration，返回一个全新的Configuration，此接口方法的形式决定了，一般可以采用静态代理、动态代理、装饰器等设计模式来实现此方法，实现对原有Configuration的增强</li>\n</ul>\n<pre><code class=\"language-js\"><span class=\"hljs-comment\">/**\n * Seata扩展配置提供者接口\n * package：io.seata.config\n */</span>\npublic interface ExtConfigurationProvider {\n    <span class=\"hljs-comment\">/**\n     * provide a AbstractConfiguration implementation instance\n     * @param originalConfiguration\n     * @return configuration\n     */</span>\n    Configuration provide(Configuration originalConfiguration);\n}\n</code></pre>\n<ul>\n<li>当应用侧基于seata-seata-spring-boot-starter启动时，将<strong>采用『SpringBootConfigurationProvider』作为扩展配置提供者</strong>，在其provide方法中，使用动态字节码生成（CGLIB）的方式为『FileConfiguration』实例创建了一个动态代理类，拦截了所有以&quot;get&quot;开头的方法，来从application.properties/application.yaml中获取元配置项。</li>\n</ul>\n<p>关于SpringBootConfigurationProvider类，本文只说明下实现思路，不再展开分析源码，这也仅是ExtConfigurationProvider接口的一种实现方式，从Configuration可扩展、可替换的角度来看，Seata正是通过ExtConfigurationProvider这样一个扩展点，为多种配置的实现提供了一个广阔的舞台，允许配置的多种实现与接入方案。</p>\n<p>经历过上述加载流程后，如果我们<strong>没有扩展配置提供者</strong>，我们将从Seata元配置文件中获取到注册中心的类型为file，同时创建了一个文件注册中心实例：FileRegistryServiceImpl</p>\n<h4>从注册中心获取TC Server地址</h4>\n<p>获取注册中心的实例后，需要执行lookup()方法（RegistryFactory.getInstance().<strong>lookup(transactionServiceGroup)</strong>），FileRegistryServiceImpl.lookup()的实现如下：</p>\n<pre><code class=\"language-js\">    <span class=\"hljs-comment\">/**\n     * 根据事务分组名称，获取TC Server可用地址列表\n     * package：io.seata.discovery.registry\n     * class：FileRegistryServiceImpl\n     */</span>\n    @Override\n    public List&lt;InetSocketAddress&gt; lookup(<span class=\"hljs-built_in\">String</span> key) throws Exception {\n        <span class=\"hljs-comment\">//获取TC Server集群名称</span>\n        <span class=\"hljs-built_in\">String</span> clusterName = getServiceGroup(key);\n        <span class=\"hljs-keyword\">if</span> (clusterName == <span class=\"hljs-literal\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n        }\n        <span class=\"hljs-comment\">//从配置中心中获取TC集群中所有可用的Server地址</span>\n        <span class=\"hljs-built_in\">String</span> endpointStr = CONFIG.getConfig(\n            PREFIX_SERVICE_ROOT + CONFIG_SPLIT_CHAR + clusterName + POSTFIX_GROUPLIST);\n        <span class=\"hljs-keyword\">if</span> (StringUtils.isNullOrEmpty(endpointStr)) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(clusterName + POSTFIX_GROUPLIST + <span class=\"hljs-string\">\" is required\"</span>);\n        }\n        <span class=\"hljs-comment\">//将地址封装为InetSocketAddress并返回</span>\n        <span class=\"hljs-built_in\">String</span>[] endpoints = endpointStr.split(ENDPOINT_SPLIT_CHAR);\n        List&lt;InetSocketAddress&gt; inetSocketAddresses = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">String</span> endpoint : endpoints) {\n            <span class=\"hljs-built_in\">String</span>[] ipAndPort = endpoint.split(IP_PORT_SPLIT_CHAR);\n            <span class=\"hljs-keyword\">if</span> (ipAndPort.length != <span class=\"hljs-number\">2</span>) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> IllegalArgumentException(<span class=\"hljs-string\">\"endpoint format should like ip:port\"</span>);\n            }\n            inetSocketAddresses.add(<span class=\"hljs-keyword\">new</span> InetSocketAddress(ipAndPort[<span class=\"hljs-number\">0</span>], Integer.parseInt(ipAndPort[<span class=\"hljs-number\">1</span>])));\n        }\n        <span class=\"hljs-keyword\">return</span> inetSocketAddresses;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 注册中心接口中的default方法\n     * package：io.seata.discovery.registry\n     * class：RegistryService\n     */</span>\n    <span class=\"hljs-keyword\">default</span> <span class=\"hljs-built_in\">String</span>  getServiceGroup(<span class=\"hljs-built_in\">String</span> key) {\n        key = PREFIX_SERVICE_ROOT + CONFIG_SPLIT_CHAR + PREFIX_SERVICE_MAPPING + key;\n        <span class=\"hljs-comment\">//在配置缓存中，添加事务分组名称变化监听事件</span>\n        <span class=\"hljs-keyword\">if</span> (!SERVICE_GROUP_NAME.contains(key)) {\n            ConfigurationCache.addConfigListener(key);\n            SERVICE_GROUP_NAME.add(key);\n        }\n        <span class=\"hljs-comment\">//从配置中心中获取事务分组对应的TC集群名称</span>\n        <span class=\"hljs-keyword\">return</span> ConfigurationFactory.getInstance().getConfig(key);\n    }\n</code></pre>\n<p>可以看到，代码逻辑与第一节中图<strong>Seata事务分组与建立连接的关系</strong>中的流程相符合，\n这时，注册中心将需要<strong>配置中心的协助</strong>，来获取事务分组对应的集群名称、并查找集群中可用的服务地址。</p>\n<h3>从<strong>配置中心</strong>获取TC集群名称</h3>\n<h4>配置中心的初始化</h4>\n<p>配置中心的初始化（在ConfigurationFactory.buildConfiguration()），与注册中心的初始化流程类似，都是先从<strong>元配置文件</strong>中获取配置中心的类型等信息，然后初始化一个具体的配置中心实例，有了之前的分析基础，这里不再赘述。</p>\n<h4>获取配置项的值</h4>\n<p>上方代码段的两个方法：*FileRegistryServiceImpl.lookup()<em>以及</em>RegistryService.getServiceGroup()*中，都从配置中心中获取的配置项的值：</p>\n<ul>\n<li>lookup()需要由具体的注册中心实现，使用文件作为注册中心，其实是一种直连TC Server的情况，其特殊点在于<strong>TC Server的地址是写死在配置中的</strong>的（正常应存于注册中心中），因此FileRegistryServiceImpl.lookup()方法，是通过配置中心获取的TC集群中Server的地址信息</li>\n<li>getServiceGroup()是RegistryServer接口中的default方法，即所有注册中心的公共实现，Seata中任何一种注册中心，都需要通过配置中心来根据事务分组名称来获取TC集群名称</li>\n</ul>\n<h3>负载均衡</h3>\n<p>经过上述环节配置中心、注册中心的协作，现在我们已经获取到了当前应用侧所有可用的TC Server地址，那么在发送真正的请求之前，还需要通过特定的负载均衡策略，选择一个TC Server地址，这部分源码比较简单，就不带着大家分析了。</p>\n<blockquote>\n<p>关于负载均衡的源码，大家可以阅读AbstractNettyRemotingClient.doSelect()，因本文分析的代码是RMClient/TMClient的重连方法，此方法中，所有获取到的Server地址，都会通过遍历依次连接（重连），因此这里不需要再做负载均衡。</p>\n</blockquote>\n<p>以上就是Seata应用侧在启动过程中，注册中心与配置中心这两个关键模块之间的协作关系与工作流程，欢迎共同探讨、学习！</p>\n<blockquote>\n<p>后记：本文及其上篇<a href=\"http://booogu.top/2021/02/28/seata-client-start-analysis-01/\"> Seata客户端启动过程剖析（一）</a>，是本人撰写的首批技术博客，将上手Seata时，个人认为Seata中较为复杂、需要研究和弄通的部分源码进行了分析和记录。\n在此欢迎各位读者提出各种改进建议，谢谢！</p>\n</blockquote>\n",
  "link": "/zh-cn/blog/seata-client-start-analysis-02.html",
  "meta": {
    "layout": "post",
    "comments": "true",
    "title": "Seata应用侧启动过程剖析——注册中心与配置中心模块",
    "date": "2021-03-04 1:35:01",
    "author": "\"booogu\"",
    "catalog": "true",
    "tags": "",
    "- Seata": ""
  }
}