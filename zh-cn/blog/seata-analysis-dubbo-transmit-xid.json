{
  "filename": "seata-analysis-dubbo-transmit-xid.md",
  "__html": "<h1>源码分析Seata-XID传递 Dubbo篇</h1>\n<p>本文作者：FUNKYE(陈健斌),杭州某互联网公司主程。</p>\n<h1>前言</h1>\n<p>​\t1.首先来看下包结构,在seata-dubbo和seata-dubbo-alibaba下有统一由TransactionPropagationFilter这个类,分别对应apache-dubbo跟alibaba-dubbo.</p>\n<p><img src=\"/img/blog/20200101203229.png\" alt=\"20200101203229\"></p>\n<h2>分析源码</h2>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">package</span> io.seata.integration.dubbo;\n\n<span class=\"hljs-keyword\">import</span> io.seata.core.context.RootContext;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.common.Constants;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.common.extension.Activate;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.Filter;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.Invocation;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.Invoker;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.Result;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.RpcContext;\n<span class=\"hljs-keyword\">import</span> org.apache.dubbo.rpc.RpcException;\n<span class=\"hljs-keyword\">import</span> org.slf4j.Logger;\n<span class=\"hljs-keyword\">import</span> org.slf4j.LoggerFactory;\n\n<span class=\"hljs-meta\">@Activate</span>(group = {Constants.PROVIDER, Constants.CONSUMER}, order = <span class=\"hljs-number\">100</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TransactionPropagationFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">Filter</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Logger LOGGER = LoggerFactory.getLogger(TransactionPropagationFilter.class);\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Result <span class=\"hljs-title\">invoke</span><span class=\"hljs-params\">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class=\"hljs-keyword\">throws</span> RpcException </span>{\n        <span class=\"hljs-comment\">//获取本地XID</span>\n        String xid = RootContext.getXID();\n        String xidInterceptorType = RootContext.getXIDInterceptorType();\n        <span class=\"hljs-comment\">//获取Dubbo隐式传参中的XID</span>\n        String rpcXid = getRpcXid();\n        String rpcXidInterceptorType = RpcContext.getContext().getAttachment(RootContext.KEY_XID_INTERCEPTOR_TYPE);\n        <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(<span class=\"hljs-string\">\"xid in RootContext[{}] xid in RpcContext[{}]\"</span>, xid, rpcXid);\n        }\n        <span class=\"hljs-keyword\">boolean</span> bind = <span class=\"hljs-keyword\">false</span>;\n        <span class=\"hljs-keyword\">if</span> (xid != <span class=\"hljs-keyword\">null</span>) {\n            <span class=\"hljs-comment\">//传递XID</span>\n            RpcContext.getContext().setAttachment(RootContext.KEY_XID, xid);\n            RpcContext.getContext().setAttachment(RootContext.KEY_XID_INTERCEPTOR_TYPE, xidInterceptorType);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> (rpcXid != <span class=\"hljs-keyword\">null</span>) {\n                <span class=\"hljs-comment\">//绑定XID</span>\n                RootContext.bind(rpcXid);\n                RootContext.bindInterceptorType(rpcXidInterceptorType);\n                bind = <span class=\"hljs-keyword\">true</span>;\n                <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(<span class=\"hljs-string\">\"bind[{}] interceptorType[{}] to RootContext\"</span>, rpcXid, rpcXidInterceptorType);\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-keyword\">return</span> invoker.invoke(invocation);\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-keyword\">if</span> (bind) {\n                <span class=\"hljs-comment\">//进行剔除已完成事务的XID</span>\n                String unbindInterceptorType = RootContext.unbindInterceptorType();\n                String unbindXid = RootContext.unbind();\n                <span class=\"hljs-keyword\">if</span> (LOGGER.isDebugEnabled()) {\n                    LOGGER.debug(<span class=\"hljs-string\">\"unbind[{}] interceptorType[{}] from RootContext\"</span>, unbindXid, unbindInterceptorType);\n                }\n                <span class=\"hljs-comment\">//如果发现解绑的XID并不是当前接收到的XID</span>\n                <span class=\"hljs-keyword\">if</span> (!rpcXid.equalsIgnoreCase(unbindXid)) {\n                    LOGGER.warn(<span class=\"hljs-string\">\"xid in change during RPC from {} to {}, xidInterceptorType from {} to {} \"</span>, rpcXid, unbindXid, rpcXidInterceptorType, unbindInterceptorType);\n                    <span class=\"hljs-keyword\">if</span> (unbindXid != <span class=\"hljs-keyword\">null</span>) {\n                        <span class=\"hljs-comment\">//重新绑定XID</span>\n                        RootContext.bind(unbindXid);\n                        RootContext.bindInterceptorType(unbindInterceptorType);\n                        LOGGER.warn(<span class=\"hljs-string\">\"bind [{}] interceptorType[{}] back to RootContext\"</span>, unbindXid, unbindInterceptorType);\n                    }\n                }\n            }\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * get rpc xid\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> String <span class=\"hljs-title\">getRpcXid</span><span class=\"hljs-params\">()</span> </span>{\n        String rpcXid = RpcContext.getContext().getAttachment(RootContext.KEY_XID);\n        <span class=\"hljs-keyword\">if</span> (rpcXid == <span class=\"hljs-keyword\">null</span>) {\n            rpcXid = RpcContext.getContext().getAttachment(RootContext.KEY_XID.toLowerCase());\n        }\n        <span class=\"hljs-keyword\">return</span> rpcXid;\n    }\n\n}\n</code></pre>\n<p>​\t1.根据源码,我们可以推出相应的逻辑处理</p>\n<p><img src=\"/img/blog/20200101213336.png\" alt=\"20200101213336\"></p>\n<h2>要点知识</h2>\n<p>​\t1.Dubbo @Activate注解:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Documented</span>\n<span class=\"hljs-meta\">@Retention</span>(RetentionPolicy.RUNTIME)\n<span class=\"hljs-meta\">@Target</span>({ElementType.TYPE, ElementType.METHOD})\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-meta\">@interface</span> Activate {\n    <span class=\"hljs-comment\">/**\n     * Group过滤条件。\n     * &lt;br /&gt;\n     * 包含{<span class=\"hljs-doctag\">@link</span> ExtensionLoader#getActivateExtension}的group参数给的值，则返回扩展。\n     * &lt;br /&gt;\n     * 如没有Group设置，则不过滤。\n     */</span>\n    String[] group() <span class=\"hljs-keyword\">default</span> {};\n\n    <span class=\"hljs-comment\">/**\n     * Key过滤条件。包含{<span class=\"hljs-doctag\">@link</span> ExtensionLoader#getActivateExtension}的URL的参数Key中有，则返回扩展。\n     * &lt;p/&gt;\n     * 示例：&lt;br/&gt;\n     * 注解的值 &lt;code&gt;<span class=\"hljs-doctag\">@Activate</span>(\"cache,validatioin\")&lt;/code&gt;，\n     * 则{<span class=\"hljs-doctag\">@link</span> ExtensionLoader#getActivateExtension}的URL的参数有&lt;code&gt;cache&lt;/code&gt;Key，或是&lt;code&gt;validatioin&lt;/code&gt;则返回扩展。\n     * &lt;br/&gt;\n     * 如没有设置，则不过滤。\n     */</span>\n    String[] value() <span class=\"hljs-keyword\">default</span> {};\n\n    <span class=\"hljs-comment\">/**\n     * 排序信息，可以不提供。\n     */</span>\n    String[] before() <span class=\"hljs-keyword\">default</span> {};\n\n    <span class=\"hljs-comment\">/**\n     * 排序信息，可以不提供。\n     */</span>\n    String[] after() <span class=\"hljs-keyword\">default</span> {};\n\n    <span class=\"hljs-comment\">/**\n     * 排序信息，可以不提供。\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">order</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">default</span> 0</span>;\n}\n</code></pre>\n<p>可以分析得知,Seata的dubbo过滤器上的注解@Activate(group = {Constants.PROVIDER, Constants.CONSUMER}, order = 100),表示dubbo的服务提供方跟消费方都会触发到这个过滤器,所以我们的Seata发起者会产生一个XID的传递,上述流程图跟代码已经很清晰的表示了.</p>\n<p>​\t2.Dubbo隐式传参可以通过 <code>RpcContext</code> 上的 <code>setAttachment</code> 和 <code>getAttachment</code> 在服务消费方和提供方之间进行参数的隐式传递。</p>\n<p>获取:RpcContext.getContext().getAttachment(RootContext.KEY_XID);</p>\n<p>传递:RpcContext.getContext().setAttachment(RootContext.KEY_XID, xid);</p>\n<h1>总结</h1>\n<p>更多源码阅读请访问<a href=\"http://seata.io/zh-cn/index.html\">Seata官网</a></p>\n",
  "link": "/zh-cn/blog/seata-analysis-dubbo-transmit-xid.html",
  "meta": {
    "title": "源码分析Seata-XID传递 Dubbo篇",
    "keywords": "Seata,Dubbo,分布式事务,spring",
    "description": "本文讲述通过源码解析Seata-Dubbo传递XID",
    "author": "FUNKYE",
    "date": "2020/01/01"
  }
}