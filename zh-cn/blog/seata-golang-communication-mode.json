{
  "filename": "seata-golang-communication-mode.md",
  "__html": "<h1>基于 getty 的 seata-golang 通信模型详解</h1>\n<p>作者 | 刘晓敏 于雨</p>\n<h2>一、简介</h2>\n<p>Java 的世界里，大家广泛使用的一个高性能网络通信框架 netty，很多 RPC 框架都是基于 netty 来实现的。在 golang 的世界里，<a href=\"https://github.com/AlexStocks/getty\">getty</a> 也是一个类似 netty 的高性能网络通信库。getty 最初由 dubbogo 项目负责人于雨开发，作为底层通信库在 <a href=\"https://github.com/apache/dubbo-go\">dubbo-go</a> 中使用。随着 dubbo-go 捐献给 apache 基金会，在社区小伙伴的共同努力下，getty 也最终进入到 apache 这个大家庭，并改名 <a href=\"https://github.com/apache/dubbo-getty\">dubbo-getty</a> 。</p>\n<p>18 年的时候，我在公司里实践微服务，当时遇到最大的问题就是分布式事务问题。同年，阿里在社区开源他们的分布式事务解决方案，我也很快关注到这个项目，起初还叫 fescar，后来更名 seata。由于我对开源技术很感兴趣，加了很多社区群，当时也很关注 dubbo-go 这个项目，在里面默默潜水。随着对 seata 的了解，逐渐萌生了做一个 go 版本的分布式事务框架的想法。</p>\n<p>要做一个 golang 版的分布式事务框架，首要的一个问题就是如何实现 RPC 通信。dubbo-go 就是很好的一个例子摆在眼前，遂开始研究 dubbo-go 的底层 getty。</p>\n<h2>二、如何基于 getty 实现 RPC 通信</h2>\n<p>getty 框架的整体模型图如下：</p>\n<p><img src=\"https://img.alicdn.com/imgextra/i1/O1CN011TIcL01jY4JaweOfV_!!6000000004559-2-tps-954-853.png\" alt=\"image.png\"></p>\n<p>下面结合相关代码，详述 seata-golang 的 RPC 通信过程。</p>\n<h3>1. 建立连接</h3>\n<p>实现 RPC 通信，首先要建立网络连接吧，我们从 <a href=\"https://github.com/apache/dubbo-getty/blob/master/client.go\">client.go</a> 开始看起。</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *client)</span> <span class=\"hljs-title\">connect</span><span class=\"hljs-params\">()</span></span> {\n\t<span class=\"hljs-keyword\">var</span> (\n\t\terr error\n\t\tss  Session\n\t)\n\n\t<span class=\"hljs-keyword\">for</span> {\n        <span class=\"hljs-comment\">// 建立一个 session 连接</span>\n\t\tss = c.dial()\n\t\t<span class=\"hljs-keyword\">if</span> ss == <span class=\"hljs-literal\">nil</span> {\n\t\t\t<span class=\"hljs-comment\">// client has been closed</span>\n\t\t\t<span class=\"hljs-keyword\">break</span>\n\t\t}\n\t\terr = c.newSession(ss)\n\t\t<span class=\"hljs-keyword\">if</span> err == <span class=\"hljs-literal\">nil</span> {\n            <span class=\"hljs-comment\">// 收发报文</span>\n\t\t\tss.(*session).run()\n\t\t\t<span class=\"hljs-comment\">// 此处省略部分代码</span>\n      \n\t\t\t<span class=\"hljs-keyword\">break</span>\n\t\t}\n\t\t<span class=\"hljs-comment\">// don't distinguish between tcp connection and websocket connection. Because</span>\n\t\t<span class=\"hljs-comment\">// gorilla/websocket/conn.go:(Conn)Close also invoke net.Conn.Close()</span>\n\t\tss.Conn().Close()\n\t}\n}\n</code></pre>\n<p><code>connect()</code> 方法通过 <code>dial()</code> 方法得到了一个 session 连接，进入 dial() 方法：</p>\n<pre><code>func (c *client) dial() Session {\n\tswitch c.endPointType {\n\tcase TCP_CLIENT:\n\t\treturn c.dialTCP()\n\tcase UDP_CLIENT:\n\t\treturn c.dialUDP()\n\tcase WS_CLIENT:\n\t\treturn c.dialWS()\n\tcase WSS_CLIENT:\n\t\treturn c.dialWSS()\n\t}\n\n\treturn nil\n}\n</code></pre>\n<p>我们关注的是 TCP 连接，所以继续进入 <code>c.dialTCP()</code> 方法：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *client)</span> <span class=\"hljs-title\">dialTCP</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">Session</span></span> {\n\t<span class=\"hljs-keyword\">var</span> (\n\t\terr  error\n\t\tconn net.Conn\n\t)\n\n\t<span class=\"hljs-keyword\">for</span> {\n\t\t<span class=\"hljs-keyword\">if</span> c.IsClosed() {\n\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t\t}\n\t\t<span class=\"hljs-keyword\">if</span> c.sslEnabled {\n\t\t\t<span class=\"hljs-keyword\">if</span> sslConfig, err := c.tlsConfigBuilder.BuildTlsConfig(); err == <span class=\"hljs-literal\">nil</span> &amp;&amp; sslConfig != <span class=\"hljs-literal\">nil</span> {\n\t\t\t\td := &amp;net.Dialer{Timeout: connectTimeout}\n\t\t\t\t<span class=\"hljs-comment\">// 建立加密连接</span>\n\t\t\t\tconn, err = tls.DialWithDialer(d, <span class=\"hljs-string\">\"tcp\"</span>, c.addr, sslConfig)\n\t\t\t}\n\t\t} <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// 建立 tcp 连接</span>\n\t\t\tconn, err = net.DialTimeout(<span class=\"hljs-string\">\"tcp\"</span>, c.addr, connectTimeout)\n\t\t}\n\t\t<span class=\"hljs-keyword\">if</span> err == <span class=\"hljs-literal\">nil</span> &amp;&amp; gxnet.IsSameAddr(conn.RemoteAddr(), conn.LocalAddr()) {\n\t\t\tconn.Close()\n\t\t\terr = errSelfConnect\n\t\t}\n\t\t<span class=\"hljs-keyword\">if</span> err == <span class=\"hljs-literal\">nil</span> {\n            <span class=\"hljs-comment\">// 返回一个 TCPSession</span>\n\t\t\t<span class=\"hljs-keyword\">return</span> newTCPSession(conn, c)\n\t\t}\n\n\t\tlog.Infof(<span class=\"hljs-string\">\"net.DialTimeout(addr:%s, timeout:%v) = error:%+v\"</span>, c.addr, connectTimeout, perrors.WithStack(err))\n\t\t&lt;-wheel.After(connectInterval)\n\t}\n}\n</code></pre>\n<p>至此，我们知道了 getty 如何建立 TCP 连接，并返回 TCPSession。</p>\n<h3>2. 收发报文</h3>\n<p>那它是怎么收发报文的呢，我们回到 connection 方法接着往下看，有这样一行 <code>ss.(*session).run()</code>，在这行代码之后代码都是很简单的操作，我们猜测这行代码运行的逻辑里面一定包含收发报文的逻辑，接着进入 <code>run()</code> 方法：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s *session)</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span> {\n\t<span class=\"hljs-comment\">// 省略部分代码</span>\n  \n\t<span class=\"hljs-keyword\">go</span> s.handleLoop()\n\t<span class=\"hljs-keyword\">go</span> s.handlePackage()\n}\n</code></pre>\n<p>这里起了两个 goroutine，<code>handleLoop</code> 和 <code>handlePackage</code>，看字面意思符合我们的猜想，进入 <code>handleLoop()</code> 方法：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s *session)</span> <span class=\"hljs-title\">handleLoop</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-comment\">// 省略部分代码</span>\n  \n\t<span class=\"hljs-keyword\">for</span> {\n\t\t<span class=\"hljs-comment\">// A select blocks until one of its cases is ready to run.</span>\n\t\t<span class=\"hljs-comment\">// It choose one at random if multiple are ready. Otherwise it choose default branch if none is ready.</span>\n\t\t<span class=\"hljs-keyword\">select</span> {\n\t\t<span class=\"hljs-comment\">// 省略部分代码</span>\n      \n\t\t<span class=\"hljs-keyword\">case</span> outPkg, ok = &lt;-s.wQ:\n\t\t\t<span class=\"hljs-comment\">// 省略部分代码</span>\n\n\t\t\tiovec = iovec[:<span class=\"hljs-number\">0</span>]\n\t\t\t<span class=\"hljs-keyword\">for</span> idx := <span class=\"hljs-number\">0</span>; idx &lt; maxIovecNum; idx++ {\n        <span class=\"hljs-comment\">// 通过 s.writer 将 interface{} 类型的 outPkg 编码成二进制的比特</span>\n\t\t\t\tpkgBytes, err = s.writer.Write(s, outPkg)\n\t\t\t\t<span class=\"hljs-comment\">// 省略部分代码</span>\n        \n\t\t\t\tiovec = <span class=\"hljs-built_in\">append</span>(iovec, pkgBytes)\n\n                <span class=\"hljs-comment\">//省略部分代码</span>\n\t\t\t}\n            <span class=\"hljs-comment\">// 将这些二进制比特发送出去</span>\n\t\t\terr = s.WriteBytesArray(iovec[:]...)\n\t\t\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t\t\tlog.Errorf(<span class=\"hljs-string\">\"%s, [session.handleLoop]s.WriteBytesArray(iovec len:%d) = error:%+v\"</span>,\n\t\t\t\t\ts.sessionToken(), <span class=\"hljs-built_in\">len</span>(iovec), perrors.WithStack(err))\n\t\t\t\ts.stop()\n\t\t\t\t<span class=\"hljs-comment\">// break LOOP</span>\n\t\t\t\tflag = <span class=\"hljs-literal\">false</span>\n\t\t\t}\n\n\t\t<span class=\"hljs-keyword\">case</span> &lt;-wheel.After(s.period):\n\t\t\t<span class=\"hljs-keyword\">if</span> flag {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> wsFlag {\n\t\t\t\t\terr := wsConn.writePing()\n\t\t\t\t\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t\t\t\t\tlog.Warnf(<span class=\"hljs-string\">\"wsConn.writePing() = error:%+v\"</span>, perrors.WithStack(err))\n\t\t\t\t\t}\n\t\t\t\t}\n                <span class=\"hljs-comment\">// 定时执行的逻辑，心跳等</span>\n\t\t\t\ts.listener.OnCron(s)\n\t\t\t}\n\t\t}\n\t}\n}\n</code></pre>\n<p>通过上面的代码，我们不难发现，<code>handleLoop()</code> 方法处理的是发送报文的逻辑，RPC 需要发送的消息首先由 <code>s.writer</code> 编码成二进制比特，然后通过建立的 TCP 连接发送出去。这个 <code>s.writer</code> 对应的 Writer 接口是 RPC 框架必须要实现的一个接口。</p>\n<p>继续看 <code>handlePackage()</code> 方法：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s *session)</span> <span class=\"hljs-title\">handlePackage</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-comment\">// 省略部分代码</span>\n\n\t<span class=\"hljs-keyword\">if</span> _, ok := s.Connection.(*gettyTCPConn); ok {\n\t\t<span class=\"hljs-keyword\">if</span> s.reader == <span class=\"hljs-literal\">nil</span> {\n\t\t\terrStr := fmt.Sprintf(<span class=\"hljs-string\">\"session{name:%s, conn:%#v, reader:%#v}\"</span>, s.name, s.Connection, s.reader)\n\t\t\tlog.Error(errStr)\n\t\t\t<span class=\"hljs-built_in\">panic</span>(errStr)\n\t\t}\n\n\t\terr = s.handleTCPPackage()\n\t} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> _, ok := s.Connection.(*gettyWSConn); ok {\n\t\terr = s.handleWSPackage()\n\t} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> _, ok := s.Connection.(*gettyUDPConn); ok {\n\t\terr = s.handleUDPPackage()\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\t<span class=\"hljs-built_in\">panic</span>(fmt.Sprintf(<span class=\"hljs-string\">\"unknown type session{%#v}\"</span>, s))\n\t}\n}\n</code></pre>\n<p>进入 <code>handleTCPPackage()</code> 方法：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s *session)</span> <span class=\"hljs-title\">handleTCPPackage</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">error</span></span> {\n    <span class=\"hljs-comment\">// 省略部分代码</span>\n\n\tconn = s.Connection.(*gettyTCPConn)\n\t<span class=\"hljs-keyword\">for</span> {\n\t\t<span class=\"hljs-comment\">// 省略部分代码</span>\n\n\t\tbufLen = <span class=\"hljs-number\">0</span>\n\t\t<span class=\"hljs-keyword\">for</span> {\n\t\t\t<span class=\"hljs-comment\">// for clause for the network timeout condition check</span>\n\t\t\t<span class=\"hljs-comment\">// s.conn.SetReadTimeout(time.Now().Add(s.rTimeout))</span>\n            <span class=\"hljs-comment\">// 从 TCP 连接中收到报文</span>\n\t\t\tbufLen, err = conn.recv(buf)\n\t\t\t<span class=\"hljs-comment\">// 省略部分代码</span>\n      \n\t\t\t<span class=\"hljs-keyword\">break</span>\n\t\t}\n\t\t<span class=\"hljs-comment\">// 省略部分代码</span>\n    \n        <span class=\"hljs-comment\">// 将收到的报文二进制比特写入 pkgBuf</span>\n\t\tpktBuf.Write(buf[:bufLen])\n\t\t<span class=\"hljs-keyword\">for</span> {\n\t\t\t<span class=\"hljs-keyword\">if</span> pktBuf.Len() &lt;= <span class=\"hljs-number\">0</span> {\n\t\t\t\t<span class=\"hljs-keyword\">break</span>\n\t\t\t}\n            <span class=\"hljs-comment\">// 通过 s.reader 将收到的报文解码成 RPC 消息</span>\n\t\t\tpkg, pkgLen, err = s.reader.Read(s, pktBuf.Bytes())\n\t\t\t<span class=\"hljs-comment\">// 省略部分代码</span>\n\n      s.UpdateActive()\n            <span class=\"hljs-comment\">// 将收到的消息放入 TaskQueue 供 RPC 消费端消费</span>\n\t\t\ts.addTask(pkg)\n\t\t\tpktBuf.Next(pkgLen)\n\t\t\t<span class=\"hljs-comment\">// continue to handle case 5</span>\n\t\t}\n\t\t<span class=\"hljs-keyword\">if</span> exit {\n\t\t\t<span class=\"hljs-keyword\">break</span>\n\t\t}\n\t}\n\n\t<span class=\"hljs-keyword\">return</span> perrors.WithStack(err)\n}\n</code></pre>\n<p>从上面的代码逻辑我们分析出，RPC 消费端需要将从 TCP 连接收到的二进制比特报文解码成 RPC 能消费的消息，这个工作由 s.reader 实现，所以，我们要构建 RPC 通信层也需要实现 s.reader 对应的 Reader 接口。</p>\n<h3>3. 底层处理网络报文的逻辑如何与业务逻辑解耦</h3>\n<p>我们都知道，netty 通过 boss 线程和 worker 线程实现了底层网络逻辑和业务逻辑的解耦。那么，getty 是如何实现的呢？</p>\n<p>在 <code>handlePackage()</code> 方法最后，我们看到，收到的消息被放入了 <code>s.addTask(pkg)</code> 这个方法，接着往下分析：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s *session)</span> <span class=\"hljs-title\">addTask</span><span class=\"hljs-params\">(pkg <span class=\"hljs-keyword\">interface</span>{})</span></span> {\n\tf := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n\t\ts.listener.OnMessage(s, pkg)\n\t\ts.incReadPkgNum()\n\t}\n\t<span class=\"hljs-keyword\">if</span> taskPool := s.EndPoint().GetTaskPool(); taskPool != <span class=\"hljs-literal\">nil</span> {\n\t\ttaskPool.AddTaskAlways(f)\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\tf()\n}\n</code></pre>\n<p><code>pkg</code> 参数传递到了一个匿名方法，这个方法最终放入了 <code>taskPool</code>。这个方法很关键，在我后来写 seata-golang 代码的时候，就遇到了一个坑，这个坑后面分析。</p>\n<p>接着我们看一下 <a href=\"https://github.com/dubbogo/gost/blob/master/sync/task_pool.go\">taskPool</a> 的定义：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// NewTaskPoolSimple build a simple task pool</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewTaskPoolSimple</span><span class=\"hljs-params\">(size <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">GenericTaskPool</span></span> {\n\t<span class=\"hljs-keyword\">if</span> size &lt; <span class=\"hljs-number\">1</span> {\n\t\tsize = runtime.NumCPU() * <span class=\"hljs-number\">100</span>\n\t}\n\t<span class=\"hljs-keyword\">return</span> &amp;taskPoolSimple{\n\t\twork: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> task),\n\t\tsem:  <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">struct</span>{}, size),\n\t\tdone: <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">chan</span> <span class=\"hljs-keyword\">struct</span>{}),\n\t}\n}\n</code></pre>\n<p>构建了一个缓冲大小为 size （默认为  <code>runtime.NumCPU() * 100</code>） 的 channel <code>sem</code>。再看方法 <code>AddTaskAlways(t task)</code>：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(p *taskPoolSimple)</span> <span class=\"hljs-title\">AddTaskAlways</span><span class=\"hljs-params\">(t task)</span></span> {\n\t<span class=\"hljs-keyword\">select</span> {\n\t<span class=\"hljs-keyword\">case</span> &lt;-p.done:\n\t\t<span class=\"hljs-keyword\">return</span>\n\t<span class=\"hljs-keyword\">default</span>:\n\t}\n\n\t<span class=\"hljs-keyword\">select</span> {\n\t<span class=\"hljs-keyword\">case</span> p.work &lt;- t:\n\t\t<span class=\"hljs-keyword\">return</span>\n\t<span class=\"hljs-keyword\">default</span>:\n\t}\n\t<span class=\"hljs-keyword\">select</span> {\n\t<span class=\"hljs-keyword\">case</span> p.work &lt;- t:\n\t<span class=\"hljs-keyword\">case</span> p.sem &lt;- <span class=\"hljs-keyword\">struct</span>{}{}:\n\t\tp.wg.Add(<span class=\"hljs-number\">1</span>)\n\t\t<span class=\"hljs-keyword\">go</span> p.worker(t)\n\t<span class=\"hljs-keyword\">default</span>:\n\t\tgoSafely(t)\n\t}\n}\n</code></pre>\n<p>加入的任务，会先由 len(p.sem) 个 goroutine 去消费，如果没有 goroutine 空闲，则会启动一个临时的 goroutine 去运行 t()。相当于有  len(p.sem) 个 goroutine 组成了 goroutine pool，pool 中的 goroutine 去处理业务逻辑，而不是由处理网络报文的 goroutine 去运行业务逻辑，从而实现了解耦。写 seata-golang 时遇到的一个坑，就是忘记设置 taskPool 造成了处理业务逻辑和处理底层网络报文逻辑的 goroutine 是同一个，我在业务逻辑中阻塞等待一个任务完成时，阻塞了整个 goroutine，使得阻塞期间收不到任何报文。</p>\n<h3>4. 具体实现</h3>\n<p>下面的代码见 <a href=\"https://github.com/apache/dubbo-getty/blob/master/getty.go\">getty.go</a>：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// Reader is used to unmarshal a complete pkg from buffer</span>\n<span class=\"hljs-keyword\">type</span> Reader <span class=\"hljs-keyword\">interface</span> {\n\tRead(Session, []<span class=\"hljs-keyword\">byte</span>) (<span class=\"hljs-keyword\">interface</span>{}, <span class=\"hljs-keyword\">int</span>, error)\n}\n\n<span class=\"hljs-comment\">// Writer is used to marshal pkg and write to session</span>\n<span class=\"hljs-keyword\">type</span> Writer <span class=\"hljs-keyword\">interface</span> {\n\t<span class=\"hljs-comment\">// if @Session is udpGettySession, the second parameter is UDPContext.</span>\n\tWrite(Session, <span class=\"hljs-keyword\">interface</span>{}) ([]<span class=\"hljs-keyword\">byte</span>, error)\n}\n\n<span class=\"hljs-comment\">// ReadWriter interface use for handle application packages</span>\n<span class=\"hljs-keyword\">type</span> ReadWriter <span class=\"hljs-keyword\">interface</span> {\n\tReader\n\tWriter\n}\n</code></pre>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// EventListener is used to process pkg that received from remote session</span>\n<span class=\"hljs-keyword\">type</span> EventListener <span class=\"hljs-keyword\">interface</span> {\n\t<span class=\"hljs-comment\">// invoked when session opened</span>\n\t<span class=\"hljs-comment\">// If the return error is not nil, @Session will be closed.</span>\n\tOnOpen(Session) error\n\n\t<span class=\"hljs-comment\">// invoked when session closed.</span>\n\tOnClose(Session)\n\n\t<span class=\"hljs-comment\">// invoked when got error.</span>\n\tOnError(Session, error)\n\n\t<span class=\"hljs-comment\">// invoked periodically, its period can be set by (Session)SetCronPeriod</span>\n\tOnCron(Session)\n\n\t<span class=\"hljs-comment\">// invoked when getty received a package. Pls attention that do not handle long time</span>\n\t<span class=\"hljs-comment\">// logic processing in this func. You'd better set the package's maximum length.</span>\n\t<span class=\"hljs-comment\">// If the message's length is greater than it, u should should return err in</span>\n\t<span class=\"hljs-comment\">// Reader{Read} and getty will close this connection soon.</span>\n\t<span class=\"hljs-comment\">//</span>\n\t<span class=\"hljs-comment\">// If ur logic processing in this func will take a long time, u should start a goroutine</span>\n\t<span class=\"hljs-comment\">// pool(like working thread pool in cpp) to handle the processing asynchronously. Or u</span>\n\t<span class=\"hljs-comment\">// can do the logic processing in other asynchronous way.</span>\n\t<span class=\"hljs-comment\">// !!!In short, ur OnMessage callback func should return asap.</span>\n\t<span class=\"hljs-comment\">//</span>\n\t<span class=\"hljs-comment\">// If this is a udp event listener, the second parameter type is UDPContext.</span>\n\tOnMessage(Session, <span class=\"hljs-keyword\">interface</span>{})\n}\n</code></pre>\n<p>通过对整个 getty 代码的分析，我们只要实现  <code>ReadWriter</code> 来对 RPC  消息编解码，再实现 <code>EventListener</code> 来处理 RPC 消息的对应的具体逻辑，将 <code>ReadWriter</code> 实现和 <code>EventLister</code> 实现注入到 RPC 的 Client 和 Server 端，则可实现 RPC 通信。</p>\n<h4>4.1 编解码协议实现</h4>\n<p>下面是 seata 协议的定义：\n<img src=\"https://cdn.nlark.com/yuque/0/2020/png/737378/1607180799872-5f96afb6-680d-4e69-8c95-b8fd1ac4c3a7.png#align=left&amp;display=inline&amp;height=209&amp;margin=%5Bobject%20Object%5D&amp;name=image-20201205214556457.png&amp;originHeight=209&amp;originWidth=690&amp;size=18407&amp;status=done&amp;style=none&amp;width=690\" alt=\"image-20201205214556457.png\"></p>\n<p>在 ReadWriter 接口的实现 <a href=\"https://github.com/opentrx/seata-golang\"><code>RpcPackageHandler</code></a> 中，调用 Codec 方法对消息体按照上面的格式编解码：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// 消息编码为二进制比特</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">MessageEncoder</span><span class=\"hljs-params\">(codecType <span class=\"hljs-keyword\">byte</span>, in <span class=\"hljs-keyword\">interface</span>{})</span> []<span class=\"hljs-title\">byte</span></span> {\n\t<span class=\"hljs-keyword\">switch</span> codecType {\n\t<span class=\"hljs-keyword\">case</span> SEATA:\n\t\t<span class=\"hljs-keyword\">return</span> SeataEncoder(in)\n\t<span class=\"hljs-keyword\">default</span>:\n\t\tlog.Errorf(<span class=\"hljs-string\">\"not support codecType, %s\"</span>, codecType)\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t}\n}\n\n<span class=\"hljs-comment\">// 二进制比特解码为消息体</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">MessageDecoder</span><span class=\"hljs-params\">(codecType <span class=\"hljs-keyword\">byte</span>, in []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">interface</span>{}, <span class=\"hljs-keyword\">int</span>)</span></span> {\n\t<span class=\"hljs-keyword\">switch</span> codecType {\n\t<span class=\"hljs-keyword\">case</span> SEATA:\n\t\t<span class=\"hljs-keyword\">return</span> SeataDecoder(in)\n\t<span class=\"hljs-keyword\">default</span>:\n\t\tlog.Errorf(<span class=\"hljs-string\">\"not support codecType, %s\"</span>, codecType)\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, <span class=\"hljs-number\">0</span>\n\t}\n}\n</code></pre>\n<h4>4.2 Client 端实现</h4>\n<p>再来看 client 端 <code>EventListener</code> 的实现 <a href=\"https://github.com/opentrx/seata-golang/blob/dev/pkg/client/rpc_remoting_client.go\"><code>RpcRemotingClient</code></a>：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(client *RpcRemoteClient)</span> <span class=\"hljs-title\">OnOpen</span><span class=\"hljs-params\">(session getty.Session)</span> <span class=\"hljs-title\">error</span></span> {\n\t<span class=\"hljs-keyword\">go</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span> \n\t\t<span class=\"hljs-title\">request</span> := <span class=\"hljs-title\">protocal</span>.<span class=\"hljs-title\">RegisterTMRequest</span></span>{AbstractIdentifyRequest: protocal.AbstractIdentifyRequest{\n\t\t\tApplicationId:           client.conf.ApplicationId,\n\t\t\tTransactionServiceGroup: client.conf.TransactionServiceGroup,\n\t\t}}\n    <span class=\"hljs-comment\">// 建立连接后向 Transaction Coordinator 发起注册 TransactionManager 的请求</span>\n\t\t_, err := client.sendAsyncRequestWithResponse(session, request, RPC_REQUEST_TIMEOUT)\n\t\t<span class=\"hljs-keyword\">if</span> err == <span class=\"hljs-literal\">nil</span> {\n      <span class=\"hljs-comment\">// 将与 Transaction Coordinator 建立的连接保存在连接池供后续使用</span>\n\t\t\tclientSessionManager.RegisterGettySession(session)\n\t\t\tclient.GettySessionOnOpenChannel &lt;- session.RemoteAddr()\n\t\t}\n\t}()\n\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-comment\">// OnError ...</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(client *RpcRemoteClient)</span> <span class=\"hljs-title\">OnError</span><span class=\"hljs-params\">(session getty.Session, err error)</span></span> {\n\tclientSessionManager.ReleaseGettySession(session)\n}\n\n<span class=\"hljs-comment\">// OnClose ...</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(client *RpcRemoteClient)</span> <span class=\"hljs-title\">OnClose</span><span class=\"hljs-params\">(session getty.Session)</span></span> {\n\tclientSessionManager.ReleaseGettySession(session)\n}\n\n<span class=\"hljs-comment\">// OnMessage ...</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(client *RpcRemoteClient)</span> <span class=\"hljs-title\">OnMessage</span><span class=\"hljs-params\">(session getty.Session, pkg <span class=\"hljs-keyword\">interface</span>{})</span></span> {\n\tlog.Info(<span class=\"hljs-string\">\"received message:{%v}\"</span>, pkg)\n\trpcMessage, ok := pkg.(protocal.RpcMessage)\n\t<span class=\"hljs-keyword\">if</span> ok {\n\t\theartBeat, isHeartBeat := rpcMessage.Body.(protocal.HeartBeatMessage)\n\t\t<span class=\"hljs-keyword\">if</span> isHeartBeat &amp;&amp; heartBeat == protocal.HeartBeatMessagePong {\n\t\t\tlog.Debugf(<span class=\"hljs-string\">\"received PONG from %s\"</span>, session.RemoteAddr())\n\t\t}\n\t}\n\n\t<span class=\"hljs-keyword\">if</span> rpcMessage.MessageType == protocal.MSGTYPE_RESQUEST ||\n\t\trpcMessage.MessageType == protocal.MSGTYPE_RESQUEST_ONEWAY {\n\t\tlog.Debugf(<span class=\"hljs-string\">\"msgId:%s, body:%v\"</span>, rpcMessage.Id, rpcMessage.Body)\n      \n\t\t<span class=\"hljs-comment\">// 处理事务消息，提交 or 回滚</span>\n\t\tclient.onMessage(rpcMessage, session.RemoteAddr())\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\tresp, loaded := client.futures.Load(rpcMessage.Id)\n\t\t<span class=\"hljs-keyword\">if</span> loaded {\n\t\t\tresponse := resp.(*getty2.MessageFuture)\n\t\t\tresponse.Response = rpcMessage.Body\n\t\t\tresponse.Done &lt;- <span class=\"hljs-literal\">true</span>\n\t\t\tclient.futures.Delete(rpcMessage.Id)\n\t\t}\n\t}\n}\n\n<span class=\"hljs-comment\">// OnCron ...</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(client *RpcRemoteClient)</span> <span class=\"hljs-title\">OnCron</span><span class=\"hljs-params\">(session getty.Session)</span></span> {\n  <span class=\"hljs-comment\">// 发送心跳</span>\n\tclient.defaultSendRequest(session, protocal.HeartBeatMessagePing)\n}\n</code></pre>\n<p><code>clientSessionManager.RegisterGettySession(session)</code> 的逻辑 4.4 小节分析。</p>\n<h4>4.3 Server 端 Transaction Coordinator 实现</h4>\n<p>代码见 <a href=\"https://github.com/opentrx/seata-golang/blob/dev/tc/server/default_coordinator_event_listener.go\"><code>DefaultCoordinator</code></a>：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(coordinator *DefaultCoordinator)</span> <span class=\"hljs-title\">OnOpen</span><span class=\"hljs-params\">(session getty.Session)</span> <span class=\"hljs-title\">error</span></span> {\n\tlog.Infof(<span class=\"hljs-string\">\"got getty_session:%s\"</span>, session.Stat())\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(coordinator *DefaultCoordinator)</span> <span class=\"hljs-title\">OnError</span><span class=\"hljs-params\">(session getty.Session, err error)</span></span> {\n\t<span class=\"hljs-comment\">// 释放 TCP 连接</span>\n  SessionManager.ReleaseGettySession(session)\n\tsession.Close()\n\tlog.Errorf(<span class=\"hljs-string\">\"getty_session{%s} got error{%v}, will be closed.\"</span>, session.Stat(), err)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(coordinator *DefaultCoordinator)</span> <span class=\"hljs-title\">OnClose</span><span class=\"hljs-params\">(session getty.Session)</span></span> {\n\tlog.Info(<span class=\"hljs-string\">\"getty_session{%s} is closing......\"</span>, session.Stat())\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(coordinator *DefaultCoordinator)</span> <span class=\"hljs-title\">OnMessage</span><span class=\"hljs-params\">(session getty.Session, pkg <span class=\"hljs-keyword\">interface</span>{})</span></span> {\n\tlog.Debugf(<span class=\"hljs-string\">\"received message:{%v}\"</span>, pkg)\n\trpcMessage, ok := pkg.(protocal.RpcMessage)\n\t<span class=\"hljs-keyword\">if</span> ok {\n\t\t_, isRegTM := rpcMessage.Body.(protocal.RegisterTMRequest)\n\t\t<span class=\"hljs-keyword\">if</span> isRegTM {\n      <span class=\"hljs-comment\">// 将 TransactionManager 信息和 TCP 连接建立映射关系</span>\n\t\t\tcoordinator.OnRegTmMessage(rpcMessage, session)\n\t\t\t<span class=\"hljs-keyword\">return</span>\n\t\t}\n\n\t\theartBeat, isHeartBeat := rpcMessage.Body.(protocal.HeartBeatMessage)\n\t\t<span class=\"hljs-keyword\">if</span> isHeartBeat &amp;&amp; heartBeat == protocal.HeartBeatMessagePing {\n\t\t\tcoordinator.OnCheckMessage(rpcMessage, session)\n\t\t\t<span class=\"hljs-keyword\">return</span>\n\t\t}\n\n\t\t<span class=\"hljs-keyword\">if</span> rpcMessage.MessageType == protocal.MSGTYPE_RESQUEST ||\n\t\t\trpcMessage.MessageType == protocal.MSGTYPE_RESQUEST_ONEWAY {\n\t\t\tlog.Debugf(<span class=\"hljs-string\">\"msgId:%s, body:%v\"</span>, rpcMessage.Id, rpcMessage.Body)\n\t\t\t_, isRegRM := rpcMessage.Body.(protocal.RegisterRMRequest)\n\t\t\t<span class=\"hljs-keyword\">if</span> isRegRM {\n        <span class=\"hljs-comment\">// 将 ResourceManager 信息和 TCP 连接建立映射关系</span>\n\t\t\t\tcoordinator.OnRegRmMessage(rpcMessage, session)\n\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> SessionManager.IsRegistered(session) {\n\t\t\t\t\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n\t\t\t\t\t\t<span class=\"hljs-keyword\">if</span> err := <span class=\"hljs-built_in\">recover</span>(); err != <span class=\"hljs-literal\">nil</span> {\n\t\t\t\t\t\t\tlog.Errorf(<span class=\"hljs-string\">\"Catch Exception while do RPC, request: %v,err: %w\"</span>, rpcMessage, err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}()\n          <span class=\"hljs-comment\">// 处理事务消息，全局事务注册、分支事务注册、分支事务提交、全局事务回滚等</span>\n\t\t\t\t\tcoordinator.OnTrxMessage(rpcMessage, session)\n\t\t\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t\t\tsession.Close()\n\t\t\t\t\tlog.Infof(<span class=\"hljs-string\">\"close a unhandled connection! [%v]\"</span>, session)\n\t\t\t\t}\n\t\t\t}\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\tresp, loaded := coordinator.futures.Load(rpcMessage.Id)\n\t\t\t<span class=\"hljs-keyword\">if</span> loaded {\n\t\t\t\tresponse := resp.(*getty2.MessageFuture)\n\t\t\t\tresponse.Response = rpcMessage.Body\n\t\t\t\tresponse.Done &lt;- <span class=\"hljs-literal\">true</span>\n\t\t\t\tcoordinator.futures.Delete(rpcMessage.Id)\n\t\t\t}\n\t\t}\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(coordinator *DefaultCoordinator)</span> <span class=\"hljs-title\">OnCron</span><span class=\"hljs-params\">(session getty.Session)</span></span> {\n\n}\n</code></pre>\n<p><code>coordinator.OnRegTmMessage(rpcMessage, session)</code> 注册 Transaction Manager，<code>coordinator.OnRegRmMessage(rpcMessage, session)</code> 注册 Resource Manager。具体逻辑分析见 4.4 小节。\n消息进入 <code>coordinator.OnTrxMessage(rpcMessage, session)</code> 方法，将按照消息的类型码路由到具体的逻辑当中：</p>\n<pre><code class=\"language-go\">\t<span class=\"hljs-keyword\">switch</span> msg.GetTypeCode() {\n\t<span class=\"hljs-keyword\">case</span> protocal.TypeGlobalBegin:\n\t\treq := msg.(protocal.GlobalBeginRequest)\n\t\tresp := coordinator.doGlobalBegin(req, ctx)\n\t\t<span class=\"hljs-keyword\">return</span> resp\n\t<span class=\"hljs-keyword\">case</span> protocal.TypeGlobalStatus:\n\t\treq := msg.(protocal.GlobalStatusRequest)\n\t\tresp := coordinator.doGlobalStatus(req, ctx)\n\t\t<span class=\"hljs-keyword\">return</span> resp\n\t<span class=\"hljs-keyword\">case</span> protocal.TypeGlobalReport:\n\t\treq := msg.(protocal.GlobalReportRequest)\n\t\tresp := coordinator.doGlobalReport(req, ctx)\n\t\t<span class=\"hljs-keyword\">return</span> resp\n\t<span class=\"hljs-keyword\">case</span> protocal.TypeGlobalCommit:\n\t\treq := msg.(protocal.GlobalCommitRequest)\n\t\tresp := coordinator.doGlobalCommit(req, ctx)\n\t\t<span class=\"hljs-keyword\">return</span> resp\n\t<span class=\"hljs-keyword\">case</span> protocal.TypeGlobalRollback:\n\t\treq := msg.(protocal.GlobalRollbackRequest)\n\t\tresp := coordinator.doGlobalRollback(req, ctx)\n\t\t<span class=\"hljs-keyword\">return</span> resp\n\t<span class=\"hljs-keyword\">case</span> protocal.TypeBranchRegister:\n\t\treq := msg.(protocal.BranchRegisterRequest)\n\t\tresp := coordinator.doBranchRegister(req, ctx)\n\t\t<span class=\"hljs-keyword\">return</span> resp\n\t<span class=\"hljs-keyword\">case</span> protocal.TypeBranchStatusReport:\n\t\treq := msg.(protocal.BranchReportRequest)\n\t\tresp := coordinator.doBranchReport(req, ctx)\n\t\t<span class=\"hljs-keyword\">return</span> resp\n\t<span class=\"hljs-keyword\">default</span>:\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t}\n</code></pre>\n<h4>4.4 session manager 分析</h4>\n<p>Client 端同 Transaction Coordinator 建立连接起连接后，通过 <code>clientSessionManager.RegisterGettySession(session)</code> 将连接保存在 <code>serverSessions = sync.Map{}</code> 这个 map 中。map 的 key 为从 session 中获取的 RemoteAddress 即 Transaction Coordinator 的地址，value 为 session。这样，Client 端就可以通过 map 中的一个 session 来向 Transaction Coordinator 注册 Transaction Manager 和 Resource Manager 了。具体代码见 <a href=\"https://github.com/opentrx/seata-golang/blob/dev/pkg/client/getty_client_session_manager.go\"><code>getty_client_session_manager.go</code>。</a>\nTransaction Manager 和 Resource Manager 注册到 Transaction Coordinator 后，一个连接既有可能用来发送 TM 消息也有可能用来发送 RM 消息。我们通过 RpcContext 来标识一个连接信息：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> RpcContext <span class=\"hljs-keyword\">struct</span> {\n\tVersion                 <span class=\"hljs-keyword\">string</span>\n\tTransactionServiceGroup <span class=\"hljs-keyword\">string</span>\n\tClientRole              meta.TransactionRole\n\tApplicationId           <span class=\"hljs-keyword\">string</span>\n\tClientId                <span class=\"hljs-keyword\">string</span>\n\tResourceSets            *model.Set\n\tSession                 getty.Session\n}\n</code></pre>\n<p>当收到事务消息时，我们需要构造这样一个 RpcContext 供后续事务处理逻辑使用。所以，我们会构造下列 map 来缓存映射关系：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">var</span> (\n\t<span class=\"hljs-comment\">// session -&gt; transactionRole</span>\n\t<span class=\"hljs-comment\">// TM will register before RM, if a session is not the TM registered,</span>\n\t<span class=\"hljs-comment\">// it will be the RM registered</span>\n\tsession_transactionroles = sync.Map{}\n\n\t<span class=\"hljs-comment\">// session -&gt; applicationId</span>\n\tidentified_sessions = sync.Map{}\n\n\t<span class=\"hljs-comment\">// applicationId -&gt; ip -&gt; port -&gt; session</span>\n\tclient_sessions = sync.Map{}\n\n\t<span class=\"hljs-comment\">// applicationId -&gt; resourceIds</span>\n\tclient_resources = sync.Map{}\n)\n</code></pre>\n<p>这样，Transaction Manager 和 Resource Manager 分别通过 <code>coordinator.OnRegTmMessage(rpcMessage, session)</code> 和 <code>coordinator.OnRegRmMessage(rpcMessage, session)</code> 注册到 Transaction Coordinator 时，会在上述 client_sessions map 中缓存 applicationId、ip、port 与 session 的关系，在 client_resources map 中缓存 applicationId 与 resourceIds（一个应用可能存在多个 Resource Manager） 的关系。在需要时，我们就可以通过上述映射关系构造一个 RpcContext。这部分的实现和 java 版 seata 有很大的不同，感兴趣的可以深入了解一下。具体代码见 <a href=\"https://github.com/opentrx/seata-golang/blob/dev/tc/server/getty_session_manager.go\"><code>getty_session_manager.go</code>。</a>\n至此，我们就分析完了 <a href=\"https://github.com/opentrx/seata-golang\">seata-golang</a> 整个 RPC 通信模型的机制。</p>\n<h2>三、seata-golang 的未来</h2>\n<p><a href=\"https://github.com/opentrx/seata-golang\">seata-golang</a>  从今年 4 月份开始开发，到 8 月份基本实现和 java 版 <a href=\"https://github.com/seata/seata\">seata 1.2</a> 协议的互通，对 mysql 数据库实现了 AT 模式（自动协调分布式事务的提交回滚），实现了 TCC 模式，TC 端使用 mysql 存储数据，使 TC 变成一个无状态应用支持高可用部署。下图展示了 AT 模式的原理：<img src=\"https://img.alicdn.com/imgextra/i3/O1CN01alqsQS1G2oQecFYIs_!!6000000000565-2-tps-1025-573.png\" alt=\"image20201205-232516.png\"></p>\n<p>后续，还有许多工作可以做，比如：对注册中心的支持、对配置中心的支持、和 java 版 seata 1.4 的协议互通、其他数据库的支持、raft transaction coordinator 的实现等，希望对分布式事务问题感兴趣的开发者可以加入进来一起来打造一个完善的 golang 的分布式事务框架。</p>\n<p>如果你有任何疑问，欢迎钉钉扫码加入交流群【钉钉群号 33069364】：\n<img src=\"https://img.alicdn.com/imgextra/i2/O1CN01IjOVG425erjuzqcOi_!!6000000007552-2-tps-600-621.png\" width=\"200px\" /></p>\n<h3><strong>作者简介</strong></h3>\n<p>刘晓敏 (GitHubID dk-lockdown)，目前就职于 h3c 成都分公司，擅长使用 Java/Go 语言，在云原生和微服务相关技术方向均有涉猎，目前专攻分布式事务。\n于雨(github @AlexStocks)，dubbo-go 项目和社区负责人，一个有十多年服务端基础架构研发一线工作经验的程序员，陆续参与改进过 Muduo/Pika/Dubbo/Sentinel-go 等知名项目，目前在蚂蚁金服可信原生部从事容器编排和 service mesh 工作。</p>\n<h4>参考资料</h4>\n<p>seata 官方：<a href=\"https://seata.io\">https://seata.io</a></p>\n<p>java 版 seata：<a href=\"https://github.com/seata/seata\">https://github.com/seata/seata</a></p>\n<p>seata-golang 项目地址：<a href=\"https://github.com/transaction-wg/seata-golang\">https://github.com/opentrx/seata-golang</a></p>\n<p>seata-golang go 夜读 b站分享：<a href=\"https://www.bilibili.com/video/BV1oz411e72T\">https://www.bilibili.com/video/BV1oz411e72T</a></p>\n",
  "link": "/zh-cn/blog/seata-golang-communication-mode.html",
  "meta": {
    "title": "seata-golang 通信模型详解",
    "keywords": "seata,seata-golang,seata-go,getty,分布式事务",
    "description": "本文详细讲述 seata-golang 底层 rpc 通信的实现原理",
    "author": "刘晓敏",
    "date": "2021/01/04"
  }
}